// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/david/sync/projects/able/.tmp/gomod/github.com/tree-sitter/go-tree-sitter@v0.25.0/parser.go:1:1
package tree_sitter

/*
#cgo CFLAGS: -Iinclude -Isrc -std=c11 -D_POSIX_C_SOURCE=200112L -D_DEFAULT_SOURCE
#include <tree_sitter/api.h>
#include <stdio.h>

extern void logCallback(void *payload, TSLogType log_type, char *message);
extern char *readUTF8(void *payload, uint32_t byte_index, TSPoint position, uint32_t *bytes_read);
extern char *readUTF16LE(void *payload, uint32_t byte_offset, TSPoint position, uint32_t *bytes_read);
extern char *readUTF16BE(void *payload, uint32_t byte_offset, TSPoint position, uint32_t *bytes_read);
extern bool parserProgressCallback(TSParseState *state);
extern char *readCustomEncoding(void *payload, uint32_t byte_offset, TSPoint position, uint32_t *bytes_read);
*/
import _ "unsafe"

import (
	"context"
	"os"
	"sync/atomic"
	"unsafe"

	"github.com/mattn/go-pointer"
)

// A stateful object that this is used to produce a [Tree] based on some
// source code.
type Parser struct {
	_inner * /*line :29:10*/_Ctype_TSParser /*line :29:20*/
}

// A stateful object that is passed into the progress callback [ParseOptions.ProgressCallback]
// to provide the current state of the parser.
type ParseState struct {
	// The byte offset in the document that the parser is at.
	CurrentByteOffset uint32

	// Indicates whether the parser has encountered an error during parsing.
	HasError bool
}

// Options for parsing
//
// The [ParseOptions.ProgressCallback] property is a function that is called periodically
// during parsing to check whether parsing should be cancelled.
//
// See [Parser.ParseWithOptions] for more information.
type ParseOptions struct {
	// A function that is called periodically during parsing to check
	// whether parsing should be cancelled. If the progress callback returns
	// `true`, then parsing will be cancelled. You can also use this to instrument
	// parsing and check where the parser is at in the document. The progress callback
	// takes a single argument, which is a [ParseState] representing the current
	// state of the parser.
	ProgressCallback func(ParseState) bool
}

// Create a new parser.
func NewParser() *Parser {
	return &Parser{_inner: ( /*line :60:25*/_Cfunc_ts_parser_new /*line :60:39*/)()}
}

func (p *Parser) Close() {
	p.StopPrintingDotGraphs()
	p.SetLogger(nil)
	func() { _cgo0 := /*line :66:21*/p._inner; _cgoCheckPointer(_cgo0, nil); /*line :66:30*/_Cfunc_ts_parser_delete(_cgo0); }()
}

// Set the language that the parser should use for parsing.
//
// Returns an error indicating whether or not the language was successfully
// assigned. Nil means assignment succeeded. Non-nil means there was a
// version mismatch: the language was generated with an incompatible
// version of the Tree-sitter CLI. Check the language's ABI version using
// [Language.Version] and compare it to this library's [LANGUAGE_VERSION] and
// [MIN_COMPATIBLE_LANGUAGE_VERSION] constants.
func (p *Parser) SetLanguage(l *Language) error {
	version := l.AbiVersion()
	if version >= MIN_COMPATIBLE_LANGUAGE_VERSION && version <= LANGUAGE_VERSION {
		func() _Ctype__Bool{ _cgo0 := /*line :80:28*/p._inner; _cgo1 := /*line :80:38*/l.Inner; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :80:46*/_Cfunc_ts_parser_set_language(_cgo0, _cgo1); }()
		return nil
	}
	return &LanguageError{version}
}

// Get the parser's current language.
func (p *Parser) Language() *Language {
	ptr := func() *_Ctype_struct_TSLanguage{ _cgo0 := /*line :88:30*/p._inner; _cgoCheckPointer(_cgo0, nil); return /*line :88:39*/_Cfunc_ts_parser_language(_cgo0); }()
	if ptr == nil {
		return nil
	}
	return &Language{Inner: ptr}
}

// A callback that receives log messages during parser.
//
//export logCallback
func logCallback(payload unsafe.Pointer, cLogType  /*line :98:51*/_Ctype_TSLogType /*line :98:62*/, cMessage * /*line :98:74*/_Ctype_char /*line :98:80*/) {
	logger := pointer.Restore(payload).(Logger)
	if logger != nil {
		message := ( /*line :101:14*/_Cfunc_GoString /*line :101:23*/)(cMessage)
		var logType LogType
		if cLogType == ( /*line :103:18*/_Ciconst_TSLogTypeParse /*line :103:33*/) {
			logType = LogTypeParse
		} else {
			logType = LogTypeLex
		}
		logger(logType, message)
	}
}

// Set the logging callback that a parser should use during parsing.
func (p *Parser) SetLogger(logger Logger) {
	prevLogger := func() _Ctype_struct_TSLogger{ _cgo0 := /*line :114:35*/p._inner; _cgoCheckPointer(_cgo0, nil); return /*line :114:44*/_Cfunc_ts_parser_logger(_cgo0); }()
	if prevLogger.payload != nil {
		// Clean up the old logger
		oldLogger := (*Logger)(prevLogger.payload)
		if oldLogger != nil {
			oldLogger = nil
		}
	}

	// Prepare the new logger
	var cLogger  /*line :124:14*/_Ctype_TSLogger /*line :124:24*/
	if logger != nil {
		cptr := pointer.Save(logger)

		// Set the C logger struct
		cLogger =  /*line :129:13*/_Ctype_TSLogger /*line :129:23*/{
			payload: cptr,
			log:     (*[0]byte)(( /*line :131:24*/_Cgo_ptr(_Cfpvar_fp_logCallback) /*line :131:36*/)),
		}
	} else {
		// Set a null logger if none is provided
		cLogger =  /*line :135:13*/_Ctype_TSLogger /*line :135:23*/{
			payload: nil,
			log:     nil,
		}
	}

	// Set the new logger in the parser
	func() { _cgo0 := /*line :142:25*/p._inner; _cgo1 := /*line :142:35*/cLogger; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); /*line :142:43*/_Cfunc_ts_parser_set_logger(_cgo0, _cgo1); }()
}

// Get the parser's current logger.
func (p *Parser) Logger() *Logger {
	logger := func() _Ctype_struct_TSLogger{ _cgo0 := /*line :147:31*/p._inner; _cgoCheckPointer(_cgo0, nil); return /*line :147:40*/_Cfunc_ts_parser_logger(_cgo0); }()
	return (*Logger)(logger.payload)
}

// Set the destination to which the parser should write debugging graphs
// during parsing. The graphs are formatted in the DOT language. You may
// want to pipe these graphs directly to a `dot(1)` process in order to
// generate SVG output.
func (p *Parser) PrintDotGraphs(file *os.File) {
	func() { _cgo0 := /*line :156:31*/p._inner; var _cgo1 _Ctype_int = _Ctype_int /*line :156:46*/(dupeFD(file.Fd())); _cgoCheckPointer(_cgo0, nil); /*line :156:66*/_Cfunc_ts_parser_print_dot_graphs(_cgo0, _cgo1); }()
}

// Stop the parser from printing debugging graphs while parsing.
func (p *Parser) StopPrintingDotGraphs() {
	func() { _cgo0 := /*line :161:31*/p._inner; var _cgo1 _Ctype_int = _Ctype_int /*line :161:46*/(-1); _cgoCheckPointer(_cgo0, nil); /*line :161:51*/_Cfunc_ts_parser_print_dot_graphs(_cgo0, _cgo1); }()
}

// Parse a slice of UTF8 text.
//
// # Arguments:
//   - `text` The UTF8-encoded text to parse.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
func (p *Parser) Parse(text []byte, oldTree *Tree) *Tree {
	length := len(text)
	return p.ParseWithOptions(func(i int, _ Point) []byte {
		if i < length {
			return text[i:]
		}
		return []byte{}
	}, oldTree, nil)
}

// Deprecated: Use [Parser.ParseWithOptions] instead, and handle cancellation in the callback, this will be removed in 0.26.
//
// Parse a slice of UTF8 text.
//
// # Arguments:
//   - `ctx` The context to parse with.
//   - `text` The UTF8-encoded text to parse.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
func (p *Parser) ParseCtx(ctx context.Context, text []byte, oldTree *Tree) *Tree {
	finish := make(chan struct{})

	if ctx.Done() != nil {
		go func() {
			select {
			case <-ctx.Done():
				atomic.StoreUintptr(p.CancellationFlag(), 1)
			case <-finish:
				return
			}
		}()
	}

	tree := p.Parse(text, oldTree)
	close(finish)

	return tree
}

// Deprecated: Use [Parser.ParseUTF16LE] or [Parser.ParseUTF16BE] instead.
// Parse a slice of UTF16 text.
//
// # Arguments:
//   - `text` The UTF16-encoded text to parse.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
func (p *Parser) ParseUTF16(text []uint16, oldTree *Tree) *Tree {
	length := len(text)
	return p.ParseUTF16With(func(i int, _ Point) []uint16 {
		if i < length {
			return text[i:]
		}
		return []uint16{}
	}, oldTree)
}

// / Parse a slice of UTF16 little-endian text.
// /
// / # Arguments:
// / * `text` The UTF16-encoded text to parse.
// / * `old_tree` A previous syntax tree parsed from the same document. If the text of the
// /   document has changed since `old_tree` was created, then you must edit `old_tree` to match
// /   the new text using [Tree.Edit].
func (p *Parser) ParseUTF16LE(text []uint16, oldTree *Tree) *Tree {
	length := len(text)
	return p.ParseUTF16LEWith(func(i int, _ Point) []uint16 {
		if i < length {
			return text[i:]
		}
		return []uint16{}
	}, oldTree)
}

// / Parse a slice of UTF16 big-endian text.
// /
// / # Arguments:
// / * `text` The UTF16-encoded text to parse.
// / * `old_tree` A previous syntax tree parsed from the same document. If the text of the
// /   document has changed since `old_tree` was created, then you must edit `old_tree` to match
// /   the new text using [Tree.Edit].
func (p *Parser) ParseUTF16BE(text []uint16, oldTree *Tree) *Tree {
	length := len(text)
	return p.ParseUTF16BEWith(func(i int, _ Point) []uint16 {
		if i < length {
			return text[i:]
		}
		return []uint16{}
	}, oldTree)
}

type payload[T any] struct {
	callback func(int, Point) []T
	text     []T
	cStrings []* /*line :266:14*/_Ctype_char /*line :266:20*/
}

// This C function is passed to Tree-sitter as the input callback.
//
//export readUTF8
func readUTF8(_payload unsafe.Pointer, byteIndex  /*line :272:50*/_Ctype_uint32_t /*line :272:60*/, position  /*line :272:71*/_Ctype_TSPoint /*line :272:80*/, bytesRead * /*line :272:93*/_Ctype_uint32_t /*line :272:103*/) * /*line :272:106*/_Ctype_char /*line :272:112*/ {
	payload := pointer.Restore(_payload).(*payload[byte])
	payload.text = payload.callback(int(byteIndex), Point{uint(position.row), uint(position.column)})
	*bytesRead =  /*line :275:15*/_Ctype_uint32_t /*line :275:25*/(len(payload.text))
	strbytes := ( /*line :276:14*/_Cfunc_CString /*line :276:22*/)(string(payload.text))
	payload.cStrings = append(payload.cStrings, strbytes)
	return strbytes
}

// This C function is passed to Tree-sitter as the progress callback.
//
//export parserProgressCallback
func parserProgressCallback(state * /*line :284:36*/_Ctype_TSParseState /*line :284:50*/)  /*line :284:52*/_Ctype_bool /*line :284:58*/ {
	payload := pointer.Restore(state.payload).(*ParseOptions)
	return  /*line :286:9*/_Ctype_bool /*line :286:15*/(payload.ProgressCallback(ParseState{
		CurrentByteOffset: uint32(state.current_byte_offset),
		HasError:          bool(state.has_error),
	}))
}

// Deprecated: Use [Parser.ParseWithOptions] instead, this will be removed in 0.26.
//
// Parse UTF8 text provided in chunks by a callback.
//
// # Arguments:
//   - `callback` A function that takes a byte offset and position and returns a slice of
//     UTF8-encoded text starting at that byte offset and position. The slices can be of any
//     length. If the given position is at the end of the text, the callback should return an
//     empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
func (p *Parser) ParseWith(callback func(int, Point) []byte, oldTree *Tree) *Tree {
	return p.ParseWithOptions(callback, oldTree, nil)
}

// Parse UTF8 text provided in chunks by a callback.
//
// # Arguments:
//   - `callback` A function that takes a byte offset and position and returns a slice of
//     UTF8-encoded text starting at that byte offset and position. The slices can be of any
//     length. If the given position is at the end of the text, the callback should return an
//     empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
//   - `options` Options for parsing the text. This can be used to set a progress callback, or context.
func (p *Parser) ParseWithOptions(callback func(int, Point) []byte, oldTree *Tree, options *ParseOptions) *Tree {
	payload := payload[byte]{
		callback: callback,
		text:     nil,
		cStrings: make([]* /*line :323:21*/_Ctype_char /*line :323:27*/, 0),
	}

	defer func() {
		for _, cString := range payload.cStrings {
			go_free(unsafe.Pointer(cString))
		}
	}()

	cptr := pointer.Save(&payload)
	defer pointer.Unref(cptr)

	cInput :=  /*line :335:12*/_Ctype_TSInput /*line :335:21*/{
		payload:  unsafe.Pointer(cptr),
		read:     (*[0]byte)(( /*line :337:24*/_Cgo_ptr(_Cfpvar_fp_readUTF8) /*line :337:33*/)),
		encoding: ( /*line :338:13*/_Ciconst_TSInputEncodingUTF8 /*line :338:33*/),
	}

	var cOldTree * /*line :341:16*/_Ctype_TSTree /*line :341:24*/
	if oldTree != nil {
		cOldTree = oldTree._inner
	}

	var cOptions  /*line :346:15*/_Ctype_TSParseOptions /*line :346:31*/
	if options != nil {
		cOptions =  /*line :348:14*/_Ctype_TSParseOptions /*line :348:30*/{
			progress_callback: (*[0]byte)(( /*line :349:34*/_Cgo_ptr(_Cfpvar_fp_parserProgressCallback) /*line :349:57*/)),
			payload:           pointer.Save(options),
		}
	}

	cNewTree := func() *_Ctype_struct_TSTree{ _cgo0 := /*line :354:45*/p._inner; _cgo1 := /*line :354:55*/cOldTree; _cgo2 := /*line :354:65*/cInput; _cgo3 := /*line :354:73*/cOptions; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :354:82*/_Cfunc_ts_parser_parse_with_options(_cgo0, _cgo1, _cgo2, _cgo3); }()

	if cNewTree != nil {
		return newTree(cNewTree)
	}

	return nil
}

func cStringUTF16(s []uint16) * /*line :363:32*/_Ctype_char /*line :363:38*/ {
	if len(s)+1 <= 0 {
		panic("string too large")
	}
	p := _cgo_cmalloc(uint64((len(s) + 1) * 2))
	sliceHeader := struct {
		p   unsafe.Pointer
		len int
		cap int
	}{p, len(s) + 1, len(s) + 1}
	b := *(*[]uint16)(unsafe.Pointer(&sliceHeader))
	copy(b, s)
	b[len(s)] = 0
	return (* /*line :376:11*/_Ctype_char /*line :376:17*/)(p)
}

// This C function is passed to Tree-sitter as the input callback.
//
//export readUTF16LE
func readUTF16LE(_payload unsafe.Pointer, byteOffset uint32, position  /*line :382:71*/_Ctype_TSPoint /*line :382:80*/, bytesRead *uint32) * /*line :382:102*/_Ctype_char /*line :382:108*/ {
	payload := pointer.Restore(_payload).(*payload[uint16])
	payload.text = payload.callback(int(byteOffset/2), Point{uint(position.row), uint(position.column / 2)})
	*bytesRead = uint32(len(payload.text) * 2)
	strbytes := cStringUTF16(payload.text)
	payload.cStrings = append(payload.cStrings, strbytes)
	return strbytes
}

// This C function is passed to Tree-sitter as the input callback.
//
//export readUTF16BE
func readUTF16BE(_payload unsafe.Pointer, byteOffset uint32, position  /*line :394:71*/_Ctype_TSPoint /*line :394:80*/, bytesRead *uint32) * /*line :394:102*/_Ctype_char /*line :394:108*/ {
	payload := pointer.Restore(_payload).(*payload[uint16])
	payload.text = payload.callback(int(byteOffset/2), Point{uint(position.row), uint(position.column / 2)})
	*bytesRead = uint32(len(payload.text) * 2)
	strbytes := cStringUTF16(payload.text)
	payload.cStrings = append(payload.cStrings, strbytes)
	return strbytes
}

// Deprecated: Use [Parser.ParseUTF16LEWith] or [Parser.ParseUTF16BEWith] instead, this will be removed in 0.26.
//
// Parse UTF16 text provided in chunks by a callback.
//
// # Arguments:
//   - `callback` A function that takes a code point offset and position and returns a slice of
//     UTF16-encoded text starting at that byte offset and position. The slices can be of any
//     length. If the given position is at the end of the text, the callback should return an
//     empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
func (p *Parser) ParseUTF16With(callback func(int, Point) []uint16, oldTree *Tree) *Tree {
	return p.ParseUTF16LEWith(callback, oldTree)
}

// Deprecated: Use [Parser.ParseUTF16LEWithOptions] instead, this will be removed in 0.26.
//
// Parse UTF16 little-endian text provided in chunks by a callback.
//
// # Arguments:
//   - `callback` A function that takes a code point offset and position and returns a slice of
//     UTF16-encoded text starting at that byte offset and position. The slices can be of any
//     length. If the given position is at the end of the text, the callback should return an
//     empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
func (p *Parser) ParseUTF16LEWith(callback func(int, Point) []uint16, oldTree *Tree) *Tree {
	return p.ParseUTF16LEWithOptions(callback, oldTree, nil)
}

// Parse UTF16 little-endian text provided in chunks by a callback.
//
// # Arguments:
//   - `callback` A function that takes a code point offset and position and returns a slice of
//     UTF16-encoded text starting at that byte offset and position. The slices can be of any
//     length. If the given position is at the end of the text, the callback should return an
//     empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
//   - `options` Options for parsing the text. This can be used to set a progress callback.
func (p *Parser) ParseUTF16LEWithOptions(callback func(int, Point) []uint16, oldTree *Tree, options *ParseOptions) *Tree {
	payload := payload[uint16]{
		callback: callback,
		text:     nil,
		cStrings: make([]* /*line :450:21*/_Ctype_char /*line :450:27*/, 0),
	}

	defer func() {
		for _, cString := range payload.cStrings {
			go_free(unsafe.Pointer(cString))
		}
	}()

	cptr := pointer.Save(&payload)
	defer pointer.Unref(cptr)

	cInput :=  /*line :462:12*/_Ctype_TSInput /*line :462:21*/{
		payload:  unsafe.Pointer(cptr),
		read:     (*[0]byte)(( /*line :464:24*/_Cgo_ptr(_Cfpvar_fp_readUTF16LE) /*line :464:36*/)),
		encoding: ( /*line :465:13*/_Ciconst_TSInputEncodingUTF16LE /*line :465:36*/),
	}

	var cOldTree * /*line :468:16*/_Ctype_TSTree /*line :468:24*/
	if oldTree != nil {
		cOldTree = oldTree._inner
	}

	var cOptions  /*line :473:15*/_Ctype_TSParseOptions /*line :473:31*/
	if options != nil {
		cOptions =  /*line :475:14*/_Ctype_TSParseOptions /*line :475:30*/{
			progress_callback: (*[0]byte)(( /*line :476:34*/_Cgo_ptr(_Cfpvar_fp_parserProgressCallback) /*line :476:57*/)),
			payload:           pointer.Save(options),
		}
	}

	cNewTree := func() *_Ctype_struct_TSTree{ _cgo0 := /*line :481:45*/p._inner; _cgo1 := /*line :481:55*/cOldTree; _cgo2 := /*line :481:65*/cInput; _cgo3 := /*line :481:73*/cOptions; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :481:82*/_Cfunc_ts_parser_parse_with_options(_cgo0, _cgo1, _cgo2, _cgo3); }()

	if cNewTree != nil {
		return newTree(cNewTree)
	}

	return nil
}

// Deprecated: Use [Parser.ParseUTF16BEWithOptions] instead, this will be removed in 0.26.
//
// Parse UTF16 big-endian text provided in chunks by a callback.
//
// # Arguments:
//   - `callback` A function that takes a code point offset and position and returns a slice of
//     UTF16-encoded text starting at that byte offset and position. The slices can be of any
//     length. If the given position is at the end of the text, the callback should return an
//     empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
func (p *Parser) ParseUTF16BEWith(callback func(int, Point) []uint16, oldTree *Tree) *Tree {
	return p.ParseUTF16BEWithOptions(callback, oldTree, nil)
}

// Parse UTF16 big-endian text provided in chunks by a callback.
//
// # Arguments:
//   - `callback` A function that takes a code point offset and position and returns a slice of
//     UTF16-encoded text starting at that byte offset and position. The slices can be of any
//     length. If the given position is at the end of the text, the callback should return an
//     empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [Tree.Edit].
//   - `options` Options for parsing the text. This can be used to set a progress callback.
func (p *Parser) ParseUTF16BEWithOptions(callback func(int, Point) []uint16, oldTree *Tree, options *ParseOptions) *Tree {
	payload := payload[uint16]{
		callback: callback,
		text:     nil,
		cStrings: make([]* /*line :521:21*/_Ctype_char /*line :521:27*/, 0),
	}

	defer func() {
		for _, cString := range payload.cStrings {
			go_free(unsafe.Pointer(cString))
		}
	}()

	cptr := pointer.Save(&payload)
	defer pointer.Unref(cptr)

	cInput :=  /*line :533:12*/_Ctype_TSInput /*line :533:21*/{
		payload:  unsafe.Pointer(cptr),
		read:     (*[0]byte)(( /*line :535:24*/_Cgo_ptr(_Cfpvar_fp_readUTF16BE) /*line :535:36*/)),
		encoding: ( /*line :536:13*/_Ciconst_TSInputEncodingUTF16BE /*line :536:36*/),
	}

	var cOldTree * /*line :539:16*/_Ctype_TSTree /*line :539:24*/
	if oldTree != nil {
		cOldTree = oldTree._inner
	}

	var cOptions  /*line :544:15*/_Ctype_TSParseOptions /*line :544:31*/
	if options != nil {
		cOptions =  /*line :546:14*/_Ctype_TSParseOptions /*line :546:30*/{
			progress_callback: (*[0]byte)(( /*line :547:34*/_Cgo_ptr(_Cfpvar_fp_parserProgressCallback) /*line :547:57*/)),
			payload:           pointer.Save(options),
		}
	}

	cNewTree := func() *_Ctype_struct_TSTree{ _cgo0 := /*line :552:45*/p._inner; _cgo1 := /*line :552:55*/cOldTree; _cgo2 := /*line :552:65*/cInput; _cgo3 := /*line :552:73*/cOptions; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :552:82*/_Cfunc_ts_parser_parse_with_options(_cgo0, _cgo1, _cgo2, _cgo3); }()

	if cNewTree != nil {
		return newTree(cNewTree)
	}

	return nil
}

// Decoder interface defines the required method for custom decoding
type Decoder interface {
	// Decode takes a byte slice and returns the decoded code point and number of bytes consumed
	// Returns -1 as codePoint if decoding fails
	Decode(data []byte) (codePoint int32, bytesRead uint32)
}

//export readCustomEncoding
func readCustomEncoding(_payload unsafe.Pointer, byteOffset  /*line :569:61*/_Ctype_uint32_t /*line :569:71*/, position  /*line :569:82*/_Ctype_TSPoint /*line :569:91*/, bytesRead * /*line :569:104*/_Ctype_uint32_t /*line :569:114*/) * /*line :569:117*/_Ctype_char /*line :569:123*/ {
	payload := pointer.Restore(_payload).(*payload[byte])
	payload.text = payload.callback(int(byteOffset), Point{uint(position.row), uint(position.column)})
	*bytesRead =  /*line :572:15*/_Ctype_uint32_t /*line :572:25*/(len(payload.text))
	strbytes := ( /*line :573:14*/_Cfunc_CString /*line :573:22*/)(string(payload.text))
	payload.cStrings = append(payload.cStrings, strbytes)
	return strbytes
}

// Parse text provided in chunks by a callback using a custom encoding.
// This is useful for parsing text in encodings that are not UTF-8 or UTF-16.
//
// # Arguments:
//   - `callback` A function that takes a byte offset and position and returns a slice of text
//     starting at that byte offset and position. The slices can be of any length. If the given
//     position is at the end of the text, the callback should return an empty slice.
//   - `old_tree` A previous syntax tree parsed from the same document. If the text of the
//     document has changed since `old_tree` was created, then you must edit `old_tree` to match
//     the new text using [`Tree::edit`].
//   - `options` Options for parsing the text. This can be used to set a progress callback.
//   - `decode` A function that takes a byte slice and returns the number of bytes consumed.
//     It will also write the resulting code point to `codePoint`. If decoding fails, the function
//     should write -1 to the code point. The signature for the function is the following:
//     func myDecodeFn(data *C.char, length C.uint32_t, codePoint *C.int32_t) C.uint32_t
//     Note that this function *must* be a C function, as it's called many times during parsing.
//     To have a Go function be callable from C, you must use the `//export` directive. More info
//     can be found at https://pkg.go.dev/cmd/cgo#hdr-C_references_to_Go. The reason for this is that
//     knowing the function body at compile time rather than loading it at runtime is important for
//     performance. This is also a significantly advanced feature, and should only be used if you
//     have a good reason to do so, and understand how to implement the C function. An example of
//     how to use this can be found in `parser_test.go`.
func (p *Parser) ParseCustomEncoding(
	callback func(int, Point) []byte,
	oldTree *Tree,
	options *ParseOptions,
	decode unsafe.Pointer,
) *Tree {
	payload := &payload[byte]{
		callback: callback,
		text:     nil,
		cStrings: make([]* /*line :609:21*/_Ctype_char /*line :609:27*/, 0),
	}

	cptr := pointer.Save(payload)
	defer pointer.Unref(cptr)

	cInput :=  /*line :615:12*/_Ctype_TSInput /*line :615:21*/{
		payload:  unsafe.Pointer(cptr),
		read:     (*[0]byte)(( /*line :617:24*/_Cgo_ptr(_Cfpvar_fp_readCustomEncoding) /*line :617:43*/)),
		encoding: ( /*line :618:13*/_Ciconst_TSInputEncodingCustom /*line :618:35*/),
		decode:   (*[0]byte)(decode),
	}

	var cOldTree * /*line :622:16*/_Ctype_TSTree /*line :622:24*/
	if oldTree != nil {
		cOldTree = oldTree._inner
	}

	var cOptions  /*line :627:15*/_Ctype_TSParseOptions /*line :627:31*/
	if options != nil {
		cOptions =  /*line :629:14*/_Ctype_TSParseOptions /*line :629:30*/{
			progress_callback: (*[0]byte)(( /*line :630:34*/_Cgo_ptr(_Cfpvar_fp_parserProgressCallback) /*line :630:57*/)),
			payload:           pointer.Save(options),
		}
	}

	cNewTree := func() *_Ctype_struct_TSTree{ _cgo0 := /*line :635:45*/p._inner; _cgo1 := /*line :635:55*/cOldTree; _cgo2 := /*line :635:65*/cInput; _cgo3 := /*line :635:73*/cOptions; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); return /*line :635:82*/_Cfunc_ts_parser_parse_with_options(_cgo0, _cgo1, _cgo2, _cgo3); }()

	if cNewTree != nil {
		return newTree(cNewTree)
	}

	return nil
}

// Instruct the parser to start the next parse from the beginning.
//
// If the parser previously failed because of a timeout or a cancellation,
// then by default, it will resume where it left off on the next call
// to [Parser.Parse] or other parsing functions. If you don't
// want to resume, and instead intend to use this parser to parse some
// other document, you must call `Reset` first.
func (p *Parser) Reset() {
	func() { _cgo0 := /*line :652:20*/p._inner; _cgoCheckPointer(_cgo0, nil); /*line :652:29*/_Cfunc_ts_parser_reset(_cgo0); }()
}

// Deprecated: Use [Parser.ParseWithOptions] and pass in a callback instead, this will be removed in 0.26.
//
// Get the duration in microseconds that parsing is allowed to take.
//
// This is set via [Parser.SetTimeoutMicros].
func (p *Parser) TimeoutMicros() uint64 {
	return uint64(func() _Ctype_uint64_t{ _cgo0 := /*line :661:43*/p._inner; _cgoCheckPointer(_cgo0, nil); return /*line :661:52*/_Cfunc_ts_parser_timeout_micros(_cgo0); }())
}

// Deprecated: Use [Parser.ParseWithOptions] and pass in a callback instead, this will be removed in 0.26.
//
// Set the maximum duration in microseconds that parsing should be allowed
// to take before halting.
//
// If parsing takes longer than this, it will halt early, returning `nil`.
// See [Parser.Parse] for more information.
func (p *Parser) SetTimeoutMicros(timeoutMicros uint64) {
	func() { _cgo0 := /*line :672:33*/p._inner; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :672:53*/(timeoutMicros); _cgoCheckPointer(_cgo0, nil); /*line :672:69*/_Cfunc_ts_parser_set_timeout_micros(_cgo0, _cgo1); }()
}

// Get the ranges of text that the parser will include when parsing.
func (p *Parser) IncludedRanges() []Range {
	var count  /*line :677:12*/_Ctype_uint /*line :677:18*/
	ptr := func() *_Ctype_struct_TSRange{ _cgo0 := /*line :678:37*/p._inner; var _cgo1 *_Ctype_uint32_t = /*line :678:47*/&count; _cgoCheckPointer(_cgo0, nil); return /*line :678:54*/_Cfunc_ts_parser_included_ranges(_cgo0, _cgo1); }()
	ranges := make([]Range, int(count))
	for i := uintptr(0); i < uintptr(count); i++ {
		val := *(* /*line :681:13*/_Ctype_TSRange /*line :681:22*/)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + i*unsafe.Sizeof(*ptr)))
		ranges[i] = Range{
			StartByte:  uint(val.start_byte),
			EndByte:    uint(val.end_byte),
			StartPoint: Point{Row: uint(val.start_point.row), Column: uint(val.start_point.column)},
			EndPoint:   Point{Row: uint(val.end_point.row), Column: uint(val.end_point.column)},
		}
	}
	return ranges
}

// Set the ranges of text that the parser should include when parsing.
//
// By default, the parser will always include entire documents. This
// function allows you to parse only a *portion* of a document but
// still return a syntax tree whose ranges match up with the document
// as a whole. You can also pass multiple disjoint ranges.
//
// If `ranges` is empty, then the entire document will be parsed.
// Otherwise, the given ranges must be ordered from earliest to latest
// in the document, and they must not overlap. That is, the following
// must hold for all `i` < `length - 1`:
//
//	ranges[i].end_byte <= ranges[i + 1].start_byte
//
// If this requirement is not satisfied, method will return
// [IncludedRangesError] error with an offset in the passed ranges
// slice pointing to a first incorrect range.
func (p *Parser) SetIncludedRanges(ranges []Range) error {
	tsRanges := make([] /*line :710:21*/_Ctype_TSRange /*line :710:30*/, len(ranges))
	for i, r := range ranges {
		tsRanges[i] =  /*line :712:17*/_Ctype_TSRange /*line :712:26*/{
			start_byte:   /*line :713:17*/_Ctype_uint32_t /*line :713:27*/(r.StartByte),
			end_byte:     /*line :714:17*/_Ctype_uint32_t /*line :714:27*/(r.EndByte),
			start_point: r.StartPoint.toTSPoint(),
			end_point:   r.EndPoint.toTSPoint(),
		}
	}
	var cPtr * /*line :719:12*/_Ctype_TSRange /*line :719:21*/
	if len(tsRanges) > 0 {
		cPtr = &tsRanges[0]
	}
	result := func() _Ctype__Bool{ _cgo0 := /*line :723:44*/p._inner; var _cgo1 *_Ctype_struct_TSRange = /*line :723:54*/cPtr; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :723:70*/(len(tsRanges)); _cgoCheckPointer(_cgo0, nil); return /*line :723:86*/_Cfunc_ts_parser_set_included_ranges(_cgo0, _cgo1, _cgo2); }()
	if result {
		return nil
	}
	var prevEndByte uint
	for i, r := range ranges {
		if r.StartByte < prevEndByte || r.EndByte < r.StartByte {
			return &IncludedRangesError{uint32(i)}
		}
		prevEndByte = r.EndByte
	}
	return &IncludedRangesError{0}
}

// Deprecated: Use [Parser.ParseWithOptions] and pass in a callback instead, this will be removed in 0.26.
//
// Get the parser's current cancellation flag pointer.
func (p *Parser) CancellationFlag() *uintptr {
	return (*uintptr)(unsafe.Pointer(func() *_Ctype_size_t{ _cgo0 := /*line :741:65*/p._inner; _cgoCheckPointer(_cgo0, nil); return /*line :741:74*/_Cfunc_ts_parser_cancellation_flag(_cgo0); }()))
}

// Deprecated: Use [Parser.ParseWithOptions] and pass in a callback instead, this will be removed in 0.26.
//
// Set the parser's current cancellation flag pointer.
//
// If a pointer is assigned, then the parser will periodically read from
// this pointer during parsing. If it reads a non-zero value, it will halt
// early, returning `nil`. See [Parser.Parse] for more
// information.
func (p *Parser) SetCancellationFlag(flag *uintptr) {
	func() { _cgo0 := /*line :753:36*/p._inner; var _cgo1 *_Ctype_size_t = /*line :753:46*/(*_Ctype_size_t /*line :753:56*/)(unsafe.Pointer(flag)); _cgoCheckPointer(_cgo0, nil); /*line :753:80*/_Cfunc_ts_parser_set_cancellation_flag(_cgo0, _cgo1); }()
}
