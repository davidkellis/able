// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/david/sync/projects/able/.tmp/gomod/github.com/tree-sitter/go-tree-sitter@v0.25.0/tree.go:1:1
package tree_sitter

/*
#cgo CFLAGS: -Iinclude -Isrc -std=c11 -D_POSIX_C_SOURCE=200112L -D_DEFAULT_SOURCE
#include <tree_sitter/api.h>
*/
import _ "unsafe"

import (
	"unsafe"
)

// A stateful object that this is used to produce a [Tree] based on some
// source code.
type Tree struct {
	_inner * /*line :16:10*/_Ctype_TSTree /*line :16:18*/
}

// Create a new tree from a raw pointer.
func newTree(inner * /*line :20:21*/_Ctype_TSTree /*line :20:29*/) *Tree {
	return &Tree{_inner: inner}
}

// Get the root node of the syntax tree.
func (t *Tree) RootNode() *Node {
	return &Node{_inner: func() _Ctype_struct_TSNode{ _cgo0 := /*line :26:43*/t._inner; _cgoCheckPointer(_cgo0, nil); return /*line :26:52*/_Cfunc_ts_tree_root_node(_cgo0); }()}
}

// Get the root node of the syntax tree, but with its position shifted
// forward by the given offset.
func (t *Tree) RootNodeWithOffset(offsetBytes int, offsetExtent Point) *Node {
	return &Node{_inner: func() _Ctype_struct_TSNode{ _cgo0 := /*line :32:55*/t._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :32:71*/(offsetBytes); var _cgo2 _Ctype_struct_TSPoint = /*line :32:86*/offsetExtent.toTSPoint(); _cgoCheckPointer(_cgo0, nil); return /*line :32:111*/_Cfunc_ts_tree_root_node_with_offset(_cgo0, _cgo1, _cgo2); }()}
}

// Get the language that was used to parse the syntax tree.
func (t *Tree) Language() *Language {
	return &Language{Inner: func() *_Ctype_struct_TSLanguage{ _cgo0 := /*line :37:45*/t._inner; _cgoCheckPointer(_cgo0, nil); return /*line :37:54*/_Cfunc_ts_tree_language(_cgo0); }()}
}

// Edit the syntax tree to keep it in sync with source code that has been
// edited.
//
// You must describe the edit both in terms of byte offsets and in terms of
// row/column coordinates.
func (t *Tree) Edit(edit *InputEdit) {
	func() { _cgo0 := /*line :46:17*/t._inner; var _cgo1 *_Ctype_struct_TSInputEdit = /*line :46:27*/edit.toTSInputEdit(); _cgoCheckPointer(_cgo0, nil); /*line :46:48*/_Cfunc_ts_tree_edit(_cgo0, _cgo1); }()
}

// Create a new [TreeCursor] starting from the root of the tree.
func (t *Tree) Walk() *TreeCursor {
	return t.RootNode().Walk()
}

// Compare this old edited syntax tree to a new syntax tree representing
// the same document, returning a sequence of ranges whose syntactic
// structure has changed.
//
// For this to work correctly, this syntax tree must have been edited such
// that its ranges match up to the new tree. Generally, you'll want to
// call this method right after calling one of the [Parser.parse]
// functions. Call it on the old tree that was passed to parse, and
// pass the new tree that was returned from `parse`.
//
// The returned ranges indicate areas where the hierarchical structure of syntax
// nodes (from root to leaf) has changed between the old and new trees. Characters
// outside these ranges have identical ancestor nodes in both trees.
//
// Note that the returned ranges may be slightly larger than the exact changed areas,
// but Tree-sitter attempts to make them as small as possible.
func (t *Tree) ChangedRanges(other *Tree) []Range {
	var count  /*line :71:12*/_Ctype_uint /*line :71:18*/
	ptr := func() *_Ctype_struct_TSRange{ _cgo0 := /*line :72:38*/t._inner; _cgo1 := /*line :72:48*/other._inner; var _cgo2 *_Ctype_uint32_t = /*line :72:62*/&count; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :72:69*/_Cfunc_ts_tree_get_changed_ranges(_cgo0, _cgo1, _cgo2); }()
	ranges := make([]Range, int(count))
	for i := uintptr(0); i < uintptr(count); i++ {
		val := *(* /*line :75:13*/_Ctype_TSRange /*line :75:22*/)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + i*unsafe.Sizeof(*ptr)))
		ranges[i] = Range{
			StartPoint: Point{Row: uint(val.start_point.row), Column: uint(val.start_point.column)},
			EndPoint:   Point{Row: uint(val.end_point.row), Column: uint(val.end_point.column)},
			StartByte:  uint(val.start_byte),
			EndByte:    uint(val.end_byte),
		}
	}
	go_free(unsafe.Pointer(ptr))
	return ranges
}

// Get the included ranges that were used to parse the syntax tree.
func (t *Tree) IncludedRanges() []Range {
	var count  /*line :89:12*/_Ctype_uint /*line :89:18*/
	ptr := func() *_Ctype_struct_TSRange{ _cgo0 := /*line :90:35*/t._inner; var _cgo1 *_Ctype_uint32_t = /*line :90:45*/&count; _cgoCheckPointer(_cgo0, nil); return /*line :90:52*/_Cfunc_ts_tree_included_ranges(_cgo0, _cgo1); }()
	ranges := make([]Range, int(count))
	for i := uintptr(0); i < uintptr(count); i++ {
		val := *(* /*line :93:13*/_Ctype_TSRange /*line :93:22*/)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr)) + i*unsafe.Sizeof(*ptr)))
		ranges[i] = Range{
			StartPoint: Point{Row: uint(val.start_point.row), Column: uint(val.start_point.column)},
			EndPoint:   Point{Row: uint(val.end_point.row), Column: uint(val.end_point.column)},
			StartByte:  uint(val.start_byte),
			EndByte:    uint(val.end_byte),
		}
	}
	go_free(unsafe.Pointer(ptr))
	return ranges
}

// Print a graph of the tree to the given file descriptor.
// The graph is formatted in the DOT language. You may want to pipe this
// graph directly to a `dot(1)` process in order to generate SVG
// output.
func (t *Tree) PrintDotGraph(file int) {
	func() { _cgo0 := /*line :110:28*/t._inner; var _cgo1 _Ctype_int = _Ctype_int /*line :110:43*/(file); _cgoCheckPointer(_cgo0, nil); /*line :110:50*/_Cfunc_ts_tree_print_dot_graph(_cgo0, _cgo1); }()
}

func (t *Tree) Close() {
	if t != nil {
		func() { _cgo0 := /*line :115:20*/t._inner; _cgoCheckPointer(_cgo0, nil); /*line :115:29*/_Cfunc_ts_tree_delete(_cgo0); }()
	}
}

func (t *Tree) Clone() *Tree {
	return newTree(func() *_Ctype_struct_TSTree{ _cgo0 := /*line :120:32*/t._inner; _cgoCheckPointer(_cgo0, nil); return /*line :120:41*/_Cfunc_ts_tree_copy(_cgo0); }())
}
