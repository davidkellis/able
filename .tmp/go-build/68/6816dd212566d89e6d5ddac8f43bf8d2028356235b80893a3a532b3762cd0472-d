// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/david/sync/projects/able/.tmp/gomod/github.com/tree-sitter/go-tree-sitter@v0.25.0/node.go:1:1
package tree_sitter

/*
#cgo CFLAGS: -Iinclude -Isrc -std=c11 -D_POSIX_C_SOURCE=200112L -D_DEFAULT_SOURCE
#include <tree_sitter/api.h>
*/
import _ "unsafe"
import "unsafe"

// A single node within a syntax [Tree].
// Note that this is a C-compatible struct
type Node struct {
	_inner  /*line :13:9*/_Ctype_TSNode /*line :13:17*/
}

func newNode(node  /*line :16:19*/_Ctype_TSNode /*line :16:27*/) *Node {
	if node.id == nil {
		return nil
	}
	return &Node{_inner: node}
}

// Get a numeric id for this node that is unique.
//
// Within a given syntax tree, no two nodes have the same id. However, if
// a new tree is created based on an older tree, and a node from the old
// tree is reused in the process, then that node will have the same id in
// both trees.
func (n *Node) Id() uintptr {
	return uintptr(n._inner.id)
}

// Get this node's type as a numerical id.
func (n *Node) KindId() uint16 {
	return uint16(func() _Ctype_TSSymbol{ _cgo0 := /*line :35:33*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :35:42*/_Cfunc_ts_node_symbol(_cgo0); }())
}

// Get the node's type as a numerical id as it appears in the grammar
// ignoring aliases.
func (n *Node) GrammarId() uint16 {
	return uint16(func() _Ctype_TSSymbol{ _cgo0 := /*line :41:41*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :41:50*/_Cfunc_ts_node_grammar_symbol(_cgo0); }())
}

// Get this node's type as a string.
func (n *Node) Kind() string {
	return ( /*line :46:9*/_Cfunc_GoString /*line :46:18*/)(func() *_Ctype_char{ _cgo0 := /*line :46:35*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :46:44*/_Cfunc_ts_node_type(_cgo0); }())
}

// Get this node's symbol name as it appears in the grammar ignoring
// aliases as a string.
func (n *Node) GrammarName() string {
	return ( /*line :52:9*/_Cfunc_GoString /*line :52:18*/)(func() *_Ctype_char{ _cgo0 := /*line :52:43*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :52:52*/_Cfunc_ts_node_grammar_type(_cgo0); }())
}

// Get the [Language] that was used to parse this node's syntax tree.
func (n *Node) Language() *Language {
	return &Language{Inner: func() *_Ctype_struct_TSLanguage{ _cgo0 := /*line :57:45*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :57:54*/_Cfunc_ts_node_language(_cgo0); }()}
}

// Check if this node is *named*.
//
// Named nodes correspond to named rules in the grammar, whereas
// *anonymous* nodes correspond to string literals in the grammar.
func (n *Node) IsNamed() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :65:33*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :65:42*/_Cfunc_ts_node_is_named(_cgo0); }())
}

// Check if this node is *extra*.
//
// Extra nodes represent things like comments, which are not required in the
// grammar, but can appear anywhere.
func (n *Node) IsExtra() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :73:33*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :73:42*/_Cfunc_ts_node_is_extra(_cgo0); }())
}

// Check if this node has been edited.
func (n *Node) HasChanges() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :78:36*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :78:45*/_Cfunc_ts_node_has_changes(_cgo0); }())
}

// Check if this node represents a syntax error or contains any syntax
// errors anywhere within it.
func (n *Node) HasError() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :84:34*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :84:43*/_Cfunc_ts_node_has_error(_cgo0); }())
}

// Check if this node represents a syntax error.
//
// Syntax errors represent parts of the code that could not be incorporated
// into a valid syntax tree.
func (n *Node) IsError() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :92:33*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :92:42*/_Cfunc_ts_node_is_error(_cgo0); }())
}

// Get this node's parse state.
func (n *Node) ParseState() uint16 {
	return uint16(func() _Ctype_TSStateId{ _cgo0 := /*line :97:38*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :97:47*/_Cfunc_ts_node_parse_state(_cgo0); }())
}

// Get the parse state after this node.
func (n *Node) NextParseState() uint16 {
	return uint16(func() _Ctype_TSStateId{ _cgo0 := /*line :102:43*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :102:52*/_Cfunc_ts_node_next_parse_state(_cgo0); }())
}

// Check if this node is *missing*.
//
// Missing nodes are inserted by the parser in order to recover from
// certain kinds of syntax errors.
func (n *Node) IsMissing() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :110:35*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :110:44*/_Cfunc_ts_node_is_missing(_cgo0); }())
}

// Get the byte offsets where this node starts.
func (n *Node) StartByte() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :115:35*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :115:44*/_Cfunc_ts_node_start_byte(_cgo0); }())
}

// Get the byte offsets where this node end.
func (n *Node) EndByte() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :120:33*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :120:42*/_Cfunc_ts_node_end_byte(_cgo0); }())
}

// Get the byte range of source code that this node represents.
func (n *Node) ByteRange() (uint, uint) {
	return n.StartByte(), n.EndByte()
}

// Get the range of source code that this node represents, both in terms of
// raw bytes and of row/column coordinates.
func (n *Node) Range() Range {
	return Range{
		StartByte:  n.StartByte(),
		EndByte:    n.EndByte(),
		StartPoint: n.StartPosition(),
		EndPoint:   n.EndPosition(),
	}
}

// Get this node's start position in terms of rows and columns.
func (n *Node) StartPosition() Point {
	p := Point{}
	p.fromTSPoint(func() _Ctype_struct_TSPoint{ _cgo0 := /*line :142:38*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :142:47*/_Cfunc_ts_node_start_point(_cgo0); }())
	return p
}

// Get this node's end position in terms of rows and columns.
func (n *Node) EndPosition() Point {
	p := Point{}
	p.fromTSPoint(func() _Ctype_struct_TSPoint{ _cgo0 := /*line :149:36*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :149:45*/_Cfunc_ts_node_end_point(_cgo0); }())
	return p
}

// Get the node's child at the given index, where zero represents the first
// child.
//
// This method is fairly fast, but its cost is technically log(i), so if
// you might be iterating over a long list of children, you should use
// [Node.Children] instead.
func (n *Node) Child(i uint) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :160:33*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :160:49*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :160:53*/_Cfunc_ts_node_child(_cgo0, _cgo1); }())
}

// Get this node's number of children.
func (n *Node) ChildCount() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :165:36*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :165:45*/_Cfunc_ts_node_child_count(_cgo0); }())
}

// Get this node's *named* child at the given index.
//
// See also [Node.IsNamed].
// This method is fairly fast, but its cost is technically log(i), so if
// you might be iterating over a long list of children, you should use
// [Node.NamedChildren] instead.
func (n *Node) NamedChild(i uint) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :175:39*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :175:55*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :175:59*/_Cfunc_ts_node_named_child(_cgo0, _cgo1); }())
}

// Get this node's number of *named* children.
//
// See also [Node.IsNamed].
func (n *Node) NamedChildCount() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :182:42*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :182:51*/_Cfunc_ts_node_named_child_count(_cgo0); }())
}

// Get the first child with the given field name.
//
// If multiple children may have the same field name, access them using
// [Node.ChildrenByFieldName]
func (n *Node) ChildByFieldName(fieldName string) *Node {
	cFieldName := ( /*line :190:16*/_Cfunc_CString /*line :190:24*/)(fieldName)
	defer go_free(unsafe.Pointer(cFieldName))
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :192:47*/n._inner; var _cgo1 *_Ctype_char = /*line :192:57*/cFieldName; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :192:79*/(len(fieldName)); _cgoCheckPointer(_cgo0, nil); return /*line :192:96*/_Cfunc_ts_node_child_by_field_name(_cgo0, _cgo1, _cgo2); }())
}

// Get this node's child with the given numerical field id.
//
// See also [Node.ChildByFieldName]. You can
// convert a field name to an id using [Language.FieldIdForName].
func (n *Node) ChildByFieldId(fieldId uint16) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :200:45*/n._inner; var _cgo1 _Ctype_TSFieldId = _Ctype_uint16_t /*line :200:65*/(fieldId); _cgoCheckPointer(_cgo0, nil); return /*line :200:75*/_Cfunc_ts_node_child_by_field_id(_cgo0, _cgo1); }())
}

// Get the field name of this node's child at the given index.
func (n *Node) FieldNameForChild(childIndex uint32) string {
	ptr := func() *_Ctype_char{ _cgo0 := /*line :205:40*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :205:60*/(childIndex); _cgoCheckPointer(_cgo0, nil); return /*line :205:73*/_Cfunc_ts_node_field_name_for_child(_cgo0, _cgo1); }()
	if ptr == nil {
		return ""
	}
	return ( /*line :209:9*/_Cfunc_GoString /*line :209:18*/)(ptr)
}

// Get the field name of this node's named child at the given index.
func (n *Node) FieldNameForNamedChild(namedChildIndex uint32) string {
	ptr := func() *_Ctype_char{ _cgo0 := /*line :214:46*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :214:66*/(namedChildIndex); _cgoCheckPointer(_cgo0, nil); return /*line :214:84*/_Cfunc_ts_node_field_name_for_named_child(_cgo0, _cgo1); }()
	if ptr == nil {
		return ""
	}
	return ( /*line :218:9*/_Cfunc_GoString /*line :218:18*/)(ptr)
}

// Iterate over this node's children.
//
// A [TreeCursor] is used to retrieve the children efficiently. Obtain
// a [TreeCursor] by calling [Tree.Walk] or [Node.Walk]. To avoid
// unnecessary allocations, you should reuse the same cursor for
// subsequent calls to this method.
//
// If you're walking the tree recursively, you may want to use the
// [TreeCursor] APIs directly instead.
func (n *Node) Children(cursor *TreeCursor) []Node {
	cursor.Reset(*n)
	cursor.GotoFirstChild()
	childCount := n.ChildCount()
	result := make([]Node, 0, childCount)
	for i := 0; i < int(childCount); i++ {
		result = append(result, *cursor.Node())
		cursor.GotoNextSibling()
	}
	return result
}

// Iterate over this node's named children.
//
// See also [Node.Children].
func (n *Node) NamedChildren(cursor *TreeCursor) []Node {
	cursor.Reset(*n)
	cursor.GotoFirstChild()
	namedChildCount := n.NamedChildCount()
	result := make([]Node, 0, namedChildCount)
	for i := 0; i < int(namedChildCount); i++ {
		for !cursor.Node().IsNamed() {
			if !cursor.GotoNextSibling() {
				break
			}
		}
		result = append(result, *cursor.Node())
		cursor.GotoNextSibling()
	}
	return result
}

// Iterate over this node's children with a given field name.
//
// See also [Node.Children].
func (n *Node) ChildrenByFieldName(fieldName string, cursor *TreeCursor) []Node {
	fieldId := n.Language().FieldIdForName(fieldName)
	done := fieldId == 0
	if !done {
		cursor.Reset(*n)
		cursor.GotoFirstChild()
	}
	result := make([]Node, 0)
	for !done {
		for cursor.FieldId() != fieldId {
			if !cursor.GotoNextSibling() {
				return result
			}
		}
		result = append(result, *cursor.Node())
		if !cursor.GotoNextSibling() {
			done = true
		}
	}
	return result
}

// Get this node's immediate parent.
// Prefer [Node.ChildWithDescendant]
// for iterating over this node's ancestors.
func (n *Node) Parent() *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :291:34*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :291:43*/_Cfunc_ts_node_parent(_cgo0); }())
}

// Get the node that contains `descendant`.
// Note that this can return `descendant` itself.
func (n *Node) ChildWithDescendant(descendant *Node) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :297:49*/n._inner; _cgo1 := /*line :297:59*/descendant._inner; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :297:77*/_Cfunc_ts_node_child_with_descendant(_cgo0, _cgo1); }())
}

// Get this node's next sibling.
func (n *Node) NextSibling() *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :302:40*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :302:49*/_Cfunc_ts_node_next_sibling(_cgo0); }())
}

// Get this node's previous sibling.
func (n *Node) PrevSibling() *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :307:40*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :307:49*/_Cfunc_ts_node_prev_sibling(_cgo0); }())
}

// Get this node's next named sibling.
func (n *Node) NextNamedSibling() *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :312:46*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :312:55*/_Cfunc_ts_node_next_named_sibling(_cgo0); }())
}

// Get this node's previous named sibling.
func (n *Node) PrevNamedSibling() *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :317:46*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :317:55*/_Cfunc_ts_node_prev_named_sibling(_cgo0); }())
}

// Get the node's first child that contains or starts after the given byte offset.
func (n *Node) FirstChildForByte(byteOffset uint) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :322:48*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :322:64*/(byteOffset); _cgoCheckPointer(_cgo0, nil); return /*line :322:77*/_Cfunc_ts_node_first_child_for_byte(_cgo0, _cgo1); }())
}

// Get the node's first named child that contains or starts after the given byte offset.
func (n *Node) FirstNamedChildForByte(byteOffset uint) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :327:54*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :327:70*/(byteOffset); _cgoCheckPointer(_cgo0, nil); return /*line :327:83*/_Cfunc_ts_node_first_named_child_for_byte(_cgo0, _cgo1); }())
}

// Get the node's number of descendants, including one for the node itself.
func (n *Node) DescendantCount() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :332:41*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :332:50*/_Cfunc_ts_node_descendant_count(_cgo0); }())
}

// Get the smallest node within this node that spans the given range.
func (n *Node) DescendantForByteRange(start, end uint) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :337:53*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :337:69*/(start); var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :337:84*/(end); _cgoCheckPointer(_cgo0, nil); return /*line :337:90*/_Cfunc_ts_node_descendant_for_byte_range(_cgo0, _cgo1, _cgo2); }())
}

// Get the smallest named node within this node that spans the given range.
func (n *Node) NamedDescendantForByteRange(start, end uint) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :342:59*/n._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint /*line :342:75*/(start); var _cgo2 _Ctype_uint32_t = _Ctype_uint /*line :342:90*/(end); _cgoCheckPointer(_cgo0, nil); return /*line :342:96*/_Cfunc_ts_node_named_descendant_for_byte_range(_cgo0, _cgo1, _cgo2); }())
}

// Get the smallest node within this node that spans the given range.
func (n *Node) DescendantForPointRange(start, end Point) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :347:54*/n._inner; var _cgo1 _Ctype_struct_TSPoint = /*line :347:64*/start.toTSPoint(); var _cgo2 _Ctype_struct_TSPoint = /*line :347:83*/end.toTSPoint(); _cgoCheckPointer(_cgo0, nil); return /*line :347:99*/_Cfunc_ts_node_descendant_for_point_range(_cgo0, _cgo1, _cgo2); }())
}

// Get the smallest named node within this node that spans the given range.
func (n *Node) NamedDescendantForPointRange(start, end Point) *Node {
	return newNode(func() _Ctype_struct_TSNode{ _cgo0 := /*line :352:60*/n._inner; var _cgo1 _Ctype_struct_TSPoint = /*line :352:70*/start.toTSPoint(); var _cgo2 _Ctype_struct_TSPoint = /*line :352:89*/end.toTSPoint(); _cgoCheckPointer(_cgo0, nil); return /*line :352:105*/_Cfunc_ts_node_named_descendant_for_point_range(_cgo0, _cgo1, _cgo2); }())
}

func (n *Node) ToSexp() string {
	cString := func() *_Ctype_char{ _cgo0 := /*line :356:30*/n._inner; _cgoCheckPointer(_cgo0, nil); return /*line :356:39*/_Cfunc_ts_node_string(_cgo0); }()
	result := ( /*line :357:12*/_Cfunc_GoString /*line :357:21*/)(cString)
	go_free(unsafe.Pointer(cString))
	return result
}

func (n *Node) Utf8Text(source []byte) string {
	return string(source[n.StartByte():n.EndByte()])
}

func (n *Node) Utf16Text(source []uint16) []uint16 {
	return source[n.StartByte():n.EndByte()]
}

// Create a new [TreeCursor] starting from this node.
//
// Note that the given node is considered the root of the cursor,
// and the cursor cannot walk outside this node.
func (n *Node) Walk() *TreeCursor {
	return newTreeCursor(*n)
}

// Edit this node to keep it in-sync with source code that has been edited.
//
// This function is only rarely needed. When you edit a syntax tree with
// the [Tree.Edit] method, all of the nodes that you retrieve from
// the tree afterward will already reflect the edit. You only need to
// use [Node.Edit] when you have a specific [Node] instance that
// you want to keep and continue to use after an edit.
func (n *Node) Edit(edit *InputEdit) {
	func() { _cgoBase0 := /*line :386:17*/&n._inner; _cgo0 := _cgoBase0; var _cgo1 *_Ctype_struct_TSInputEdit = /*line :386:28*/edit.toTSInputEdit(); _cgoCheckPointer(_cgoBase0, 0 == 0); /*line :386:49*/_Cfunc_ts_node_edit(_cgo0, _cgo1); }()
}

// Check if two nodes are identical.
func (n *Node) Equals(other Node) bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :391:27*/n._inner; _cgo1 := /*line :391:37*/other._inner; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :391:50*/_Cfunc_ts_node_eq(_cgo0, _cgo1); }())
}
