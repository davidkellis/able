// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/david/sync/projects/able/.tmp/gomod/github.com/tree-sitter/go-tree-sitter@v0.25.0/language.go:1:1
package tree_sitter

/*
#cgo CFLAGS: -Iinclude -Isrc -std=c11 -D_POSIX_C_SOURCE=200112L -D_DEFAULT_SOURCE
#include <tree_sitter/api.h>
*/
import _ "unsafe"

import (
	"fmt"
	"unsafe"
)

const LANGUAGE_VERSION = ( /*line :14:26*/_Ciconst_TREE_SITTER_LANGUAGE_VERSION /*line :14:55*/)

const MIN_COMPATIBLE_LANGUAGE_VERSION = ( /*line :16:41*/_Ciconst_TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION /*line :16:85*/)

// An opaque object that defines how to parse a particular language. The code
// for each [Language] is generated by the Tree-sitter CLI.
type Language struct {
	Inner * /*line :21:9*/_Ctype_TSLanguage /*line :21:21*/
}

// An error that occurred when trying to assign an incompatible [TSLanguage] to
// a [TSParser].
type LanguageError struct {
	version uint32
}

// The metadata associated with a language.
//
// Currently, this metadata can be used to check the [Semantic Version](https://semver.org/)
// of the language. This version information should be used to signal if a given parser might
// be incompatible with existing queries when upgrading between major versions, or minor versions
// if it's in zerover.
type LanguageMetadata struct {
	MajorVersion uint8
	MinorVersion uint8
	PatchVersion uint8
}

func NewLanguage(ptr unsafe.Pointer) *Language {
	return &Language{Inner: (* /*line :43:28*/_Ctype_TSLanguage /*line :43:40*/)(ptr)}
}

// Deprecated: Use [Language.AbiVersion] instead.
//
// Get the ABI version number that indicates which version of the
// Tree-sitter CLI that was used to generate this [Language].
func (l *Language) Version() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :51:38*/l.Inner; _cgoCheckPointer(_cgo0, nil); return /*line :51:46*/_Cfunc_ts_language_version(_cgo0); }())
}

// Get the ABI version number that indicates which version of the
// Tree-sitter CLI that was used to generate this [Language].
func (l *Language) AbiVersion() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :57:42*/l.Inner; _cgoCheckPointer(_cgo0, nil); return /*line :57:50*/_Cfunc_ts_language_abi_version(_cgo0); }())
}

// Get the metadata for this language. This information is generated by the
// CLI, and relies on the language author providing the correct metadata in
// the language's `tree-sitter.json` file.
func (l *Language) Metadata() *LanguageMetadata {
	ptr := func() *_Ctype_struct_TSLanguageMetadata{ _cgo0 := /*line :64:32*/l.Inner; _cgoCheckPointer(_cgo0, nil); return /*line :64:40*/_Cfunc_ts_language_metadata(_cgo0); }()
	if ptr == nil {
		return nil
	}
	return &LanguageMetadata{
		MajorVersion: uint8(ptr.major_version),
		MinorVersion: uint8(ptr.minor_version),
		PatchVersion: uint8(ptr.patch_version),
	}
}

// Get the number of distinct node types in this language.
func (l *Language) NodeKindCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :77:43*/l.Inner; _cgoCheckPointer(_cgo0, nil); return /*line :77:51*/_Cfunc_ts_language_symbol_count(_cgo0); }())
}

// Get the number of valid states in this language.
func (l *Language) ParseStateCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :82:42*/l.Inner; _cgoCheckPointer(_cgo0, nil); return /*line :82:50*/_Cfunc_ts_language_state_count(_cgo0); }())
}

// Get the name of the node kind for the given numerical id.
func (l *Language) NodeKindForId(id uint16) string {
	return ( /*line :87:9*/_Cfunc_GoString /*line :87:18*/)(func() *_Ctype_char{ _cgo0 := /*line :87:46*/l.Inner; var _cgo1 _Ctype_TSSymbol = _Ctype_TSSymbol /*line :87:65*/(id); _cgoCheckPointer(_cgo0, nil); return /*line :87:70*/_Cfunc_ts_language_symbol_name(_cgo0, _cgo1); }())
}

// Get the numeric id for the given node kind.
func (l *Language) IdForNodeKind(kind string, named bool) uint16 {
	return uint16(func() _Ctype_TSSymbol{ _cgo0 := /*line :92:46*/l.Inner; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :92:64*/(kind); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :92:82*/(len(kind)); var _cgo3 _Ctype__Bool = _Ctype_bool /*line :92:101*/(named); _cgoCheckPointer(_cgo0, nil); return /*line :92:109*/_Cfunc_ts_language_symbol_for_name(_cgo0, _cgo1, _cgo2, _cgo3); }())
}

// Check if the node type for the given numerical id is named (as opposed
// to an anonymous node type).
func (l *Language) NodeKindIsNamed(id uint16) bool {
	return func() _Ctype_TSSymbolType{ _cgo0 := /*line :98:35*/l.Inner; var _cgo1 _Ctype_TSSymbol = _Ctype_TSSymbol /*line :98:54*/(id); _cgoCheckPointer(_cgo0, nil); return /*line :98:59*/_Cfunc_ts_language_symbol_type(_cgo0, _cgo1); }() == ( /*line :98:63*/_Ciconst_TSSymbolTypeRegular /*line :98:83*/)
}

// Check if the node type for the given numerical id is visible (as opposed
// to a hidden node type).
func (l *Language) NodeKindIsVisible(id uint16) bool {
	return func() _Ctype_TSSymbolType{ _cgo0 := /*line :104:35*/l.Inner; var _cgo1 _Ctype_TSSymbol = _Ctype_TSSymbol /*line :104:54*/(id); _cgoCheckPointer(_cgo0, nil); return /*line :104:59*/_Cfunc_ts_language_symbol_type(_cgo0, _cgo1); }() <= ( /*line :104:63*/_Ciconst_TSSymbolTypeAnonymous /*line :104:85*/)
}

// Check if the node type for the given numerical id is a supertype.
func (l *Language) NodeKindIsSupertype(id uint16) bool {
	return func() _Ctype_TSSymbolType{ _cgo0 := /*line :109:35*/l.Inner; var _cgo1 _Ctype_TSSymbol = _Ctype_TSSymbol /*line :109:54*/(id); _cgoCheckPointer(_cgo0, nil); return /*line :109:59*/_Cfunc_ts_language_symbol_type(_cgo0, _cgo1); }() == ( /*line :109:63*/_Ciconst_TSSymbolTypeSupertype /*line :109:85*/)
}

// Get the number of distinct field names in this language.
func (l *Language) FieldCount() uint32 {
	return uint32(func() _Ctype_uint32_t{ _cgo0 := /*line :114:42*/l.Inner; _cgoCheckPointer(_cgo0, nil); return /*line :114:50*/_Cfunc_ts_language_field_count(_cgo0); }())
}

// Get the field names for the given numerical id.
func (l *Language) FieldNameForId(id uint16) string {
	return ( /*line :119:9*/_Cfunc_GoString /*line :119:18*/)(func() *_Ctype_char{ _cgo0 := /*line :119:52*/l.Inner; var _cgo1 _Ctype_TSFieldId = _Ctype_TSFieldId /*line :119:72*/(id); _cgoCheckPointer(_cgo0, nil); return /*line :119:77*/_Cfunc_ts_language_field_name_for_id(_cgo0, _cgo1); }())
}

// Get the numerical id for the given field name.
func (l *Language) FieldIdForName(name string) uint16 {
	return uint16(func() _Ctype_TSFieldId{ _cgo0 := /*line :124:48*/l.Inner; var _cgo1 *_Ctype_char = _Cfunc_CString /*line :124:66*/(name); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :124:84*/(len(name)); _cgoCheckPointer(_cgo0, nil); return /*line :124:96*/_Cfunc_ts_language_field_id_for_name(_cgo0, _cgo1, _cgo2); }())
}

// Get the next parse state. Combine this with
// [Language.LookaheadIterator] to
// generate completion suggestions or valid symbols in error nodes.
func (l *Language) NextState(state uint16, id uint16) uint16 {
	return uint16(func() _Ctype_TSStateId{ _cgo0 := /*line :131:41*/l.Inner; var _cgo1 _Ctype_TSStateId = _Ctype_TSStateId /*line :131:61*/(state); var _cgo2 _Ctype_TSSymbol = _Ctype_TSSymbol /*line :131:80*/(id); _cgoCheckPointer(_cgo0, nil); return /*line :131:85*/_Cfunc_ts_language_next_state(_cgo0, _cgo1, _cgo2); }())
}

// Create a new lookahead iterator for this language and parse state.
//
// This returns `nil` if state is invalid for this language.
//
// Iterating [LookaheadIterator] will yield valid symbols in the given
// parse state. Newly created lookahead iterators will return the `ERROR`
// symbol from [LookaheadIterator.Symbol].
//
// Lookahead iterators can be useful to generate suggestions and improve
// syntax error diagnostics. To get symbols valid in an ERROR node, use the
// lookahead iterator on its first leaf node state. For `MISSING` nodes, a
// lookahead iterator created on the previous non-extra leaf node may be
// appropriate.
func (l *Language) LookaheadIterator(state uint16) *LookaheadIterator {
	ptr := func() *_Ctype_struct_TSLookaheadIterator{ _cgo0 := /*line :148:37*/l.Inner; var _cgo1 _Ctype_TSStateId = _Ctype_TSStateId /*line :148:57*/(state); _cgoCheckPointer(_cgo0, nil); return /*line :148:65*/_Cfunc_ts_lookahead_iterator_new(_cgo0, _cgo1); }()
	if ptr == nil {
		return nil
	}
	return newLookaheadIterator(ptr)
}

func (l *LanguageError) Error() string {
	return fmt.Sprintf("Incompatible language version %d. Expected minimum %d, maximum %d", l.version, ( /*line :156:101*/_Ciconst_TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION /*line :156:145*/), ( /*line :156:148*/_Ciconst_TREE_SITTER_LANGUAGE_VERSION /*line :156:177*/))
}
