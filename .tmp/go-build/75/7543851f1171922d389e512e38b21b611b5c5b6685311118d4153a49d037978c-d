// Code generated by cmd/cgo; DO NOT EDIT.

//line /home/david/sync/projects/able/.tmp/gomod/github.com/tree-sitter/go-tree-sitter@v0.25.0/query.go:1:1
package tree_sitter

/*
#cgo CFLAGS: -Iinclude -Isrc -std=c11 -D_POSIX_C_SOURCE=200112L -D_DEFAULT_SOURCE
#include <tree_sitter/api.h>

extern bool queryProgressCallback(TSQueryCursorState *state);
*/
import _ "unsafe"

import (
	"bytes"
	"fmt"
	"math"
	"regexp"
	"strings"
	"unsafe"

	"github.com/mattn/go-pointer"
)

type Query struct {
	_inner             * /*line :23:22*/_Ctype_TSQuery /*line :23:31*/
	captureNames       []string
	captureQuantifiers [][]CaptureQuantifier
	TextPredicates     [][]TextPredicateCapture
	propertySettings   [][]QueryProperty
	propertyPredicates [][]PropertyPredicate
	generalPredicates  [][]QueryPredicate
}

type CaptureQuantifier int

const (
	CaptureQuantifierZero CaptureQuantifier = iota
	CaptureQuantifierZeroOrOne
	CaptureQuantifierZeroOrMore
	CaptureQuantifierOne
	CaptureQuantifierOneOrMore
)

func newCaptureQuantifier(raw  /*line :42:31*/_Ctype_TSQuantifier /*line :42:45*/) CaptureQuantifier {
	switch raw {
	case ( /*line :44:7*/_Ciconst_TSQuantifierZero /*line :44:24*/):
		return CaptureQuantifierZero
	case ( /*line :46:7*/_Ciconst_TSQuantifierZeroOrOne /*line :46:29*/):
		return CaptureQuantifierZeroOrOne
	case ( /*line :48:7*/_Ciconst_TSQuantifierZeroOrMore /*line :48:30*/):
		return CaptureQuantifierZeroOrMore
	case ( /*line :50:7*/_Ciconst_TSQuantifierOne /*line :50:23*/):
		return CaptureQuantifierOne
	case ( /*line :52:7*/_Ciconst_TSQuantifierOneOrMore /*line :52:29*/):
		return CaptureQuantifierOneOrMore
	default:
		panic("invalid CaptureQuantifier")
	}
}

// A stateful object for executing a [Query] on a syntax [Tree].
type QueryCursor struct {
	_inner * /*line :61:10*/_Ctype_TSQueryCursor /*line :61:25*/
}

// A stateful object that is passed into the progress callback [QueryOptions.ProgressCallback].
// to provide the current state of the query.
type QueryCursorState struct {
	// The byte offset in the document that the query is at.
	CurrentByteOffset uint32
}

// Options for query execution
type QueryCursorOptions struct {
	// A function that will be called periodically during the execution of the query to check
	// if query execution should be cancelled. If the progress callback returns `true`, then
	// query execution will be canceled. You can also use this to instrument query execution
	// and check where the query is at in the document. The progress callback takes a single
	// argument, which is a [QueryCursorState] representing the current state of the query.
	ProgressCallback func(QueryCursorState) bool
}

// A key-value pair associated with a particular pattern in a [Query].
type QueryProperty struct {
	Key       string
	Value     *string
	CaptureId *uint
}

type QueryPredicateArg struct {
	CaptureId *uint
	String    *string
}

// A key-value pair associated with a particular pattern in a [Query].
type QueryPredicate struct {
	Operator string
	Args     []QueryPredicateArg
}

// A match of a [Query] to a particular set of [Node]s.
type QueryMatch struct {
	cursor       * /*line :101:16*/_Ctype_TSQueryCursor /*line :101:31*/
	Captures     []QueryCapture
	PatternIndex uint
	id           uint
}

// A sequence of [QueryMatch]es associated with a given [QueryCursor].
type QueryMatches struct {
	_inner  * /*line :109:11*/_Ctype_TSQueryCursor /*line :109:26*/
	query   *Query
	text    []byte
	buffer1 []byte
	buffer2 []byte
}

// A sequence of [QueryCapture]s associated with a given [QueryCursor].
type QueryCaptures struct {
	_inner  * /*line :118:11*/_Ctype_TSQueryCursor /*line :118:26*/
	query   *Query
	text    []byte
	buffer1 []byte
	buffer2 []byte
}

// A particular [Node] that has been captured with a particular name within a [Query].
// Note that this is a C-compatible struct
type QueryCapture struct {
	Node  Node
	Index uint32
}

type QueryError struct {
	Message string
	Row     uint
	Column  uint
	Offset  uint
	Kind    QueryErrorKind
}

type TextPredicateCapture struct {
	Value         any
	Type          TextPredicateType
	CaptureId     uint
	Positive      bool
	MatchAllNodes bool
}

type TextPredicateType int

const (
	TextPredicateTypeEqCapture TextPredicateType = iota
	TextPredicateTypeEqString
	TextPredicateTypeMatchString
	TextPredicateTypeAnyString
)

type PropertyPredicate struct {
	Property QueryProperty
	Positive bool
}

func (e QueryError) Error() string {
	var msg string
	switch e.Kind {
	case QueryErrorField:
		msg = "Invalid field name "
	case QueryErrorNodeType:
		msg = "Invalid node type "
	case QueryErrorCapture:
		msg = "Invalid capture name "
	case QueryErrorPredicate:
		msg = "Invalid predicate: "
	case QueryErrorStructure:
		msg = "Impossible pattern:\n"
	case QueryErrorSyntax:
		msg = "Invalid syntax:\n"
	case QueryErrorLanguage:
		msg = ""
	}

	if msg == "" {
		return e.Message
	}
	return fmt.Sprintf("Query error at %d:%d. %s%s", e.Row+1, e.Column+1, msg, e.Message)
}

type QueryErrorKind int

const (
	QueryErrorSyntax QueryErrorKind = iota
	QueryErrorNodeType
	QueryErrorField
	QueryErrorCapture
	QueryErrorPredicate
	QueryErrorStructure
	QueryErrorLanguage
)

func NewQuery(language *Language, source string) (*Query, *QueryError) {
	var errorOffset  /*line :200:18*/_Ctype_uint32_t /*line :200:28*/
	var errorType  /*line :201:16*/_Ctype_TSQueryError /*line :201:30*/
	bytes := []byte(source)

	var bytesPtr * /*line :204:16*/_Ctype_char /*line :204:22*/
	if len(bytes) > 0 {
		bytesPtr = (* /*line :206:16*/_Ctype_char /*line :206:22*/)(unsafe.Pointer(&bytes[0]))
	} else {
		bytesPtr = nil
	}

	// Compile the query.
	ptr := func() *_Ctype_struct_TSQuery{ _cgo0 := /*line :213:3*/language.Inner; var _cgo1 *_Ctype_char = /*line :214:3*/bytesPtr; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :215:13*/(len(bytes)); var _cgo3 *_Ctype_uint32_t = /*line :216:3*/&errorOffset; var _cgo4 *_Ctype_TSQueryError = /*line :217:3*/&errorType; _cgoCheckPointer(_cgo0, nil); return /*line :218:3*/_Cfunc_ts_query_new(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()

	// On failure, build an error based on the error code and offset.
	if ptr == nil {
		if errorType == ( /*line :222:19*/_Ciconst_TSQueryErrorLanguage /*line :222:40*/) {
			lErr := &LanguageError{
				version: language.AbiVersion(),
			}
			return nil, &QueryError{
				Row:     0,
				Column:  0,
				Offset:  0,
				Message: lErr.Error(),
				Kind:    QueryErrorLanguage,
			}
		}

		offset := uint(errorOffset)
		var lineStart uint
		var row uint
		var lineContainingError string
		for _, line := range strings.Split(source, "\n") {
			lineEnd := lineStart + uint(len(line)) + 1
			if lineEnd > offset {
				lineContainingError = string(line)
				break
			}
			lineStart = lineEnd
			row++
		}
		column := offset - lineStart

		var kind QueryErrorKind
		var message string
		switch errorType {
		// Error types that report names
		case ( /*line :254:8*/_Ciconst_TSQueryErrorNodeType /*line :254:29*/), ( /*line :254:32*/_Ciconst_TSQueryErrorField /*line :254:50*/), ( /*line :254:53*/_Ciconst_TSQueryErrorCapture /*line :254:73*/):
			suffix := string(bytes[offset:])
			inQuotes := offset > 0 && bytes[offset-1] == '"'
			endOffset := len(suffix)
			backslashes := 0

			if inQuotes {
				// Handle quoted strings
				for i, c := range suffix {
					if c == '"' && backslashes%2 == 0 {
						endOffset = i
						break
					} else if c == '\\' {
						backslashes++
					} else {
						backslashes = 0
					}
				}
			} else {
				// Handle unquoted strings
				for i, c := range suffix {
					if !strings.ContainsRune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-", c) {
						endOffset = i
						break
					}
				}
			}

			message = suffix[:endOffset]
			switch errorType {
			case ( /*line :284:9*/_Ciconst_TSQueryErrorNodeType /*line :284:30*/):
				kind = QueryErrorNodeType
			case ( /*line :286:9*/_Ciconst_TSQueryErrorField /*line :286:27*/):
				kind = QueryErrorField
			case ( /*line :288:9*/_Ciconst_TSQueryErrorCapture /*line :288:29*/):
				kind = QueryErrorCapture
			}

		// Error types that report positions
		default:
			if lineContainingError == "" {
				message = "Unexpected EOF"
			} else {
				message = lineContainingError + "\n" + strings.Repeat(" ", int(offset-lineStart)) + "^"
			}
			switch errorType {
			case ( /*line :300:9*/_Ciconst_TSQueryErrorStructure /*line :300:31*/):
				kind = QueryErrorStructure
			default:
				kind = QueryErrorSyntax
			}
		}
		return nil, &QueryError{
			Row:     row,
			Column:  column,
			Offset:  offset,
			Message: message,
			Kind:    kind,
		}
	}

	res, err := fromRawParts(ptr, source)
	return res, err
}

func fromRawParts(ptr * /*line :319:24*/_Ctype_TSQuery /*line :319:33*/, source string) (*Query, *QueryError) {
	stringCount := int(func() _Ctype_uint32_t{ _cgo0 := /*line :320:45*/ptr; _cgoCheckPointer(_cgo0, nil); return /*line :320:49*/_Cfunc_ts_query_string_count(_cgo0); }())
	captureCount := int(func() _Ctype_uint32_t{ _cgo0 := /*line :321:47*/ptr; _cgoCheckPointer(_cgo0, nil); return /*line :321:51*/_Cfunc_ts_query_capture_count(_cgo0); }())
	patternCount := int(func() _Ctype_uint32_t{ _cgo0 := /*line :322:47*/ptr; _cgoCheckPointer(_cgo0, nil); return /*line :322:51*/_Cfunc_ts_query_pattern_count(_cgo0); }())

	captureNames := make([]string, captureCount)
	captureQuantifiersVec := make([][]CaptureQuantifier, patternCount)
	textPredicatesVec := make([][]TextPredicateCapture, patternCount)
	propertyPredicatesVec := make([][]PropertyPredicate, patternCount)
	propertySettingsVec := make([][]QueryProperty, patternCount)
	generalPredicatesVec := make([][]QueryPredicate, patternCount)

	// Build a vector of strings to store the capture names.
	for i := 0; i < captureCount; i++ {
		var length  /*line :333:14*/_Ctype_uint32_t /*line :333:24*/
		name := func() *_Ctype_char{ _cgo0 := /*line :334:42*/ptr; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :334:57*/(i); var _cgo2 *_Ctype_uint32_t = /*line :334:62*/&length; _cgoCheckPointer(_cgo0, nil); return /*line :334:70*/_Cfunc_ts_query_capture_name_for_id(_cgo0, _cgo1, _cgo2); }()
		captureNames[i] = ( /*line :335:21*/_Cfunc_GoStringN /*line :335:31*/)(name,  /*line :335:39*/_Ctype_int /*line :335:44*/(length))
	}

	// Build a vector to store capture qunatifiers.
	for i := 0; i < patternCount; i++ {
		captureQuantifiers := make([]CaptureQuantifier, captureCount)
		for j := 0; j < captureCount; j++ {
			quantifier := func() _Ctype_TSQuantifier{ _cgo0 := /*line :342:55*/ptr; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :342:70*/(i); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :342:85*/(j); _cgoCheckPointer(_cgo0, nil); return /*line :342:89*/_Cfunc_ts_query_capture_quantifier_for_id(_cgo0, _cgo1, _cgo2); }()
			captureQuantifiers[j] = newCaptureQuantifier(quantifier)
		}
		captureQuantifiersVec[i] = captureQuantifiers
	}

	// Build a vector of strings to represent literal values used in predicates.
	stringValues := make([]string, stringCount)
	for i := 0; i < stringCount; i++ {
		var length  /*line :351:14*/_Ctype_uint32_t /*line :351:24*/
		value := func() *_Ctype_char{ _cgo0 := /*line :352:43*/ptr; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :352:58*/(i); var _cgo2 *_Ctype_uint32_t = /*line :352:63*/&length; _cgoCheckPointer(_cgo0, nil); return /*line :352:71*/_Cfunc_ts_query_string_value_for_id(_cgo0, _cgo1, _cgo2); }()
		stringValues[i] = ( /*line :353:21*/_Cfunc_GoStringN /*line :353:31*/)(value,  /*line :353:40*/_Ctype_int /*line :353:45*/(length))
	}

	// Build a vector of strings to represent literal values used in predicates.
	for i := 0; i < patternCount; i++ {
		var length  /*line :358:14*/_Ctype_uint32_t /*line :358:24*/
		rawPredicates := func() *_Ctype_struct_TSQueryPredicateStep{ _cgo0 := /*line :359:54*/ptr; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :359:69*/(i); var _cgo2 *_Ctype_uint32_t = /*line :359:74*/&length; _cgoCheckPointer(_cgo0, nil); return /*line :359:82*/_Cfunc_ts_query_predicates_for_pattern(_cgo0, _cgo1, _cgo2); }()
		predicateSteps := unsafe.Slice(rawPredicates, int(length))

		byteOffset := func() _Ctype_uint32_t{ _cgo0 := /*line :362:51*/ptr; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :362:66*/(i); _cgoCheckPointer(_cgo0, nil); return /*line :362:70*/_Cfunc_ts_query_start_byte_for_pattern(_cgo0, _cgo1); }()
		row := 0
		for i, c := range source {
			if i >= int(byteOffset) {
				break
			}
			if c == '\n' {
				row++
			}
		}
		const (
			TYPE_DONE    = ( /*line :373:19*/_Ciconst_TSQueryPredicateStepTypeDone /*line :373:48*/)
			TYPE_CAPTURE = ( /*line :374:19*/_Ciconst_TSQueryPredicateStepTypeCapture /*line :374:51*/)
			TYPE_STRING  = ( /*line :375:19*/_Ciconst_TSQueryPredicateStepTypeString /*line :375:50*/)
		)

		textPredicates := make([]TextPredicateCapture, 0)
		propertyPredicates := make([]PropertyPredicate, 0)
		propertySettings := make([]QueryProperty, 0)
		generalPredicates := make([]QueryPredicate, 0)

		// iterate over predicateSteps, and consi
		split := func(steps [] /*line :384:25*/_Ctype_TSQueryPredicateStep /*line :384:47*/, sep  /*line :384:53*/_Ctype_TSQueryPredicateStepType /*line :384:79*/) [][] /*line :384:85*/_Ctype_TSQueryPredicateStep /*line :384:107*/ {
			var result [][] /*line :385:19*/_Ctype_TSQueryPredicateStep /*line :385:41*/
			var current [] /*line :386:18*/_Ctype_TSQueryPredicateStep /*line :386:40*/
			for _, t := range steps {
				if t._type == sep {
					result = append(result, current)
					current = nil
				} else {
					current = append(current, t)
				}
			}
			if len(current) > 0 {
				result = append(result, current)
			}
			return result
		}

		for _, p := range split(predicateSteps, TYPE_DONE) {
			if len(p) == 0 {
				continue
			}

			if p[0]._type != TYPE_STRING {
				func() { _cgo0 := /*line :407:23*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :407:27*/_Cfunc_ts_query_delete(_cgo0); }()
				return nil, predicateError(uint(row), fmt.Sprintf("Expected predicate to start with a function name. Got @%s.", captureNames[p[0].value_id]))
			}

			// Build a predicate for each of the known predicate function names.
			operatorName := stringValues[p[0].value_id]
			switch operatorName {
			case "eq?", "not-eq?", "any-eq?", "any-not-eq?":
				if len(p) != 3 {
					func() { _cgo0 := /*line :416:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :416:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("Wrong number of arguments to #eq? predicate. Expected 2, got %d.", len(p)-1))
				}
				if p[1]._type != TYPE_CAPTURE {
					func() { _cgo0 := /*line :420:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :420:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("First argument to #eq? predicate must be a capture name. Got literal %s.", stringValues[p[1].value_id]))
				}

				isPositive := operatorName == "eq?" || operatorName == "any-eq?"
				matchAll := operatorName == "eq?" || operatorName == "not-eq?"
				if p[2]._type == TYPE_CAPTURE {
					textPredicates = append(textPredicates, TextPredicateCapture{
						Type:          TextPredicateTypeEqCapture,
						CaptureId:     uint(p[1].value_id),
						Value:         uint(p[2].value_id),
						Positive:      isPositive,
						MatchAllNodes: matchAll,
					})
				} else {
					textPredicates = append(textPredicates, TextPredicateCapture{
						Type:          TextPredicateTypeEqString,
						CaptureId:     uint(p[1].value_id),
						Value:         stringValues[p[2].value_id],
						Positive:      isPositive,
						MatchAllNodes: matchAll,
					})
				}

			case "match?", "not-match?", "any-match?", "any-not-match?":
				if len(p) != 3 {
					func() { _cgo0 := /*line :446:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :446:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("Wrong number of arguments to #match? predicate. Expected 2, got %d.", len(p)-1))
				}
				if p[1]._type != TYPE_CAPTURE {
					func() { _cgo0 := /*line :450:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :450:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("First argument to #match? predicate must be a capture name. Got literal %s.", stringValues[p[1].value_id]))
				}
				if p[2]._type == TYPE_CAPTURE {
					func() { _cgo0 := /*line :454:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :454:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("Second argument to #match? predicate must be a literal. Got capture @%s.", captureNames[p[2].value_id]))
				}

				isPositive := operatorName == "match?" || operatorName == "any-match?"
				matchAll := operatorName == "match?" || operatorName == "not-match?"
				regex, err := regexp.Compile(stringValues[p[2].value_id])
				if err != nil {
					func() { _cgo0 := /*line :462:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :462:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("Invalid regex: '%s'", stringValues[p[2].value_id]))
				}
				textPredicates = append(textPredicates, TextPredicateCapture{
					Type:          TextPredicateTypeMatchString,
					CaptureId:     uint(p[1].value_id),
					Value:         regex,
					Positive:      isPositive,
					MatchAllNodes: matchAll,
				})

			case "set!":
				property, err := parseProperty(uint(row), operatorName, captureNames, stringValues, p[1:])
				if err != nil {
					func() { _cgo0 := /*line :476:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :476:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, err
				}
				propertySettings = append(propertySettings, property)

			case "is?", "is-not?":
				property, err := parseProperty(uint(row), operatorName, captureNames, stringValues, p[1:])
				if err != nil {
					func() { _cgo0 := /*line :484:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :484:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, err
				}
				propertyPredicates = append(propertyPredicates, PropertyPredicate{
					Property: property,
					Positive: operatorName == "is?",
				})

			case "any-of?", "not-any-of?":
				if len(p) < 2 {
					func() { _cgo0 := /*line :494:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :494:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("Wrong number of arguments to #any-of? predicate. Expected at least 1, got %d.", len(p)-1))
				}
				if p[1]._type != TYPE_CAPTURE {
					func() { _cgo0 := /*line :498:24*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :498:28*/_Cfunc_ts_query_delete(_cgo0); }()
					return nil, predicateError(uint(row), fmt.Sprintf("First argument to #any-of? predicate must be a capture name. Got literal %s.", stringValues[p[1].value_id]))
				}

				isPositive := operatorName == "any-of?"
				values := make([]string, 0)

				for _, arg := range p[2:] {
					if arg._type == TYPE_CAPTURE {
						func() { _cgo0 := /*line :507:25*/ptr; _cgoCheckPointer(_cgo0, nil); /*line :507:29*/_Cfunc_ts_query_delete(_cgo0); }()
						return nil, predicateError(uint(row), fmt.Sprintf("Arguments to #any-of? predicate must be literals. Got capture @%s.", captureNames[arg.value_id]))
					}
					values = append(values, stringValues[arg.value_id])
				}
				textPredicates = append(textPredicates, TextPredicateCapture{
					Type:          TextPredicateTypeAnyString,
					CaptureId:     uint(p[1].value_id),
					Value:         values,
					Positive:      isPositive,
					MatchAllNodes: true,
				})

			default:
				args := make([]QueryPredicateArg, 0)
				for _, a := range p[1:] {
					if a._type == TYPE_CAPTURE {
						args = append(args, QueryPredicateArg{CaptureId: new(uint), String: nil})
						*args[len(args)-1].CaptureId = uint(a.value_id)
					} else {
						args = append(args, QueryPredicateArg{CaptureId: nil, String: new(string)})
						*args[len(args)-1].String = stringValues[a.value_id]
					}
				}
				generalPredicates = append(generalPredicates, QueryPredicate{
					Operator: operatorName,
					Args:     args,
				})
			}
		}

		textPredicatesVec[i] = textPredicates
		propertyPredicatesVec[i] = propertyPredicates
		propertySettingsVec[i] = propertySettings
		generalPredicatesVec[i] = generalPredicates
	}

	query := &Query{
		_inner:             ptr,
		captureNames:       captureNames,
		captureQuantifiers: captureQuantifiersVec,
		TextPredicates:     textPredicatesVec,
		propertyPredicates: propertyPredicatesVec,
		propertySettings:   propertySettingsVec,
		generalPredicates:  generalPredicatesVec,
	}
	return query, nil
}

func (q *Query) Close() {
	func() { _cgo0 := /*line :557:20*/q._inner; _cgoCheckPointer(_cgo0, nil); /*line :557:29*/_Cfunc_ts_query_delete(_cgo0); }()
}

// Get the byte offset where the given pattern starts in the query's source.
func (q *Query) StartByteForPattern(index uint) uint {
	if index >= uint(len(q.TextPredicates)) {
		panic(fmt.Sprintf("Pattern index is %d but the pattern count is %d", index, len(q.TextPredicates)))
	}
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :565:48*/q._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :565:68*/(index); _cgoCheckPointer(_cgo0, nil); return /*line :565:76*/_Cfunc_ts_query_start_byte_for_pattern(_cgo0, _cgo1); }())
}

// Get the byte offset where the given pattern ends in the query's source.
func (q *Query) EndByteForPattern(index uint) uint {
	if index >= uint(len(q.TextPredicates)) {
		panic(fmt.Sprintf("Pattern index is %d but the pattern count is %d", index, len(q.TextPredicates)))
	}
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :573:46*/q._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :573:66*/(index); _cgoCheckPointer(_cgo0, nil); return /*line :573:74*/_Cfunc_ts_query_end_byte_for_pattern(_cgo0, _cgo1); }())
}

// Get the number of patterns in the query.
func (q *Query) PatternCount() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :578:39*/q._inner; _cgoCheckPointer(_cgo0, nil); return /*line :578:48*/_Cfunc_ts_query_pattern_count(_cgo0); }())
}

// Get the names of the captures used in the query.
func (q *Query) CaptureNames() []string {
	return q.captureNames
}

// Get the quantifiers of the captures used in the query.
func (q *Query) CaptureQuantifiers(index uint) []CaptureQuantifier {
	return q.captureQuantifiers[index]
}

// Get the index for a given capture name.
func (q *Query) CaptureIndexForName(name string) (uint, bool) {
	for i, n := range q.captureNames {
		if n == name {
			return uint(i), true
		}
	}
	return 0, false
}

// Get the properties that are checked for the given pattern index.
//
// This includes predicates with the operators `is?` and `is-not?`.
func (q *Query) PropertyPredicates(index uint) []PropertyPredicate {
	return q.propertyPredicates[index]
}

// Get the properties that are set for the given pattern index.
//
// This includes predicates with the operator `set!`.
func (q *Query) PropertySettings(index uint) []QueryProperty {
	return q.propertySettings[index]
}

// Get the other user-defined predicates associated with the given index.
//
// This includes predicate with operators other than:
// * `match?`
// * `eq?` and `not-eq?`
// * `is?` and `is-not?`
// * `set!`
func (q *Query) GeneralPredicates(index uint) []QueryPredicate {
	return q.generalPredicates[index]
}

// Disable a certain capture within a query.
//
// This prevents the capture from being returned in matches, and also
// avoids any resource usage associated with recording the capture.
func (q *Query) DisableCapture(captureName string) {
	cstr := ( /*line :631:10*/_Cfunc_CString /*line :631:18*/)(captureName)
	func() { _cgo0 := /*line :632:29*/q._inner; var _cgo1 *_Ctype_char = /*line :632:39*/cstr; var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :632:55*/(len(captureName)); _cgoCheckPointer(_cgo0, nil); /*line :632:74*/_Cfunc_ts_query_disable_capture(_cgo0, _cgo1, _cgo2); }()
	go_free(unsafe.Pointer(cstr))
}

// Disable a certain pattern within a query.
//
// This prevents the pattern from matching, and also avoids any resource
// usage associated with the pattern.
func (q *Query) DisablePattern(index uint) {
	func() { _cgo0 := /*line :641:29*/q._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :641:49*/(index); _cgoCheckPointer(_cgo0, nil); /*line :641:57*/_Cfunc_ts_query_disable_pattern(_cgo0, _cgo1); }()
}

// Check if a given pattern within a query has a single root node.
func (q *Query) IsPatternRooted(index uint) bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :646:43*/q._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :646:63*/(index); _cgoCheckPointer(_cgo0, nil); return /*line :646:71*/_Cfunc_ts_query_is_pattern_rooted(_cgo0, _cgo1); }())
}

// Check if a given pattern within a query has a single root node.
func (q *Query) IsPatternNonLocal(index uint) bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :651:46*/q._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :651:66*/(index); _cgoCheckPointer(_cgo0, nil); return /*line :651:74*/_Cfunc_ts_query_is_pattern_non_local(_cgo0, _cgo1); }())
}

// Check if a given step in a query is 'definite'.
//
// A query step is 'definite' if its parent pattern will be guaranteed to
// match successfully once it reaches the step.
func (q *Query) IsPatternGuaranteedAtStep(byteOffset uint) bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :659:55*/q._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :659:75*/(byteOffset); _cgoCheckPointer(_cgo0, nil); return /*line :659:88*/_Cfunc_ts_query_is_pattern_guaranteed_at_step(_cgo0, _cgo1); }())
}

func parseProperty(row uint, functionName string, captureNames []string, stringValues []string, args [] /*line :662:104*/_Ctype_TSQueryPredicateStep /*line :662:126*/) (QueryProperty, *QueryError) {
	if len(args) == 0 || len(args) > 3 {
		return QueryProperty{}, predicateError(row, fmt.Sprintf("Wrong number of arguments to %s predicate. Expected 1 to 3, got %d.", functionName, len(args)))
	}

	var captureId *uint
	var key *string
	var value *string

	for _, arg := range args {
		if arg._type == ( /*line :672:19*/_Ciconst_TSQueryPredicateStepTypeCapture /*line :672:51*/) {
			if captureId != nil {
				return QueryProperty{}, predicateError(row, fmt.Sprintf("Invalid arguments to %s predicate. Unexpected second capture name @%s", functionName, captureNames[arg.value_id]))
			}
			captureId = new(uint)
			*captureId = uint(arg.value_id)
		} else if key == nil {
			k := stringValues[arg.value_id]
			key = &k
		} else if value == nil {
			v := stringValues[arg.value_id]
			value = &v
		} else {
			return QueryProperty{}, predicateError(row, fmt.Sprintf("Invalid arguments to %s predicate. Unexpected third argument @%s", functionName, stringValues[arg.value_id]))
		}
	}

	if key == nil {
		return QueryProperty{}, predicateError(row, fmt.Sprintf("Invalid arguments to %s predicate. Missing key argument", functionName))
	}

	return QueryProperty{
		Key:       *key,
		Value:     value,
		CaptureId: captureId,
	}, nil
}

// Create a new cursor for executing a given query.
//
// The cursor stores the state that is needed to iteratively search for
// matches.
func NewQueryCursor() *QueryCursor {
	return &QueryCursor{_inner: ( /*line :705:30*/_Cfunc_ts_query_cursor_new /*line :705:50*/)()}
}

// Delete the underlying memory for a query cursor.
func (qc *QueryCursor) Close() {
	func() { _cgo0 := /*line :710:27*/qc._inner; _cgoCheckPointer(_cgo0, nil); /*line :710:37*/_Cfunc_ts_query_cursor_delete(_cgo0); }()
}

// Return the maximum number of in-progress matches for this cursor.
func (qc *QueryCursor) MatchLimit() uint {
	return uint(func() _Ctype_uint32_t{ _cgo0 := /*line :715:44*/qc._inner; _cgoCheckPointer(_cgo0, nil); return /*line :715:54*/_Cfunc_ts_query_cursor_match_limit(_cgo0); }())
}

// Set the maximum number of in-progress matches for this cursor.
// The limit must be > 0 and <= 65536.
func (qc *QueryCursor) SetMatchLimit(limit uint) {
	func() { _cgo0 := /*line :721:36*/qc._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :721:57*/(limit); _cgoCheckPointer(_cgo0, nil); /*line :721:65*/_Cfunc_ts_query_cursor_set_match_limit(_cgo0, _cgo1); }()
}

// Set the maximum duration in microseconds that query execution should be allowed to
// take before halting.
//
// If query execution takes longer than this, it will halt early, returning None.
func (qc *QueryCursor) SetTimeoutMicros(timeoutMicros uint64) {
	func() { _cgo0 := /*line :729:39*/qc._inner; var _cgo1 _Ctype_uint64_t = _Ctype_uint64_t /*line :729:60*/(timeoutMicros); _cgoCheckPointer(_cgo0, nil); /*line :729:76*/_Cfunc_ts_query_cursor_set_timeout_micros(_cgo0, _cgo1); }()
}

// Get the duration in microseconds that query execution is allowed to take.
//
// This is set via [QueryCursor.SetTimeoutMicros]
func (qc *QueryCursor) TimeoutMicros() uint64 {
	return uint64(func() _Ctype_uint64_t{ _cgo0 := /*line :736:49*/qc._inner; _cgoCheckPointer(_cgo0, nil); return /*line :736:59*/_Cfunc_ts_query_cursor_timeout_micros(_cgo0); }())
}

// Check if, on its last execution, this cursor exceeded its maximum number
// of in-progress matches.
func (qc *QueryCursor) DidExceedMatchLimit() bool {
	return bool(func() _Ctype__Bool{ _cgo0 := /*line :742:55*/qc._inner; _cgoCheckPointer(_cgo0, nil); return /*line :742:65*/_Cfunc_ts_query_cursor_did_exceed_match_limit(_cgo0); }())
}

// Iterate over all of the matches in the order that they were found.
//
// Each match contains the index of the pattern that matched, and a list of
// captures. Because multiple patterns can match the same set of nodes,
// one match may contain captures that appear *before* some of the
// captures from a previous match.
func (qc *QueryCursor) Matches(query *Query, node *Node, text []byte) QueryMatches {
	func() { _cgo0 := /*line :752:25*/qc._inner; _cgo1 := /*line :752:36*/query._inner; _cgo2 := /*line :752:50*/node._inner; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); /*line :752:62*/_Cfunc_ts_query_cursor_exec(_cgo0, _cgo1, _cgo2); }()
	qm := QueryMatches{
		_inner:  qc._inner,
		query:   query,
		text:    text,
		buffer1: []byte{},
		buffer2: []byte{},
	}
	if qm._inner != qc._inner {
		panic("inner pointers of `QueryCursor` and `QueryMatches` are not equal")
	}
	if qm.query != query {
		panic("query pointers of `QueryCursor` and `QueryMatches` are not equal")
	}

	return qm
}

// This C function is passed to Tree-sitter as the progress callback.
//
//export queryProgressCallback
func queryProgressCallback(state * /*line :773:35*/_Ctype_TSQueryCursorState /*line :773:55*/)  /*line :773:57*/_Ctype_bool /*line :773:63*/ {
	payload := pointer.Restore(state.payload).(*QueryCursorOptions)
	return  /*line :775:9*/_Ctype_bool /*line :775:15*/(payload.ProgressCallback(QueryCursorState{
		CurrentByteOffset: uint32(state.current_byte_offset),
	}))
}

// Iterate over all of the matches in the order that they were found, with options.
//
// Each match contains the index of the pattern that matched, and a list of
// captures. Because multiple patterns can match the same set of nodes,
// one match may contain captures that appear *before* some of the
// captures from a previous match.
func (qc *QueryCursor) MatchesWithOptions(query *Query, node *Node, text []byte, options QueryCursorOptions) QueryMatches {
	cOptions := & /*line :787:15*/_Ctype_TSQueryCursorOptions /*line :787:37*/{
		payload:           pointer.Save(&options),
		progress_callback: (*[0]byte)(( /*line :789:33*/_Cgo_ptr(_Cfpvar_fp_queryProgressCallback) /*line :789:55*/)),
	}

	func() { _cgo0 := /*line :792:38*/qc._inner; _cgo1 := /*line :792:49*/query._inner; _cgo2 := /*line :792:63*/node._inner; _cgo3 := /*line :792:76*/cOptions; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); _cgoCheckPointer(_cgo3, nil); /*line :792:85*/_Cfunc_ts_query_cursor_exec_with_options(_cgo0, _cgo1, _cgo2, _cgo3); }()

	qm := QueryMatches{
		_inner:  qc._inner,
		query:   query,
		text:    text,
		buffer1: []byte{},
		buffer2: []byte{},
	}
	if qm._inner != qc._inner {
		panic("inner pointers of `QueryCursor` and `QueryMatches` are not equal")
	}
	if qm.query != query {
		panic("query pointers of `QueryCursor` and `QueryMatches` are not equal")
	}

	return qm
}

// Iterate over all of the individual captures in the order that they
// appear.
//
// This is useful if you don't care about which pattern matched, and just
// want a single, ordered sequence of captures.
func (qc *QueryCursor) Captures(query *Query, node *Node, text []byte) QueryCaptures {
	func() { _cgo0 := /*line :817:25*/qc._inner; _cgo1 := /*line :817:36*/query._inner; _cgo2 := /*line :817:50*/node._inner; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); /*line :817:62*/_Cfunc_ts_query_cursor_exec(_cgo0, _cgo1, _cgo2); }()
	return QueryCaptures{
		_inner:  qc._inner,
		query:   query,
		text:    text,
		buffer1: []byte{},
		buffer2: []byte{},
	}
}

// Set the range of bytes in which the query will be executed.
//
// The query cursor will return matches that intersect with the given point range.
// This means that a match may be returned even if some of its captures fall
// outside the specified range, as long as at least part of the match
// overlaps with the range.
//
// For example, if a query pattern matches a node that spans a larger area
// than the specified range, but part of that node intersects with the range,
// the entire match will be returned.
//
// This will have no effect if the start byte is greater than the end byte.
func (qc *QueryCursor) SetByteRange(startByte uint, endByte uint) *QueryCursor {
	func() _Ctype__Bool{ _cgo0 := /*line :840:35*/qc._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :840:56*/(startByte); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :840:79*/(endByte); _cgoCheckPointer(_cgo0, nil); return /*line :840:89*/_Cfunc_ts_query_cursor_set_byte_range(_cgo0, _cgo1, _cgo2); }()
	return qc
}

// Set the range of (row, column) positions in which the query will be executed.
//
// The query cursor will return matches that intersect with the given point range.
// This means that a match may be returned even if some of its captures fall
// outside the specified range, as long as at least part of the match
// overlaps with the range.
//
// For example, if a query pattern matches a node that spans a larger area
// than the specified range, but part of that node intersects with the range,
// the entire match will be returned.
//
// This will have no effect if the start point is greater than the end point.
func (qc *QueryCursor) SetPointRange(startPoint Point, endPoint Point) *QueryCursor {
	func() _Ctype__Bool{ _cgo0 := /*line :857:36*/qc._inner; var _cgo1 _Ctype_struct_TSPoint = /*line :857:47*/startPoint.toTSPoint(); var _cgo2 _Ctype_struct_TSPoint = /*line :857:71*/endPoint.toTSPoint(); _cgoCheckPointer(_cgo0, nil); return /*line :857:92*/_Cfunc_ts_query_cursor_set_point_range(_cgo0, _cgo1, _cgo2); }()
	return qc
}

// Set the maximum start depth for a query cursor.
//
// This prevents cursors from exploring children nodes at a certain depth.
// Note if a pattern includes many children, then they will still be
// checked.
//
// The zero max start depth value can be used as a special behavior and
// it helps to destructure a subtree by staying on a node and using
// captures for interested parts. Note that the zero max start depth
// only limit a search depth for a pattern's root node but other nodes
// that are parts of the pattern may be searched at any depth what
// defined by the pattern structure.
//
// Set to `nil` to remove the maximum start depth.
func (qc *QueryCursor) SetMaxStartDepth(depth *uint) *QueryCursor {
	if depth == nil {
		func() { _cgo0 := /*line :877:41*/qc._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :877:62*/(math.MaxUint32); _cgoCheckPointer(_cgo0, nil); /*line :877:79*/_Cfunc_ts_query_cursor_set_max_start_depth(_cgo0, _cgo1); }()
	} else {
		func() { _cgo0 := /*line :879:41*/qc._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :879:62*/(*depth); _cgoCheckPointer(_cgo0, nil); /*line :879:71*/_Cfunc_ts_query_cursor_set_max_start_depth(_cgo0, _cgo1); }()
	}
	return qc
}

func (qm *QueryMatch) Id() uint {
	return qm.id
}

func newQueryMatch(m * /*line :888:23*/_Ctype_TSQueryMatch /*line :888:37*/, cursor * /*line :888:47*/_Ctype_TSQueryCursor /*line :888:62*/) QueryMatch {
	var captures []QueryCapture
	if m.capture_count > 0 {
		cCaptures := unsafe.Slice(m.captures, m.capture_count)
		captures = *(*[]QueryCapture)(unsafe.Pointer(&cCaptures))
	}
	return QueryMatch{
		cursor:       cursor,
		Captures:     captures,
		PatternIndex: uint(m.pattern_index),
		id:           uint(m.id),
	}
}

func (qm *QueryMatch) Remove() {
	func() { _cgo0 := /*line :903:33*/qm.cursor; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :903:54*/(qm.id); _cgoCheckPointer(_cgo0, nil); /*line :903:62*/_Cfunc_ts_query_cursor_remove_match(_cgo0, _cgo1); }()
}

func (qm *QueryMatch) NodesForCaptureIndex(captureIndex uint) []Node {
	nodes := make([]Node, 0)
	for _, capture := range qm.Captures {
		if uint(capture.Index) == captureIndex {
			nodes = append(nodes, capture.Node)
		}
	}

	return nodes
}

func (qm *QueryMatch) SatisfiesTextPredicate(query *Query, buffer1, buffer2 []byte, text []byte) bool {
	satisfies := true

	condition := func(predicate TextPredicateCapture) bool {
		switch predicate.Type {
		case TextPredicateTypeEqCapture:
			i := predicate.CaptureId
			j := predicate.Value.(uint)
			nodes1 := qm.NodesForCaptureIndex(i)
			nodes2 := qm.NodesForCaptureIndex(j)
			for len(nodes1) > 0 && len(nodes2) > 0 {
				node1 := nodes1[0]
				node2 := nodes2[0]
				isPositiveMatch := bytes.Equal(text[node1.StartByte():node1.EndByte()], text[node2.StartByte():node2.EndByte()])
				if isPositiveMatch != predicate.Positive && predicate.MatchAllNodes {
					return false
				}
				if isPositiveMatch == predicate.Positive && !predicate.MatchAllNodes {
					return true
				}
				nodes1 = nodes1[1:]
				nodes2 = nodes2[1:]
			}
			return len(nodes1) == 0 && len(nodes2) == 0

		case TextPredicateTypeEqString:
			i := predicate.CaptureId
			s := predicate.Value.(string)
			nodes := qm.NodesForCaptureIndex(i)
			for _, node := range nodes {
				nodeText := text[node.StartByte():node.EndByte()]
				isPositiveMatch := bytes.Equal(nodeText, []byte(s))
				if isPositiveMatch != predicate.Positive && predicate.MatchAllNodes {
					return false
				}
				if isPositiveMatch == predicate.Positive && !predicate.MatchAllNodes {
					return true
				}
			}
			return true

		case TextPredicateTypeMatchString:
			i := predicate.CaptureId
			r := predicate.Value.(*regexp.Regexp)

			nodes := qm.NodesForCaptureIndex(i)
			for _, node := range nodes {
				nodeText := text[node.StartByte():node.EndByte()]
				isPositiveMatch := r.Match(nodeText)
				if isPositiveMatch != predicate.Positive && predicate.MatchAllNodes {
					return false
				}
				if isPositiveMatch == predicate.Positive && !predicate.MatchAllNodes {
					return true
				}
			}
			return true
		case TextPredicateTypeAnyString:
			i := predicate.CaptureId
			v := predicate.Value.([]string)
			nodes := qm.NodesForCaptureIndex(i)
			for _, node := range nodes {
				nodeText := text[node.StartByte():node.EndByte()]
				isPositiveMatch := false
				for _, s := range v {
					if bytes.Equal(nodeText, []byte(s)) {
						isPositiveMatch = true
						break
					}
				}
				if isPositiveMatch != predicate.Positive {
					return false
				}
			}
			return true
		}

		return false
	}

	for _, predicate := range query.TextPredicates[qm.PatternIndex] {
		if !condition(predicate) {
			satisfies = false
			break
		}
	}

	return satisfies
}

func NewQueryProperty(key string, value *string, captureId *uint) QueryProperty {
	return QueryProperty{
		Key:       key,
		Value:     value,
		CaptureId: captureId,
	}
}

// Next will return the next match in the sequence of matches.
//
// Subsequent calls to [QueryMatches.Next] will overwrite the memory at the same location as prior matches, since the memory is reused. You can think of this as a stateful iterator.
// If you need to keep the data of a prior match without it being overwritten, you should copy what you need before calling [QueryMatches.Next] again.
//
// If there are no more matches, it will return nil.
func (qm *QueryMatches) Next() *QueryMatch {
	for {
		m := (* /*line :1023:10*/_Ctype_TSQueryMatch /*line :1023:24*/)(( /*line :1023:26*/_Cfunc__CMalloc /*line :1023:33*/)(( /*line :1023:35*/_Ciconst_sizeof_TSQueryMatch /*line :1023:55*/)))
		defer func() func() { _cgo0 := /*line :1024:16*/unsafe.Pointer(m); return func() { _cgoCheckPointer(_cgo0, nil); /*line :1024:34*/_Cfunc_free(_cgo0); }}()()
		if func() _Ctype__Bool{ _cgo0 := /*line :1025:35*/qm._inner; _cgo1 := /*line :1025:46*/m; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1025:48*/_Cfunc_ts_query_cursor_next_match(_cgo0, _cgo1); }() {
			result := newQueryMatch(m, qm._inner)
			if result.SatisfiesTextPredicate(
				qm.query,
				qm.buffer1,
				qm.buffer2,
				qm.text,
			) {
				return &result
			}
		} else {
			return nil
		}
	}
}

// Next will return the next match in the sequence of matches, as well as the index of the capture.
//
// Subsequent calls to [QueryCaptures.Next] will overwrite the memory at the same location as prior matches, since the memory is reused. You can think of this as a stateful iterator.
// If you need to keep the data of a prior match without it being overwritten, you should copy what you need before calling [QueryCaptures.Next] again.
//
// If there are no more matches, it will return nil.
func (qc *QueryCaptures) Next() (*QueryMatch, uint) {
	for {
		m := (* /*line :1049:10*/_Ctype_TSQueryMatch /*line :1049:24*/)(( /*line :1049:26*/_Cfunc__CMalloc /*line :1049:33*/)(( /*line :1049:35*/_Ciconst_sizeof_TSQueryMatch /*line :1049:55*/)))
		var captureIndex  /*line :1050:20*/_Ctype_uint32_t /*line :1050:30*/
		if func() _Ctype__Bool{ _cgo0 := /*line :1051:37*/qc._inner; _cgo1 := /*line :1051:48*/m; var _cgo2 *_Ctype_uint32_t = /*line :1051:51*/&captureIndex; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return /*line :1051:65*/_Cfunc_ts_query_cursor_next_capture(_cgo0, _cgo1, _cgo2); }() {
			result := newQueryMatch(m, qc._inner)
			if result.SatisfiesTextPredicate(
				qc.query,
				qc.buffer1,
				qc.buffer2,
				qc.text,
			) {
				return &result, uint(captureIndex)
			}
			result.Remove()
		} else {
			return nil, 0
		}
	}
}

func (qm *QueryMatches) SetByteRange(startByte uint, endByte uint) {
	func() _Ctype__Bool{ _cgo0 := /*line :1069:35*/qm._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :1069:56*/(startByte); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :1069:79*/(endByte); _cgoCheckPointer(_cgo0, nil); return /*line :1069:89*/_Cfunc_ts_query_cursor_set_byte_range(_cgo0, _cgo1, _cgo2); }()
}

func (qm *QueryMatches) SetPointRange(startPoint Point, endPoint Point) {
	func() _Ctype__Bool{ _cgo0 := /*line :1073:36*/qm._inner; var _cgo1 _Ctype_struct_TSPoint = /*line :1073:47*/startPoint.toTSPoint(); var _cgo2 _Ctype_struct_TSPoint = /*line :1073:71*/endPoint.toTSPoint(); _cgoCheckPointer(_cgo0, nil); return /*line :1073:92*/_Cfunc_ts_query_cursor_set_point_range(_cgo0, _cgo1, _cgo2); }()
}

func (qc *QueryCaptures) SetByteRange(startByte uint, endByte uint) {
	func() _Ctype__Bool{ _cgo0 := /*line :1077:35*/qc._inner; var _cgo1 _Ctype_uint32_t = _Ctype_uint32_t /*line :1077:56*/(startByte); var _cgo2 _Ctype_uint32_t = _Ctype_uint32_t /*line :1077:79*/(endByte); _cgoCheckPointer(_cgo0, nil); return /*line :1077:89*/_Cfunc_ts_query_cursor_set_byte_range(_cgo0, _cgo1, _cgo2); }()
}

func (qc *QueryCaptures) SetPointRange(startPoint Point, endPoint Point) {
	func() _Ctype__Bool{ _cgo0 := /*line :1081:36*/qc._inner; var _cgo1 _Ctype_struct_TSPoint = /*line :1081:47*/startPoint.toTSPoint(); var _cgo2 _Ctype_struct_TSPoint = /*line :1081:71*/endPoint.toTSPoint(); _cgoCheckPointer(_cgo0, nil); return /*line :1081:92*/_Cfunc_ts_query_cursor_set_point_range(_cgo0, _cgo1, _cgo2); }()
}

func predicateError(row uint, message string) *QueryError {
	return &QueryError{
		Kind:    QueryErrorPredicate,
		Row:     row,
		Column:  0,
		Offset:  0,
		Message: message,
	}
}
