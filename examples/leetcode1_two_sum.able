package twosum

## Given an array of integers nums and an integer target,
## return indices of the two numbers such that they add up to target.
## You may assume that each input would have exactly one solution,
## and you may not use the same element twice.

fn two_sum(nums: Array i32, target: i32) -> (i32, i32) {
  ## Use a hash map to store complement values
  seen := Map i32 i32 {}

  i := 0
  while i < nums.length {
    num := nums[i]
    complement := target - num

    if seen.has_key(complement) {
      return (seen[complement], i)
    }

    seen[num] = i
    i = i + 1
  }

  ## This should never happen given the problem constraints
  (-1, -1)
}

fn main() -> void {
  ## Test cases
  nums1 := [2, 7, 11, 15]
  target1 := 22
  result1 := two_sum(nums1, target1)
  print(`Input: ${nums1}, Target: ${target1}`)
  print(`Output: ${result1}`)
  print("")

  nums2 := [3, 2, 4]
  target2 := 6
  result2 := two_sum(nums2, target2)
  print(`Input: ${nums2}, Target: ${target2}`)
  print(`Output: ${result2}`)
  print("")

  nums3 := [3, 3]
  target3 := 6
  result3 := two_sum(nums3, target3)
  print(`Input: ${nums3}, Target: ${target3}`)
  print(`Output: ${result3}`)
}
