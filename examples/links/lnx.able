package links

import able.core.interfaces.{Display, Error}
import able.text.string.{StringBuilder}

## Minimal Able port of the LinkExtractor helper that powers links.rs.
## Parses HTML fragments without a full DOM dependency so the example stays
## self-contained. The parser focuses on anchor tags, supports a tiny subset
## of CSS selectors (`a`, `tag#id`, `tag.class`, `.class`, `#id`), and
## intentionally ignores scripting/style blocks and malformed markup.

struct Link {
  href: string,
  text: string,
  base_url: ?string
}

methods Link {
  fn resolved_href(self: Self) -> string {
    match self.base_url {
      case nil => self.href,
      case base: string => combine_urls(base, self.href)
    }
  }

  fn with_base(self: Self, base_url: string) -> Link {
    Link { href: self.href, text: self.text, base_url: base_url }
  }

  fn label(self: Self) -> string {
    if self.text == "" { self.href } else { self.text }
  }
}

impl Display for Link {
  fn to_string(self: Self) -> string {
    label := self.label()
    resolved := self.resolved_href()
    if label == resolved {
      resolved
    } else {
      `${label} -> ${resolved}`
    }
  }
}

struct LinkFilter {
  tag: string,
  class_name: ?string,
  id: ?string
}

methods LinkFilter {
  fn default() -> LinkFilter {
    LinkFilter { tag: "a", class_name: nil, id: nil }
  }
}

struct LinkAttributes {
  href: ?string,
  class_names: Array string,
  id: ?string
}

struct LinkExtractor {
  html: string,
  filter: LinkFilter
}

methods LinkExtractor {
  fn new(html: string) -> LinkExtractor {
    LinkExtractor { html, filter: LinkFilter::default() }
  }

  fn with_style(html: string, style: string) -> LinkExtractor {
    LinkExtractor { html, filter: parse_style(style) }
  }

  fn links(self: Self) -> Array Link {
    collect_links(self.html, self.filter)
  }

  fn links_with_url(self: Self, base_url: string) -> Array Link {
    links := self.links()
    idx := 0
    loop {
      match links.get(idx) {
        case nil => break,
        case value: Link => {
          links.set(idx, value.with_base(base_url))
        }
      }
      idx = idx + 1
    }
    links
  }
}

fn parse_style(style: string) -> LinkFilter {
  trimmed := trim_ascii(style)
  if trimmed == "" { return LinkFilter::default() }

  first := trimmed[0]
  if first == '.' {
    class_value := trim_ascii(trimmed.substring(1, trimmed.len()))
    if class_value == "" { return LinkFilter::default() }
    return LinkFilter { tag: "a", class_name: class_value, id: nil }
  }
  if first == '#' {
    id_value := trim_ascii(trimmed.substring(1, trimmed.len()))
    if id_value == "" { return LinkFilter::default() }
    return LinkFilter { tag: "a", class_name: nil, id: id_value }
  }

  tag_end := trimmed.len()
  class_value: ?string := nil
  id_value: ?string := nil
  idx := 0
  loop {
    if idx >= trimmed.len() { break }
    ch := trimmed[idx]
    if ch == '.' {
      class_value = trimmed.substring(idx + 1, trimmed.len())
      tag_end = idx
      break
    }
    if ch == '#' {
      id_value = trimmed.substring(idx + 1, trimmed.len())
      tag_end = idx
      break
    }
    idx = idx + 1
  }

  tag := if tag_end <= 0 { trimmed } else { trimmed.substring(0, tag_end) }
  tag_normalized := ascii_lowercase(trim_ascii(tag))
  if tag_normalized == "" { tag_normalized = "a" }

  LinkFilter {
    tag: tag_normalized,
    class_name: match class_value {
      case nil => nil,
      case value: string => {
        cleaned := trim_ascii(value)
        if cleaned == "" { nil } else { cleaned }
      }
    },
    id: match id_value {
      case nil => nil,
      case value: string => {
        cleaned := trim_ascii(value)
        if cleaned == "" { nil } else { cleaned }
      }
    }
  }
}

fn collect_links(html: string, filter: LinkFilter) -> Array Link {
  links := []
  seen := []
  idx := 0
  len := html.len()

  loop {
    match find_from(html, "<", idx) {
      case nil => break,
      case start: i32 => {
        idx = start + 1
        if idx >= len { break }
        marker := html[idx]
        if marker == '!' || marker == '/' || marker == '?' {
          idx = advance_to_after(html, idx, '>')
          continue
        }

        idx = skip_whitespace(html, idx)
        (raw_tag, after_tag) := read_identifier(html, idx)
        if raw_tag == "" {
          idx = after_tag
          continue
        }

        tag := ascii_lowercase(raw_tag)
        idx = after_tag
        (attributes, next_idx, self_closing) := parse_attributes(html, idx)
        idx = next_idx

        if !matches_filter(filter, tag, attributes) {
          continue
        }

        match attributes.href {
          case nil => {},
          case href_value: string => {
            if href_value == "" { continue }
            if has_seen(seen, href_value) { continue }
            seen.push(href_value)

            link_text := ""
            if !self_closing {
              close_idx := find_closing_tag(html, tag, idx)
              if close_idx > idx && close_idx <= len {
                link_text = normalize_link_text(html.substring(idx, close_idx))
              }
              idx = advance_to_after(html, close_idx, '>')
            }

            links.push(Link { href: href_value, text: link_text, base_url: nil })
          }
        }
      }
    }
  }

  links
}

fn matches_filter(filter: LinkFilter, tag: string, attrs: LinkAttributes) -> bool {
  if filter.tag != "" && filter.tag != tag {
    return false
  }

  match filter.id {
    case nil => {},
    case target: string => {
      match attrs.id {
        case nil => return false,
        case candidate: string => {
          if candidate != target { return false }
        }
      }
    }
  }

  match filter.class_name {
    case nil => {},
    case target: string => {
      if !class_list_contains(attrs.class_names, target) {
        return false
      }
    }
  }

  true
}

fn class_list_contains(classes: Array string, target: string) -> bool {
  idx := 0
  loop {
    match classes.get(idx) {
      case nil => break,
      case value: string => {
        if value == target { return true }
      }
    }
    idx = idx + 1
  }
  false
}

fn parse_attributes(html: string, start_idx: i32) -> (LinkAttributes, i32, bool) {
  idx := start_idx
  len := html.len()
  attrs := LinkAttributes { href: nil, class_names: [], id: nil }
  self_closing := false

  loop {
    idx = skip_whitespace(html, idx)
    if idx >= len { break }
    ch := html[idx]
    if ch == '>' {
      idx = idx + 1
      break
    }
    if ch == '/' {
      self_closing = true
      idx = idx + 1
      continue
    }

    (name, after_name) := read_identifier(html, idx)
    if name == "" {
      idx = idx + 1
      continue
    }

    idx = skip_whitespace(html, after_name)
    value := ""
    if idx < len && html[idx] == '=' {
      idx = idx + 1
      idx = skip_whitespace(html, idx)
      (value, idx) = read_attribute_value(html, idx)
      value = trim_ascii(value)
    }

    lowered := ascii_lowercase(name)
    if lowered == "href" {
      attrs.href = value
    } else if lowered == "class" {
      attrs.class_names = split_classes(value)
    } else if lowered == "id" {
      attrs.id = value
    }
  }

  (attrs, idx, self_closing)
}

fn read_attribute_value(html: string, start_idx: i32) -> (string, i32) {
  idx := start_idx
  len := html.len()
  if idx >= len { return ("", idx) }

  delimiter := html[idx]
  quoted := delimiter == '"' || delimiter == '\''
  if quoted {
    idx = idx + 1
    begin := idx
    loop {
      if idx >= len { break }
      if html[idx] == delimiter {
        return (html.substring(begin, idx), idx + 1)
      }
      idx = idx + 1
    }
    (html.substring(begin, len), len)
  } else {
    begin := idx
    loop {
      if idx >= len { break }
      ch := html[idx]
      if is_ascii_whitespace(ch) || ch == '>' { break }
      idx = idx + 1
    }
    (html.substring(begin, idx), idx)
  }
}

fn read_identifier(html: string, start_idx: i32) -> (string, i32) {
  idx := start_idx
  len := html.len()
  loop {
    if idx >= len { break }
    ch := html[idx]
    if !is_identifier_char(ch) { break }
    idx = idx + 1
  }
  if idx == start_idx {
    ("", start_idx)
  } else {
    (html.substring(start_idx, idx), idx)
  }
}

fn is_identifier_char(ch: char) -> bool {
  (ch >= 'a' && ch <= 'z') ||
  (ch >= 'A' && ch <= 'Z') ||
  (ch >= '0' && ch <= '9') ||
  ch == '-' || ch == '_' || ch == ':'
}

fn find_closing_tag(html: string, tag: string, start_idx: i32) -> i32 {
  idx := start_idx
  loop {
    match find_from(html, "<", idx) {
      case nil => return html.len(),
      case pos: i32 => {
        idx = pos + 1
        if idx >= html.len() { return html.len() }
        if html[idx] != '/' { continue }
        idx = idx + 1
        idx = skip_whitespace(html, idx)
        (candidate, after_name) := read_identifier(html, idx)
        normalized := ascii_lowercase(candidate)
        if normalized == tag {
          return pos
        }
        idx = after_name
      }
    }
  }
}

fn normalize_link_text(value: string) -> string {
  cleaned := value.replace("\r", " ")
  cleaned = cleaned.replace("\n", " ")
  cleaned = cleaned.replace("\t", " ")
  collapse := collapse_spaces(cleaned)
  trim_ascii(collapse)
}

fn collapse_spaces(value: string) -> string {
  builder := StringBuilder::with_capacity(value.len())
  idx := 0
  len := value.len()
  last_was_space := false
  loop {
    if idx >= len { break }
    ch := value[idx]
    if is_ascii_whitespace(ch) {
      if !last_was_space {
        builder.push_char(' ')
        last_was_space = true
      }
    } else {
      builder.push_char(ch)
      last_was_space = false
    }
    idx = idx + 1
  }
  finish_builder(builder)
}

fn split_classes(value: string) -> Array string {
  result := []
  if value == "" { return result }
  tokens := value.split(' ')
  idx := 0
  loop {
    match tokens.get(idx) {
      case nil => break,
      case token: string => {
        trimmed := trim_ascii(token)
        if trimmed != "" { result.push(trimmed) }
      }
    }
    idx = idx + 1
  }
  result
}

fn trim_ascii(value: string) -> string {
  len := value.len()
  if len == 0 { return value }
  start := 0
  while start < len and is_ascii_whitespace(value[start]) {
    start = start + 1
  }
  finish := len
  while finish > start and is_ascii_whitespace(value[finish - 1]) {
    finish = finish - 1
  }
  if start == 0 and finish == len {
    value
  } else {
    value.substring(start, finish)
  }
}

fn ascii_lowercase(value: string) -> string {
  builder := StringBuilder::with_capacity(value.len())
  idx := 0
  len := value.len()
  loop {
    if idx >= len { break }
    ch := value[idx]
    code := ch as i32
    if code >= 65 && code <= 90 {
      builder.push_char((code + 32) as char)
    } else {
      builder.push_char(ch)
    }
    idx = idx + 1
  }
  finish_builder(builder)
}

fn skip_whitespace(text: string, start_idx: i32) -> i32 {
  idx := start_idx
  len := text.len()
  loop {
    if idx >= len { break }
    if !is_ascii_whitespace(text[idx]) { break }
    idx = idx + 1
  }
  idx
}

fn is_ascii_whitespace(ch: char) -> bool {
  ch == ' ' || ch == '\n' || ch == '\t' || ch == '\r'
}

fn find_from(text: string, needle: string, start_idx: i32) -> ?i32 {
  if start_idx <= 0 {
    return text.index_of(needle)
  }
  if start_idx >= text.len() { return nil }
  slice := text.substring(start_idx, text.len())
  match slice.index_of(needle) {
    case nil => nil,
    case offset: i32 => start_idx + offset
  }
}

fn advance_to_after(text: string, start_idx: i32, target: char) -> i32 {
  idx := start_idx
  len := text.len()
  loop {
    if idx >= len { break }
    if text[idx] == target {
      return idx + 1
    }
    idx = idx + 1
  }
  len
}

fn has_seen(seen: Array string, href: string) -> bool {
  idx := 0
  loop {
    match seen.get(idx) {
      case nil => break,
      case value: string => {
        if value == href { return true }
      }
    }
    idx = idx + 1
  }
  false
}

fn combine_urls(base_url: string, href: string) -> string {
  if base_url == "" { return href }
  if href == "" { return base_url }
  if href.starts_with("http://") || href.starts_with("https://") || href.starts_with("//") {
    return href
  }
  if href.starts_with("/") {
    return `${trim_trailing_slash(base_url)}${href}`
  }
  prefix := if base_url.ends_with("/") { base_url } else { `${base_url}/` }
  `${prefix}${href}`
}

fn trim_trailing_slash(url: string) -> string {
  if url == "" { return url }
  if url.ends_with("/") {
    url.substring(0, url.len() - 1)
  } else {
    url
  }
}

fn finish_builder(builder: StringBuilder) -> string {
  match builder.finish() {
    case result: string => result,
    case err: Error => raise err
  }
}
