package collections

import able.collections.array.{Array}
import able.collections.enumerable.{Enumerable}
import able.core.iteration.{Iterator, IteratorEnd, Iterable}

struct LazySeq T {
  source: ?(Iterator T),
  cache: Array T,
  exhausted: bool
}

fn lazy_seq_from_array<T>(values: Array T) -> LazySeq T {
  LazySeq { source: nil, cache: values, exhausted: true }
}

methods LazySeq T {
  fn from_iterator(iterator: Iterator T) -> LazySeq T {
    LazySeq {
      source: iterator,
      cache: Array.new(),
      exhausted: false
    }
  }

  fn from_iterable(iterable: Iterable T) -> LazySeq T {
    LazySeq.from_iterator(iterable.iterator())
  }

  fn len(mut self: Self) -> i32 {
    self.ensure_all()
    self.cache.len()
  }

  fn is_empty(mut self: Self) -> bool {
    self.peek(0) == nil
  }

  fn get(mut self: Self, index: i32) -> ?T {
    if index < 0 { return nil }
    self.ensure_index(index)
    self.cache.get(index)
  }

  fn head(mut self: Self) -> ?T {
    self.get(0)
  }

  fn tail(mut self: Self) -> LazySeq T {
    match self.ensure_index(0) {
      case nil => self,
      case _ => {
        new_cache: Array T := Array.new()
        idx := 1
        loop {
          match self.cache.get(idx) {
            case nil => break,
            case value: T => new_cache.push(value)
          }
          idx = idx + 1
        }
        LazySeq {
          source: self.source,
          cache: new_cache,
          exhausted: self.exhausted
        }
      }
    }
  }

  fn to_array(mut self: Self) -> Array T {
    self.ensure_all()
    result := Array.with_capacity(self.cache.len())
    idx := 0
    loop {
      match self.cache.get(idx) {
        case nil => break,
        case value: T => result.push(value)
      }
      idx = idx + 1
    }
    result
  }

  fn take(mut self: Self, count: i32) -> Array T {
    if count <= 0 { return Array.new() }
    self.ensure_index(count - 1)
    result := Array.new()
    idx := 0
    loop {
      if idx >= count { break }
      match self.cache.get(idx) {
        case nil => break,
        case value: T => result.push(value)
      }
      idx = idx + 1
    }
    result
  }

  fn for_each(mut self: Self, visit: T -> void) -> void {
    idx := 0
    loop {
      match self.cache.get(idx) {
        case value: T => {
          visit(value)
        },
        case nil => {
          if self.exhausted {
            return
          }
          match self.pull_next() {
            case nil => return,
            case _ => {}
          }
          continue
        }
      }
      idx = idx + 1
    }
  }

  fn ensure_all(mut self: Self) -> void {
    loop {
      if self.exhausted { break }
      value := self.pull_next()
      if value == nil { break }
    }
  }

  fn ensure_index(mut self: Self, index: i32) -> ?T {
    if index < self.cache.len() {
      return self.cache.get(index)
    }
    loop {
      if self.exhausted { break }
      value := self.pull_next()
      match value {
        case nil => break,
        case _ => {}
      }
      if self.cache.len() - 1 >= index {
        break
      }
    }
    self.cache.get(index)
  }

  fn pull_next(mut self: Self) -> ?T {
    match self.source {
      case nil => {
        self.exhausted = true
        nil
      },
      case iterator => {
        mut mut_iter := iterator
        next_value := mut_iter.next()
        self.source = mut_iter
        match next_value {
          case IteratorEnd => {
            self.source = nil
            self.exhausted = true
            nil
          },
          case value: T => {
            self.cache.push(value)
            value
          }
        }
      }
    }
  }
}

impl Enumerable T for LazySeq T {
  fn each(self: Self, visit: T -> void) -> void {
    mut_copy := self
    mut_copy.for_each(visit)
  }
}
