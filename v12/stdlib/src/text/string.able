package string
import able.kernel.{Array}
import able.collections.array
import able.core.interfaces.{Clone, Default, Extend, Error}
import able.core.iteration.{Iterable, Iterator, IteratorEnd}
import able.core.options.{Result}
import able.core.errors.{RangeError}
import able.kernel.{__able_String_from_builtin, __able_String_to_builtin, __able_char_from_codepoint, __able_char_to_codepoint}

struct String {
  bytes: Array u8,
  len_bytes: i32
}

struct Grapheme {
  bytes: Array u8
}

struct StringBuilder {
  buffer: Array u8
}
private struct StringBytesIter {
  string: String,
  offset: i32
}
private struct StringCharsIter {
  string: String,
  offset: i32
}
private struct StringGraphemesIter {
  string: String,
  offset: i32
}
private struct RawStringBytesIter {
  bytes: Array u8,
  offset: i32,
  len_bytes: i32
}
private struct RawStringCharsIter {
  bytes: Array u8,
  offset: i32,
  len_bytes: i32
}
private struct RawStringGraphemesIter {
  bytes: Array u8,
  offset: i32,
  len_bytes: i32
}

private struct Utf8DecodeResult {
  codepoint: char,
  next_offset: i32
}

struct StringEncodingError {
  message: String,
  offset: ?i32
}

impl Error for StringEncodingError {
  fn message(self: Self) -> String { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

methods String {
  fn empty() -> String {
    String { bytes: Array.with_capacity(0), len_bytes: 0 }
  }

  fn from_bytes_unchecked(bytes: Array u8) -> String { String { len_bytes: bytes.len(), bytes } }

  fn from_bytes(bytes: Array u8) -> Result String {
    utf8_validate(bytes) match {
      case err: StringEncodingError => err,
      case nil => String.from_bytes_unchecked(bytes)
    }
  }

  fn from_builtin(value: String) -> Result String {
    data := __able_String_from_builtin(value)
    utf8_validate(data) match {
      case err: StringEncodingError => err,
      case nil => String.from_bytes_unchecked(data)
    }
  }

  fn is_empty(self: Self) -> bool { self.len_bytes == 0 }

  fn to_builtin(self: Self) -> Result String {
    __able_String_to_builtin(self.bytes.clone())
  }

  fn to_builder(self: Self) -> StringBuilder {
    builder := StringBuilder.with_capacity(self.len_bytes)
    builder.push_bytes(self.bytes.clone())
    builder
  }

  fn concat(strings: Array String) -> String {
    builder := StringBuilder.new();
    idx := 0
    loop {
      strings.get(idx) match {
        case nil => { break },
        case value: String => builder.push_string(unwrap_string(value))
      }
      idx = idx + 1
    }
    builder.finish() match { case result: String => wrap_string(result), case err: Error => { raise err } }
  }

  fn join(strings: Array String, separator: String) -> String {
    builder := StringBuilder.new();
    sep := unwrap_string(separator)
    idx := 0
    loop {
      strings.get(idx) match {
        case nil => { break },
        case value: String => {
          if idx > 0 { builder.push_string(sep) }
          builder.push_string(unwrap_string(value))
        }
      }
      idx = idx + 1
    }
    builder.finish() match { case result: String => wrap_string(result), case err: Error => { raise err } }
  }
}

private fn to_result_string(value: Result String) -> Result String {
  value match {
    case err: Error => err,
    case s: String => s.to_builtin()
  }
}

private fn validated_bytes(value: String) -> Array u8 {
  data := __able_String_from_builtin(value)
  utf8_validate(data) match {
    case err: StringEncodingError => { raise err },
    case nil => data
  }
}

private fn wrap_string(value: String) -> String {
  String.from_builtin(value) match { case err: Error => { raise err }, case s: String => s }
}

private fn unwrap_string(value: String) -> String {
  value.to_builtin() match { case err: Error => { raise err }, case text: String => text }
}

private fn to_u64(value: i32) -> u64 {
  if value <= 0 { 0 } else { value }
}

methods String {
  fn len_bytes(self: Self) -> u64 {
    bytes := validated_bytes(self)
    to_u64(bytes.len())
  }

  fn len_chars(self: Self) -> u64 {
    bytes := validated_bytes(self)
    to_u64(count_chars(bytes, bytes.len()))
  }

  fn len_graphemes(self: Self) -> u64 {
    bytes := validated_bytes(self)
    to_u64(count_graphemes(bytes, bytes.len()))
  }

  fn iterator(self: Self) -> (Iterator u8) {
    self.bytes()
  }

  fn substring(self: Self, start: i32, length: ?i32) -> Result String {
    if start < 0 { return RangeError { message: "substring start must be non-negative" } }
    bytes := validated_bytes(self)
    total_chars := count_chars(bytes, bytes.len())
    if start > total_chars { return RangeError { message: "substring start out of range" } }

    offset := 0
    codepoint_offset(bytes, bytes.len(), start) match {
      case err: Error => { return err },
      case value: i32 => offset = value
    }
    target_end := bytes.len()
    if length != nil {
      if length < 0 { return RangeError { message: "substring length must be non-negative" } }
      limit := start + length
      if limit > total_chars { return RangeError { message: "substring range out of bounds" } }
      codepoint_offset(bytes, bytes.len(), limit) match {
        case err: Error => { return err },
        case value: i32 => target_end = value
      }
    }
    slice := slice_bytes(bytes, offset, target_end)
    __able_String_to_builtin(slice)
  }

  fn subString(self: Self, start: i32, length: ?i32) -> Result String {
    self.substring(start, length)
  }

  fn contains(self: Self, needle: String) -> bool {
    haystack := validated_bytes(self)
    target := validated_bytes(needle)
    hay_len := haystack.len()
    needle_len := target.len()
    if needle_len == 0 { return true }
    if needle_len > hay_len { return false }
    pos := 0
    loop {
      if pos > hay_len - needle_len { break }
      matched := true
      j := 0
      loop {
        if j >= needle_len { break }
        read_byte(haystack, pos + j) match {
          case nil => { matched = false; break },
          case hb: u8 => {
            read_byte(target, j) match {
              case nil => { matched = false; break },
              case nb: u8 => {
                if hb != nb { matched = false; break }
              }
            }
          }
        }
        j = j + 1
      }
      if matched { return true }
      pos = pos + 1
    }
    false
  }

  fn split(self: Self, delimiter: String) -> Array String {
    haystack := validated_bytes(self)
    needle := validated_bytes(delimiter)
    hay_len := haystack.len()
    needle_len := needle.len()
    result: Array String := Array.new();

    if needle_len == 0 {
      offset := 0
      loop {
        if offset >= hay_len { break }
        utf8_decode(haystack, offset, hay_len) match {
          case err: StringEncodingError => { raise err },
          case res: Utf8DecodeResult => {
            segment := slice_bytes(haystack, offset, res.next_offset)
            result.push(__able_String_to_builtin(segment))
            offset = res.next_offset
          }
        }
      }
      return result
    }

    start := 0
    pos := 0
    loop {
      if pos > hay_len - needle_len { break }
      matched := true
      j := 0
      loop {
        if j >= needle_len { break }
        read_byte(haystack, pos + j) match {
          case nil => { matched = false; break },
          case hb: u8 => {
            read_byte(needle, j) match {
              case nil => { matched = false; break },
              case nb: u8 => {
                if hb != nb { matched = false; break }
              }
            }
          }
        }
        j = j + 1
      }
      if matched {
        segment := slice_bytes(haystack, start, pos)
        result.push(__able_String_to_builtin(segment))
        pos = pos + needle_len
        start = pos
      }
      if !matched {
        pos = pos + 1
      }
    }

    tail := slice_bytes(haystack, start, hay_len)
    result.push(__able_String_to_builtin(tail))

    result
  }

  fn replace(self: Self, old: String, new: String) -> String {
    haystack := validated_bytes(self)
    needle := validated_bytes(old)
    replacement := validated_bytes(new)
    hay_len := haystack.len()
    needle_len := needle.len()
    if needle_len == 0 { return __able_String_to_builtin(haystack) }

    builder := StringBuilder.with_capacity(hay_len)
    idx := 0
    start := 0
    loop {
      if idx > hay_len - needle_len { break }
      matched := true
      j := 0
      loop {
        if j >= needle_len { break }
        read_byte(haystack, idx + j) match {
          case nil => { matched = false; break },
          case hb: u8 => {
            read_byte(needle, j) match {
              case nil => { matched = false; break },
              case nb: u8 => { if hb != nb { matched = false; break } }
            }
          }
        }
        j = j + 1
      }
      if matched {
        prefix := slice_bytes(haystack, start, idx)
        builder.push_bytes(prefix)
        builder.push_bytes(replacement.clone())
        idx = idx + needle_len
        start = idx
      }
      if !matched { idx = idx + 1 }
    }
    trailing := slice_bytes(haystack, start, hay_len)
    builder.push_bytes(trailing)
    __able_String_to_builtin(builder.buffer)
  }

  fn starts_with(self: Self, prefix: String) -> bool {
    haystack := validated_bytes(self)
    needle := validated_bytes(prefix)
    if needle.len() > haystack.len() { return false }
    compare_length := needle.len()
    idx := 0
    loop {
      if idx >= compare_length { break }
      read_byte(needle, idx) match {
        case nil => { return false },
        case pb: u8 => {
          read_byte(haystack, idx) match {
            case nil => { return false },
            case sb: u8 => { if pb != sb { return false } }
          }
        }
      }
      idx = idx + 1
    }
    true
  }

  fn ends_with(self: Self, suffix: String) -> bool {
    haystack := validated_bytes(self)
    needle := validated_bytes(suffix)
    if needle.len() > haystack.len() { return false }
    offset := haystack.len() - needle.len()
    idx := 0
    loop {
      if idx >= needle.len() { break }
      read_byte(needle, idx) match {
        case nil => { return false },
        case sb: u8 => {
          read_byte(haystack, offset + idx) match {
            case nil => { return false },
            case pb: u8 => { if sb != pb { return false } }
          }
        }
      }
      idx = idx + 1
    }
    true
  }

  fn bytes(self: Self) -> (Iterator u8) {
    data := validated_bytes(self)
    RawStringBytesIter { bytes: data, offset: 0, len_bytes: data.len() }
  }

  fn chars(self: Self) -> (Iterator char) {
    data := validated_bytes(self)
    RawStringCharsIter { bytes: data, offset: 0, len_bytes: data.len() }
  }

  fn graphemes(self: Self) -> (Iterator Grapheme) {
    data := validated_bytes(self)
    RawStringGraphemesIter { bytes: data, offset: 0, len_bytes: data.len() }
  }

  fn map(self: Self, f: char -> char) -> String {
    builder := StringBuilder.new();
    for ch in self.chars() {
      builder.push_char(f(ch))
    }
    builder.finish() match {
      case result: String => wrap_string(result),
      case err: Error => { raise err }
    }
  }

  fn filter(self: Self, predicate: char -> bool) -> String {
    builder := StringBuilder.new();
    for ch in self.chars() {
      if predicate(ch) { builder.push_char(ch) }
    }
    builder.finish() match {
      case result: String => wrap_string(result),
      case err: Error => { raise err }
    }
  }
}

impl Clone for String {
  fn clone(self: Self) -> String {
    self
  }
}

impl Default for String {
  fn default() -> String { String.empty() }
}

impl Extend char for String {
  fn extend(self: Self, value: char) -> Self {
    builder := self.to_builder()
    builder.push_char(value)
    builder.finish() match {
      case result: String => wrap_string(result),
      case err: Error => { raise err }
    }
  }
}

impl Clone for Grapheme {
  fn clone(self: Self) -> Grapheme {
    Grapheme { bytes: self.bytes.clone() }
  }
}

methods Grapheme {
  fn len_bytes(self: Self) -> u64 { to_u64(self.bytes.len()) }
  fn bytes(self: Self) -> Array u8 { self.bytes.clone() }
  fn as_string(self: Self) -> String { __able_String_to_builtin(self.bytes.clone()) }
}

methods StringBuilder {
  fn new() -> StringBuilder { StringBuilder { buffer: Array.with_capacity(0) } }

  fn with_capacity(capacity: i32) -> StringBuilder {
    StringBuilder { buffer: Array.with_capacity(capacity) }
  }

  fn clear(self: Self) -> void {
    self.buffer.clear()
  }

  fn push_char(self: Self, value: char) -> void {
    bytes := char_to_utf8(value)
    self.buffer.push_all(bytes)
  }

  fn push_byte(self: Self, value: u8) -> void {
    self.buffer.push(value)
  }

  fn push_bytes(self: Self, bytes: Array u8) -> void {
    self.buffer.push_all(bytes)
  }

  fn push_string(self: Self, value: String) -> void {
    self.buffer.push_all(validated_bytes(value))
  }

  fn append_builder(self: Self, other: StringBuilder) -> void {
    self.buffer.push_all(other.buffer)
  }

  fn len_bytes(self: Self) -> u64 { to_u64(self.buffer.len()) }

  fn finish(self: Self) -> Result String {
    to_result_string(String.from_bytes(self.buffer))
  }

  fn map(self: Self, f: char -> char) -> StringBuilder {
    result := StringBuilder.new();
    for ch in self {
      result.push_char(f(ch))
    }
    result
  }

  fn filter(self: Self, predicate: char -> bool) -> StringBuilder {
    result := StringBuilder.new();
    for ch in self {
      if predicate(ch) { result.push_char(ch) }
    }
    result
  }
}

impl Default for StringBuilder {
  fn default() -> StringBuilder { StringBuilder.new() }
}

impl Extend char for StringBuilder {
  fn extend(self: Self, value: char) -> Self {
    self.push_char(value)
    self
  }
}

impl Iterable u8 for String {
  fn iterator(self: Self) -> (Iterator u8) { self.bytes() }
}

impl Iterator u8 for RawStringBytesIter {
  fn next(self: Self) -> u8 | IteratorEnd {
    if self.offset >= self.len_bytes {
      return IteratorEnd {}
    }

    read_byte(self.bytes, self.offset) match {
      case nil => IteratorEnd {},
      case value: u8 => {
        self.offset = self.offset + 1
        value
      }
    }
  }
}

impl Iterable u8 for RawStringBytesIter {
  fn iterator(self: Self) -> (Iterator u8) { self }
}

impl Iterator u8 for StringBytesIter {
  fn next(self: Self) -> u8 | IteratorEnd {
    if self.offset >= self.string.len_bytes {
      return IteratorEnd {}
    }

    read_byte(self.string.bytes, self.offset) match {
      case nil => IteratorEnd {},
      case value: u8 => {
        self.offset = self.offset + 1
        value
      }
    }
  }

  fn size(self: Self) -> u64 {
    remaining := self.string.len_bytes - self.offset
    if remaining <= 0 { 0 } else { remaining }
  }
}

impl Iterable char for String {
  fn iterator(self: Self) -> (Iterator char) { self.chars() }
}

impl Iterable char for StringBuilder {
  fn iterator(self: Self) -> (Iterator char) {
    RawStringCharsIter { bytes: self.buffer.clone(), offset: 0, len_bytes: self.buffer.len() }
  }
}

impl Iterator char for RawStringCharsIter {
  fn next(self: Self) -> char | IteratorEnd {
    if self.offset >= self.len_bytes {
      return IteratorEnd {}
    }

    utf8_decode(self.bytes, self.offset, self.len_bytes) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        self.offset = result.next_offset
        result.codepoint
      }
    }
  }
}

impl Iterable char for RawStringCharsIter {
  fn iterator(self: Self) -> (Iterator char) { self }
}

impl Iterable u8 for StringBytesIter {
  fn iterator(self: Self) -> (Iterator u8) { self }
}

impl Iterator char for StringCharsIter {
  fn next(self: Self) -> char | IteratorEnd {
    if self.offset >= self.string.len_bytes {
      return IteratorEnd {}
    }

    utf8_decode(self.string.bytes, self.offset, self.string.len_bytes) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        self.offset = result.next_offset
        result.codepoint
      }
    }
  }

  fn size(self: Self) -> u64 {
    count := 0
    idx := self.offset
    loop {
      if idx >= self.string.len_bytes { break }
      utf8_decode(self.string.bytes, idx, self.string.len_bytes) match {
        case err: StringEncodingError => { raise err },
        case result: Utf8DecodeResult => {
          idx = result.next_offset
          count = count + 1
        }
      }
    }
    count
  }
}

impl Iterable Grapheme for String {
  fn iterator(self: Self) -> (Iterator Grapheme) { self.graphemes() }
}

impl Iterator Grapheme for RawStringGraphemesIter {
  fn next(self: Self) -> Grapheme | IteratorEnd {
    if self.offset >= self.len_bytes {
      return IteratorEnd {}
    }

    start := self.offset

    utf8_decode(self.bytes, self.offset, self.len_bytes) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        end := result.next_offset
        ## TODO: expand to full grapheme cluster detection once unicode tables land.
        self.offset = end
        Grapheme { bytes: slice_bytes(self.bytes, start, end) }
      }
    }
  }
}

impl Iterable Grapheme for RawStringGraphemesIter {
  fn iterator(self: Self) -> (Iterator Grapheme) { self }
}

impl Iterable char for StringCharsIter {
  fn iterator(self: Self) -> (Iterator char) { self }
}

impl Iterator Grapheme for StringGraphemesIter {
  fn next(self: Self) -> Grapheme | IteratorEnd {
    if self.offset >= self.string.len_bytes {
      return IteratorEnd {}
    }

    start := self.offset

    utf8_decode(self.string.bytes, self.offset, self.string.len_bytes) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        end := result.next_offset
        ## TODO: expand to full grapheme cluster detection once unicode tables land.
        self.offset = end
        Grapheme { bytes: slice_bytes(self.string.bytes, start, end) }
      }
    }
  }

  fn size(self: Self) -> u64 {
    count := 0
    idx := self.offset
    loop {
      if idx >= self.string.len_bytes { break }
      utf8_decode(self.string.bytes, idx, self.string.len_bytes) match {
        case err: StringEncodingError => { raise err },
        case result: Utf8DecodeResult => {
          idx = result.next_offset
          count = count + 1
        }
      }
    }
    count
  }
}

impl Iterable Grapheme for StringGraphemesIter {
  fn iterator(self: Self) -> (Iterator Grapheme) { self }
}

fn utf8_validate(bytes: Array u8) -> ?StringEncodingError {
  len := bytes.len()
  idx := 0
  loop {
    if idx >= len { break }
    utf8_decode(bytes, idx, len) match {
      case err: StringEncodingError => { return err },
      case result: Utf8DecodeResult => idx = result.next_offset
    }
  }
  nil
}

fn utf8_decode(bytes: Array u8, offset: i32, length: i32) -> Utf8DecodeResult | StringEncodingError {
  if offset >= length {
    return encoding_error("unexpected end of UTF-8 sequence", offset)
  }

  read_byte(bytes, offset) match {
    case nil => encoding_error("unexpected end of UTF-8 sequence", offset),
    case raw: u8 => {
      first := raw
      if (first .& 0x80) == 0 {
        return Utf8DecodeResult {
          codepoint: __able_char_from_codepoint(first),
          next_offset: offset + 1
        }
      }

      if (first .& 0xE0) == 0xC0 {
        return decode_multibyte(bytes, offset, length, (first .& 0x1F) as i32, 1, 0x80, offset + 1, 0x110000)
      }

      if (first .& 0xF0) == 0xE0 {
        return decode_multibyte(bytes, offset, length, (first .& 0x0F) as i32, 2, 0x800, offset + 1, 0x110000)
      }

      if (first .& 0xF8) == 0xF0 {
        return decode_multibyte(bytes, offset, length, (first .& 0x07) as i32, 3, 0x10000, offset + 1, 0x110000)
      }

      encoding_error("invalid UTF-8 leading byte", offset)
    }
  }
}

fn decode_multibyte(
  bytes: Array u8,
  start: i32,
  length: i32,
  initial: i32,
  required_continuations: i32,
  min_value: i32,
  offset: i32,
  max_value: i32
) -> Utf8DecodeResult | StringEncodingError {
  codepoint := initial
  remaining := required_continuations

  loop {
    if remaining <= 0 { break }
    if offset >= length {
      return encoding_error("unexpected end of UTF-8 sequence", offset)
    }

    read_byte(bytes, offset) match {
      case nil => { return encoding_error("unexpected end of UTF-8 sequence", offset) },
      case raw: u8 => {
        value := raw
        if (value .& 0xC0) != 0x80 {
          return encoding_error("invalid UTF-8 continuation byte", offset)
        }
        codepoint = (codepoint .<< 6) .| (value .& 0x3F)
      }
    }

    offset = offset + 1
    remaining = remaining - 1
  }

  if codepoint < min_value {
    return encoding_error("overlong UTF-8 encoding detected", start)
  }

  if codepoint >= 0xD800 && codepoint <= 0xDFFF {
    return encoding_error("UTF-8 sequence encodes surrogate half", start)
  }

  if codepoint >= max_value {
    return encoding_error("codepoint exceeds Unicode range", start)
  }

  Utf8DecodeResult {
    codepoint: __able_char_from_codepoint(codepoint as i32),
    next_offset: offset
  }
}

fn read_byte(bytes: Array u8, idx: i32) -> ?u8 {
  bytes.get(idx)
}

fn slice_bytes(bytes: Array u8, start: i32, end: i32) -> Array u8 {
  length := end - start
  if length <= 0 {
    return Array.with_capacity(0)
  }

  result: Array u8 := Array.with_capacity(length)
  idx := start
  loop {
    if idx >= end { break }
    bytes.get(idx) match {
      case nil => { break },
      case value: u8 => result.push(value)
    }
    idx = idx + 1
  }
  result
}

fn char_to_utf8(value: char) -> Array u8 {
  bytes := Array.with_capacity(4)
  code := __able_char_to_codepoint(value)
  if code <= 0x7F {
    bytes.push(code as u8)
  } else {
    if code <= 0x7FF {
      bytes.push(((code .>> 6) .| 0xC0) as u8)
      bytes.push(((code .& 0x3F) .| 0x80) as u8)
    } else {
      if code <= 0xFFFF {
        bytes.push(((code .>> 12) .| 0xE0) as u8)
        bytes.push((((code .>> 6) .& 0x3F) .| 0x80) as u8)
        bytes.push(((code .& 0x3F) .| 0x80) as u8)
      } else {
        bytes.push(((code .>> 18) .| 0xF0) as u8)
        bytes.push((((code .>> 12) .& 0x3F) .| 0x80) as u8)
        bytes.push((((code .>> 6) .& 0x3F) .| 0x80) as u8)
        bytes.push(((code .& 0x3F) .| 0x80) as u8)
      }
    }
  }
  bytes
}

fn encoding_error(message: String, offset: ?i32) -> StringEncodingError {
  StringEncodingError { message, offset }
}

fn count_chars(bytes: Array u8, length: i32) -> i32 {
  idx := 0
  count := 0
  loop {
    if idx >= length { break }
    utf8_decode(bytes, idx, length) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        idx = result.next_offset
        count = count + 1
      }
    }
  }
  count
}

fn count_graphemes(bytes: Array u8, length: i32) -> i32 {
  idx := 0
  count := 0
  loop {
    if idx >= length { break }
    utf8_decode(bytes, idx, length) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        idx = result.next_offset
        count = count + 1
      }
    }
  }
  count
}

fn codepoint_offset(bytes: Array u8, length: i32, target: i32) -> Result i32 {
  if target == 0 { return 0 }
  idx := 0
  offset := 0
  loop {
    if idx >= target { break }
    utf8_decode(bytes, offset, length) match {
      case err: StringEncodingError => { return err },
      case result: Utf8DecodeResult => {
        offset = result.next_offset
        idx = idx + 1
      }
    }
  }
  offset
}
