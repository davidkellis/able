package deque_tests

import able.collections.deque.{Deque}
import able.core.iteration.{IteratorEnd}

fn assert(condition: bool, message: String) -> void {
  if condition { return }
  raise message
}

fn expect_i32(value: ?i32, expected: i32, message: String) -> void {
  value match {
    case actual: i32 => assert(actual == expected, message),
    case nil => { raise message }
  }
}

fn check_push_and_pop() -> void {
  deque := Deque.new()
  assert(deque.is_empty(), "new deque should be empty")

  deque.push_back(2)
  deque.push_front(1)
  deque.push_back(3)
  assert(deque.len() == 3, "push_front/push_back should grow the deque")

  expect_i32(deque.front(), 1, "front should peek the head without removal")
  expect_i32(deque.back(), 3, "back should peek the tail without removal")

  expect_i32(deque.pop_front(), 1, "pop_front should remove from the head")
  expect_i32(deque.pop_back(), 3, "pop_back should remove from the tail")
  expect_i32(deque.pop_back(), 2, "pop_back should return the remaining element")

  deque.pop_front() match {
    case nil => {},
    case _ => { raise "pop_front on empty deque should return nil" }
  }
  assert(deque.is_empty(), "all pops should empty the deque")
}

fn check_iteration_and_growth() -> void {
  deque := Deque.new()
  i := 0
  loop {
    if i >= 12 { break }
    deque.push_back(i)
    i = i + 1
  }
  assert(deque.len() == 12, "deque should grow beyond its initial capacity")

  iter := deque.iterator()
  sum := 0
  count := 0
  loop {
    iter.next() match {
      case value: i32 => {
        sum = sum + value
        count = count + 1
      },
      case IteratorEnd {} => { break }
    }
  }
  assert(count == 12, "iterator should traverse every element once")
  assert(sum == 66, "iterator should yield elements in insertion order")

  for_sum := 0
  for value in deque {
    for_sum = for_sum + value
  }
  assert(for_sum == sum, "Enumerable.each should power for-in loops")
}

fn main() -> void {
  check_push_and_pop()
  check_iteration_and_growth()
}

main()
