package rational_specs

import able.numbers.rational.{Rational}
import able.core.interfaces.{Less, Greater}
import able.spec.*

describe("Rational") { suite =>
  suite.module_path("numbers/rational")

  suite.it("normalizes and exposes numerators/denominators") { _ctx =>
    value := Rational.new(6, -8)
    expect(value.numerator()).to(eq(-3))
    expect(value.denominator()).to(eq(4))

    zero := Rational.new(0, 5)
    expect(zero.numerator()).to(eq(0))
    expect(zero.denominator()).to(eq(1))

    expect(fn() { Rational.new(1, 0) }).to(raise_error())
  }

  suite.it("performs arithmetic") { _ctx =>
    half := Rational.new(1, 2)
    third := Rational.new(1, 3)

    sum := half.add(third)
    expect(sum.to_string()).to(eq("5/6"))

    diff := half.sub(third)
    expect(diff.to_string()).to(eq("1/6"))

    product := half.mul(third)
    expect(product.to_string()).to(eq("1/6"))

    quotient := half.div(third)
    expect(quotient.to_string()).to(eq("3/2"))

    expect(fn() { half.div(Rational.new(0, 1)) }).to(raise_error())
  }

  suite.it("supports reciprocity, abs, and comparisons") { _ctx =>
    value := Rational.new(-3, 4)
    expect(value.abs().to_string()).to(eq("3/4"))
    expect(value.reciprocal().to_string()).to(eq("-4/3"))

    other := Rational.new(2, 3)
    expect(value.compare(other)).to(eq(Less))
    expect(other.compare(value)).to(eq(Greater))
    expect(other.min(value)).to(eq(value))
    expect(other.max(value)).to(eq(other))

    clamped := value.clamp(Rational.new(-1, 1), Rational.new(1, 2))
    expect(clamped).to(eq(value))
    expect(fn() { value.clamp(Rational.new(2, 1), Rational.new(1, 2)) }).to(raise_error())
  }

  suite.it("implements fractional helpers") { _ctx =>
    value := Rational.new(7, 3)
    expect(value.floor()).to(eq(Rational.new(2, 1)))
    expect(value.ceil()).to(eq(Rational.new(3, 1)))
    expect(value.fract()).to(eq(Rational.new(1, 3)))
    expect(value.round()).to(eq(Rational.new(2, 1)))

    negative := Rational.new(-7, 3)
    expect(negative.floor()).to(eq(Rational.new(-3, 1)))
    expect(negative.ceil()).to(eq(Rational.new(-2, 1)))
    expect(negative.round()).to(eq(Rational.new(-2, 1)))
  }

  suite.it("converts to native numeric types when integral") { _ctx =>
    integer := Rational.new(12, 4)
    expect(integer.to_i32()).to(eq(3))
    expect(integer.to_i64()).to(eq(3))
    expect(integer.to_u32()).to(eq(3_u32))
    expect(integer.to_u64()).to(eq(3_u64))
    expect(integer.to_f64()).to(be_within(1e-12, 3.0))

    expect(fn() { Rational.new(1, 2).to_i32() }).to(raise_error())
    expect(fn() { Rational.new(-1, 2).to_u32() }).to(raise_error())
  }

  suite.it("round-trips through display helpers") { _ctx =>
    expect(Rational.new(3, 5).to_string()).to(eq("3/5"))
    expect(`${Rational.new(-2, 1)}`).to(eq("-2"))
    expect(`${Rational.new(2, 3)}`).to(eq("2/3"))
  }
}
