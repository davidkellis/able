package exec_07_07_overload_resolution_runtime

## Semantics: runtime overload resolution picks the best match, nullable tails can be
## omitted (treated as nil), and ambiguous matches raise a diagnostic.

type TextOrNum = String | i32
type TextOrFlag = String | bool

fn pick(value: i32) -> String { `int ${value}` }
fn pick(value: String) -> String { `str ${value}` }
fn pick(value: bool) -> String {
  if value { "bool true" } else { "bool false" }
}

fn annotate(value: i32, note: ?String) -> String {
  note match {
    case nil => `note ${value} <nil>`,
    case _ => `note ${value} ${note}`
  }
}

fn collide(value: TextOrNum) -> String { "num" }
fn collide(value: TextOrFlag) -> String { "flag" }

fn main() -> void {
  print(pick(7))
  print(pick("ok"))
  print(pick(true))

  print(annotate(4))
  print(annotate(4, "hi"))

  collide("boom")
}
