package able.collections

interface Iterator T for I {
  fn next(I) -> Option T
}

fn Iterator[T](generate: Generator T -> Unit) -> Iterator T {
  gen = Generator()
  spawn { generate(gen) }
  gen
}

// It would be sufficient to define either #each or #iterator in isolation
impl Iterable T for Iterator T {
  fn each(it: Iterator T, visit: T -> Unit) {
    // this is effectively what for loops will translate into
    next = it.next
    while next.defined? {
      visit(next.value)
      next = it.next
    }
  }
  fn iterator(it: Iterator T) -> Iterator T => it
}