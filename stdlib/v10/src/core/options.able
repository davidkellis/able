package core

import able.core.interfaces.{Error}

## Canonical Option/Result unions used throughout the spec.
union Option T = nil | T
union Result T = Error | T

## Helpers for working with Option/Result.
methods Option T {
  fn is_some(self: Self) -> bool {
    match self {
      case _: T => true,
      case nil => false
    }
  }

  fn is_none(self: Self) -> bool { !self.is_some() }

  fn unwrap(self: Self) -> T {
    match self {
      case value: T => value,
      case nil => raise OptionUnwrapError {}
    }
  }

  fn unwrap_or(self: Self, default: T) -> T {
    match self {
      case value: T => value,
      case nil => default
    }
  }

  fn map U (self: Self, f: T -> U) -> Option U {
    match self {
      case value: T => f(value),
      case nil => nil
    }
  }

  fn and_then U (self: Self, f: T -> Option U) -> Option U {
    match self {
      case value: T => f(value),
      case nil => nil
    }
  }

  fn or_else(self: Self, alt: () -> Option T) -> Option T {
    match self {
      case _: T => self,
      case nil => alt()
    }
  }

  fn ok_or(self: Self, err: Error) -> Result T {
    match self {
      case value: T => value,
      case nil => err
    }
  }

  fn ok_or_else(self: Self, f: () -> Error) -> Result T {
    match self {
      case value: T => value,
      case nil => f()
    }
  }
}

methods Result T {
  fn is_ok(self: Self) -> bool {
    match self {
      case _: T => true,
      case _: Error => false
    }
  }

  fn is_err(self: Self) -> bool { !self.is_ok() }

  fn unwrap(self: Self) -> T {
    match self {
      case value: T => value,
      case err: Error => raise ResultUnwrapError { cause: err }
    }
  }

  fn unwrap_or(self: Self, default: T) -> T {
    match self {
      case value: T => value,
      case _: Error => default
    }
  }

  fn unwrap_or_else(self: Self, alt: () -> T) -> T {
    match self {
      case value: T => value,
      case _: Error => alt()
    }
  }

  fn map U (self: Self, f: T -> U) -> Result U {
    match self {
      case value: T => f(value),
      case err: Error => err
    }
  }

  fn map_err E (self: Self, f: Error -> Error) -> Result T {
    match self {
      case value: T => value,
      case err: Error => f(err)
    }
  }

  fn and_then U (self: Self, f: T -> Result U) -> Result U {
    match self {
      case value: T => f(value),
      case err: Error => err
    }
  }

  fn or_else(self: Self, alt: () -> Result T) -> Result T {
    match self {
      case value: T => value,
      case _: Error => alt()
    }
  }

  fn ok(self: Self) -> Option T {
    match self {
      case value: T => value,
      case _: Error => nil
    }
  }

  fn err(self: Self) -> Option Error {
    match self {
      case value: T => nil,
      case err: Error => err
    }
  }
}

struct OptionUnwrapError;

impl Error for OptionUnwrapError {
  fn message(self: Self) -> string { "called Option.unwrap() on nil" }
  fn cause(self: Self) -> ?Error { nil }
}

struct ResultUnwrapError { cause: Error }

impl Error for ResultUnwrapError {
  fn message(self: Self) -> string { "called Result.unwrap() on Error" }
  fn cause(self: Self) -> ?Error { self.cause }
