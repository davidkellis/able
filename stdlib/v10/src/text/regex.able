package text

import able.collections.array{Array}
import able.core.interfaces{Error}
import able.core.options{Result}

struct RegexOptions {
  case_insensitive: bool,
  multiline: bool,
  dot_matches_newline: bool,
  unicode: bool,
  anchored: bool,
  unicode_case: bool,
  grapheme_mode: bool
}

methods RegexOptions {
  fn default() -> RegexOptions {
    RegexOptions {
      case_insensitive: false,
      multiline: false,
      dot_matches_newline: false,
      unicode: true,
      anchored: false,
      unicode_case: false,
      grapheme_mode: false
    }
  }
}

struct Regex {
  pattern: String,
  options: RegexOptions
}

struct RegexUnsupportedError {
  feature: string,
  message: string
}

impl Error for RegexUnsupportedError {
  fn message(self: Self) -> string { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

fn unsupported(feature: string) -> RegexUnsupportedError {
  RegexUnsupportedError {
    feature,
    message: `regex ${feature} is not implemented yet`
  }
}

methods Regex {
  fn compile(pattern: String) -> Result Regex {
    Regex.compile_with_options(pattern, RegexOptions.default())
  }

  fn compile_with_options(pattern: String, options: RegexOptions) -> Result Regex {
    Regex { pattern, options }
  }

  fn is_match(self: Self, haystack: String) -> Result bool {
    unsupported("is_match")
  }

  fn match(self: Self, haystack: String) -> Result ?RegexMatch {
    unsupported("match")
  }

  fn replace(self: Self, haystack: String, replacement: RegexReplacement) -> Result String {
    unsupported("replace")
  }

  fn split(self: Self, haystack: String, limit: ?i32) -> Result RegexSplit {
    unsupported("split")
  }
}

struct RegexMatch {
  matched: String,
  span: RegexSpan,
  captures: RegexCaptures
}

struct RegexSpan {
  start: i32,
  end: i32
}

struct RegexCapture {
  name: ?string,
  value: ?String,
  span: ?RegexSpan
}

struct RegexCaptures {
  ordered: Array RegexCapture,
  named: Array RegexCapture
}

union RegexReplacement =
  RegexReplacementLiteral String |
  RegexReplacementFunction (RegexMatch -> String)

struct RegexSplit {
  segments: Array String
}

fn regex_is_match(pattern: string, haystack: string) -> Result bool {
  match String::from_builtin(pattern) {
    case err: Error => err,
    case pattern_string: String => match String::from_builtin(haystack) {
      case err: Error => err,
      case haystack_string: String => match Regex.compile(pattern_string) {
        case compiled: Regex => compiled.is_match(haystack_string),
        case err: Error => err
      }
    }
  }
}
