package collections

import able.core.iteration.{Iterable, Iterator}
import able.core.interfaces.{Hash, Eq, Default, Clone}
import able.collections.hash_map.{HashMap}
import able.collections.set.{Set}
import able.collections.enumerable.{Enumerable}

struct HashSet T where T: Hash + Eq T + Clone {
  map: HashMap T bool
}

methods HashSet T where T: Hash + Eq T + Clone {
  fn new() -> HashSet T {
    HashSet { map: HashMap.new() }
  }

  fn with_capacity(capacity: i32) -> HashSet T {
    HashSet { map: HashMap.with_capacity(capacity) }
  }

  fn add(mut self: Self, value: T) -> bool {
    existed := self.map.contains(value.clone())
    self.map.set(value, true)
    !existed
  }

  fn remove(mut self: Self, value: T) -> bool {
    match self.map.remove(value) {
      case nil => false,
      case _: bool => true
    }
  }

  fn contains(self: Self, value: T) -> bool {
    self.map.contains(value)
  }

  fn size(self: Self) -> i32 { self.map.size() }

  fn clear(mut self: Self) -> void { self.map.clear() }

  fn is_empty(self: Self) -> bool { self.map.size() == 0 }
}

impl Default for HashSet T where T: Hash + Eq T + Clone {
  fn default() -> HashSet T { HashSet.new() }
}

impl Clone for HashSet T where T: Hash + Eq T + Clone {
  fn clone(self: Self) -> HashSet T {
    HashSet { map: self.map.clone() }
  }
}

impl Set T for HashSet T where T: Hash + Eq T + Clone {
  fn add(mut self: Self, value: T) -> bool {
    existed := self.map.contains(value.clone())
    self.map.set(value, true)
    !existed
  }

  fn remove(mut self: Self, value: T) -> bool {
    match self.map.remove(value) {
      case nil => false,
      case _: bool => true
    }
  }

  fn contains(self: Self, value: T) -> bool { self.map.contains(value) }
  fn size(self: Self) -> i32 { self.map.size() }
  fn clear(mut self: Self) -> void { self.map.clear() }
  fn is_empty(self: Self) -> bool { self.map.size() == 0 }
}

impl Iterable T for HashSet T where T: Hash + Eq T + Clone {
  fn iterator(self: Self) -> (Iterator T) {
    backing := self.map
    Iterator { gen =>
      backing.for_each(fn(key: T, _value: bool) {
        gen.yield(key)
      })
    }
  }
}

impl Enumerable T for HashSet T where T: Hash + Eq T + Clone {
  fn each(self: Self, visit: T -> void) -> void {
    self.map.for_each(fn(key: T, _value: bool) {
      visit(key.clone())
    })
  }
}
