package collections

import able.collections.array.{Array}

interface Enumerable T for E {
  fn each(self: Self, visit: T -> void) -> void;

  fn map<U>(self: Self, f: T -> U) -> Array U {
    result: Array U := Array.new()
    self.each(fn(value: T) { result.push(f(value)) })
    result
  }

  fn to_array(self: Self) -> Array T {
    result: Array T := Array.new()
    self.each(fn(value: T) { result.push(value) })
    result
  }

  fn count(self: Self) -> i32 {
    total := 0
    self.each(fn(_value: T) { total = total + 1 })
    total
  }

  fn filter(self: Self, predicate: T -> bool) -> Array T {
    result: Array T := Array.new()
    self.each(fn(value: T) {
      if predicate(value) {
        result.push(value)
      }
    })
    result
  }

  fn any(self: Self, predicate: T -> bool) -> bool {
    found := false
    self.each(fn(value: T) {
      if predicate(value) { found = true }
    })
    found
  }

  fn all(self: Self, predicate: T -> bool) -> bool {
    ok := true
    self.each(fn(value: T) {
      if !predicate(value) { ok = false }
    })
    ok
  }

  fn none(self: Self, predicate: T -> bool) -> bool {
    !self.any(predicate)
  }

  fn find(self: Self, predicate: T -> bool) -> ?T {
    result: ?T := nil
    self.each(fn(value: T) {
      match result {
        case nil => {
          if predicate(value) { result = value }
        },
        case _ => {}
      }
    })
    result
  }

  fn reduce<U>(self: Self, initial: U, f: (U, T) -> U) -> U {
    acc := initial
    self.each(fn(value: T) { acc = f(acc, value) })
    acc
  }

  fn fold<U>(self: Self, initial: U, f: (U, T) -> U) -> U {
    self.reduce(initial, f)
  }

  fn first(self: Self) -> ?T {
    result: ?T := nil
    self.each(fn(value: T) {
      match result {
        case nil => result = value,
        case _ => {}
      }
    })
    result
  }

  fn is_empty(self: Self) -> bool {
    self.first() == nil
  }

  fn take(self: Self, count: i32) -> Array T {
    result: Array T := Array.new()
    if count <= 0 { return result }
    remaining := count
    self.each(fn(value: T) {
      if remaining > 0 {
        result.push(value)
        remaining = remaining - 1
      }
    })
    result
  }

  fn drop(self: Self, count: i32) -> Array T {
    result: Array T := Array.new()
    if count <= 0 {
      return self.to_array()
    }
    skipped := 0
    self.each(fn(value: T) {
      if skipped < count {
        skipped = skipped + 1
      } else {
        result.push(value)
      }
    })
    result
  }

  fn zip_with_index(self: Self) -> Array (T, i32) {
    result: Array (T, i32) := Array.new()
    idx := 0
    self.each(fn(value: T) {
      result.push((value, idx))
      idx = idx + 1
    })
    result
  }
}
