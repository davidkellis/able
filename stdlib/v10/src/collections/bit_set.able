package collections

import able.collections.array.{Array}
import able.collections.enumerable.{Enumerable}

const WORD_BITS: i32 = 64

struct BitSet {
  words: Array u64
}

fn word_index(bit: i32) -> i32 {
  bit / WORD_BITS
}

fn bit_mask(bit: i32) -> u64 {
  1u64 << (bit % WORD_BITS)
}

methods BitSet {
  fn new() -> BitSet {
    BitSet { words: Array.new() }
  }

  fn ensure_capacity(mut self: Self, bit: i32) -> void {
    idx := word_index(bit)
    while idx >= self.words.len() {
      self.words.push(0)
    }
  }

  fn set(mut self: Self, bit: i32) -> void {
    if bit < 0 { return }
    self.ensure_capacity(bit)
    idx := word_index(bit)
    value := self.words.get(idx)!
    self.words.write_slot(idx, value | bit_mask(bit))
  }

  fn reset(mut self: Self, bit: i32) -> void {
    if bit < 0 { return }
    idx := word_index(bit)
    if idx >= self.words.len() { return }
    value := self.words.get(idx)!
    self.words.write_slot(idx, value & ~bit_mask(bit))
  }

  fn flip(mut self: Self, bit: i32) -> void {
    if bit < 0 { return }
    self.ensure_capacity(bit)
    idx := word_index(bit)
    value := self.words.get(idx)!
    self.words.write_slot(idx, value ^ bit_mask(bit))
  }

  fn contains(self: Self, bit: i32) -> bool {
    if bit < 0 { return false }
    idx := word_index(bit)
    if idx >= self.words.len() { return false }
    (self.words.get(idx)! & bit_mask(bit)) != 0
  }

  fn clear(mut self: Self) -> void {
    i := 0
    while i < self.words.len() {
      self.words.write_slot(i, 0)
      i = i + 1
    }
  }

  fn each(self: Self, visit: i32 -> void) -> void {
    idx := 0
    while idx < self.words.len() {
      word := self.words.get(idx)!
      if word != 0 {
        bit := 0
        while bit < WORD_BITS {
          global_bit := (idx * WORD_BITS) + bit
          if (word & (1u64 << bit)) != 0 {
            visit(global_bit)
          }
          bit = bit + 1
        }
      }
      idx = idx + 1
    }
  }
}

impl Enumerable i32 for BitSet {
  fn each(self: Self, visit: i32 -> void) -> void {
    self.each(visit)
  }
}
