package collections

import able.collections.array.{Array}
import able.collections.enumerable.{Enumerable}
import able.core.interfaces.{Ord, Clone}

type Comparator T = (T, T) -> i32

struct Heap T where T: Clone {
  data: Array T,
  compare: Comparator T
}

fn default_compare<T>(a: T, b: T) -> i32 where T: Ord T {
  match a.cmp(b) {
    case Less => -1,
    case Greater => 1,
    case Equal => 0
  }
}

methods Heap T where T: Clone + Ord T {
  fn new() -> Heap T {
    Heap { data: Array.new(), compare: default_compare }
  }

  fn with_comparator(compare: Comparator T) -> Heap T {
    Heap { data: Array.new(), compare: compare }
  }

  fn len(self: Self) -> i32 { self.data.len() }

  fn is_empty(self: Self) -> bool { self.data.len() == 0 }

  fn peek(self: Self) -> ?T {
    self.data.get(0)
  }

  fn push(mut self: Self, value: T) -> void {
    self.data.push(value)
    self.bubble_up(self.data.len() - 1)
  }

  fn pop(mut self: Self) -> ?T {
    if self.data.len() == 0 { return nil }
    result := self.data.get(0)
    tail_index := self.data.len() - 1
    last := self.data.get(tail_index)
    self.data.pop()
    if self.data.len() > 0 {
      self.data.write_slot(0, last!)
      self.bubble_down(0)
    }
    result
  }

  fn bubble_up(mut self: Self, mut index: i32) -> void {
    loop {
      if index == 0 { break }
      parent := (index - 1) / 2
      current := self.data.get(index)!
      parent_value := self.data.get(parent)!
      if self.compare(current, parent_value) >= 0 { break }
      self.data.write_slot(index, parent_value)
      self.data.write_slot(parent, current)
      index = parent
    }
  }

  fn bubble_down(mut self: Self, mut index: i32) -> void {
    size := self.data.len()
    loop {
      left := (index * 2) + 1
      right := left + 1
      smallest := index

      if left < size {
        left_value := self.data.get(left)!
        smallest_value := self.data.get(smallest)!
        if self.compare(left_value, smallest_value) < 0 {
          smallest = left
        }
      }

      if right < size {
        right_value := self.data.get(right)!
        smallest_value := self.data.get(smallest)!
        if self.compare(right_value, smallest_value) < 0 {
          smallest = right
        }
      }

      if smallest == index { break }

      index_value := self.data.get(index)!
      smallest_value := self.data.get(smallest)!
      self.data.write_slot(index, smallest_value)
      self.data.write_slot(smallest, index_value)
      index = smallest
    }
  }
}
