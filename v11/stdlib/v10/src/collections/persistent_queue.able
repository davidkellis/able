package collections

import able.collections.list.{List}
import able.collections.enumerable.{Enumerable}

struct PersistentQueue T {
  front: List T,
  back: List T,
  size: i32
}

fn queue_normalize<T>(queue: PersistentQueue T) -> PersistentQueue T {
  if !queue.front.is_empty() {
    return queue
  }
  PersistentQueue {
    front: queue.back.reverse(),
    back: List.empty(),
    size: queue.size
  }
}

methods PersistentQueue T {
  fn empty() -> PersistentQueue T {
    PersistentQueue { front: List.empty(), back: List.empty(), size: 0 }
  }

  fn len(self: Self) -> i32 { self.size }

  fn is_empty(self: Self) -> bool { self.size == 0 }

  fn enqueue(self: Self, value: T) -> PersistentQueue T {
    PersistentQueue {
      front: self.front,
      back: self.back.prepend(value),
      size: self.size + 1
    }
  }

  fn peek(self: Self) -> ?T {
    normalized := queue_normalize(self)
    normalized.front.head()
  }

  fn dequeue(self: Self) -> PersistentQueue T {
    if self.size == 0 { return self }
    normalized := queue_normalize(self)
    new_front := normalized.front.tail()
    PersistentQueue {
      front: new_front,
      back: normalized.back,
      size: self.size - 1
    }
  }

  fn for_each(self: Self, visit: T -> void) -> void {
    normalized := queue_normalize(self)
    normalized.front.each(visit)
    normalized.back.reverse().each(visit)
  }
}

impl Enumerable T for PersistentQueue T {
  fn each(self: Self, visit: T -> void) -> void {
    self.for_each(visit)
  }
}
