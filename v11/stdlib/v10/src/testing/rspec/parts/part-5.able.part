fn suite_prefix_keys(path: Array string) -> Array string {
  let mut keys: Array string = Array.new()
  let mut idx = 0
  loop {
    if idx >= path.len() { break }
    let mut prefix: Array string = Array.new()
    let mut inner = 0
    loop {
      if inner > idx { break }
      match path.get(inner) {
        case nil => {},
        case segment: string => prefix.push(segment)
      }
      inner = inner + 1
    }
    keys.push(build_suite_key(prefix))
    idx = idx + 1
  }
  keys
}

fn contains_string(array: Array string, needle: string) -> bool {
  let mut idx = 0
  loop {
    if idx >= array.len() { break }
    match array.get(idx) {
      case nil => {},
      case value: string => {
        if value == needle { return true }
      }
    }
    idx = idx + 1
  }
  false
}

fn run_hook_sequence(hooks: Array (ExampleContext -> void), ctx: ExampleContext) -> ?Failure {
  let mut idx = 0
  loop {
    if idx >= hooks.len() { break }
    match hooks.get(idx) {
      case nil => {},
      case hook: (ExampleContext -> void) => {
        let mut failure: ?Failure = nil
        let _ = do { hook(ctx) } rescue {
          case assertion: AssertionError => {
            failure = failure_from_assertion(assertion)
            nil
          },
          case err: Error => {
            failure = Failure { message: err.message(), details: nil, location: nil }
            nil
          }
        }
        match failure {
          case nil => {},
          case _ => { return failure }
        }
      }
    }
    idx = idx + 1
  }
  nil
}

fn run_hook_sequence_reverse(hooks: Array (ExampleContext -> void), ctx: ExampleContext) -> ?Failure {
  let mut idx = hooks.len() - 1
  loop {
    if idx < 0 { break }
    match hooks.get(idx) {
      case nil => {},
      case hook: (ExampleContext -> void) => {
        let mut failure: ?Failure = nil
        let _ = do { hook(ctx) } rescue {
          case assertion: AssertionError => {
            failure = failure_from_assertion(assertion)
            nil
          },
          case err: Error => {
            failure = Failure { message: err.message(), details: nil, location: nil }
            nil
          }
        }
        match failure {
          case nil => {},
          case _ => { return failure }
        }
      }
    }
    idx = idx - 1
  }
  nil
}

fn run_before_all_for_suite(key: string, executed: Array string) -> ?Failure {
  match find_suite(key) {
    case nil => nil,
    case suite: SuiteDefinition => {
      if contains_string(executed, key) { return nil }
      let ctx = ExampleContext {}
      let failure = run_hook_sequence(suite.before_all, ctx)
      match failure {
        case nil => {},
        case _ => { return failure }
      }
      nil
    }
  }
}

fn run_after_all_for_suites(keys: Array string, reporter: Reporter) -> void {
  let mut idx = keys.len() - 1
  loop {
    if idx < 0 { break }
    match keys.get(idx) {
      case nil => {},
      case key: string => {
        match find_suite(key) {
          case nil => {},
          case suite: SuiteDefinition => {
            let ctx = ExampleContext {}
            match run_hook_sequence_reverse(suite.after_all, ctx) {
              case nil => {},
              case failure: Failure => reporter.emit(TestEvent.framework_error { message: failure.message })
            }
          }
        }
      }
    }
    idx = idx - 1
  }
}

impl Framework for RspecFramework {
  fn id(self: Self) -> string { FRAMEWORK_ID }

  fn discover(
    self: Self,
    request: DiscoveryRequest,
    register: TestDescriptor -> void
  ) -> void | Failure {
    let mut idx = 0
    loop {
      if idx >= EXAMPLES.len() { break }
      match EXAMPLES.get(idx) {
        case nil => {},
        case example: ExampleDefinition => {
          if !matches_filters(example, request) {
            idx = idx + 1
            continue
          }

          let mut metadata: Array MetadataEntry = Array.new()
          metadata.push(MetadataEntry { key: "suite_path", value: build_suite_key(example.suite_path) })
          if example.module_path != "" {
            metadata.push(MetadataEntry { key: "module_path", value: example.module_path })
          }
          if example.tags.len() > 0 {
            metadata.push(MetadataEntry { key: "tags", value: join_segments(example.tags, ",") })
          }

          register(TestDescriptor {
            framework_id: FRAMEWORK_ID,
            module_path: example.module_path,
            test_id: example.id,
            display_name: example.display_name,
            location: nil,
            tags: clone_string_array(example.tags),
            metadata
          })
        }
      }
      idx = idx + 1
    }
  }

  fn run(
    self: Self,
    plan: TestPlan,
    options: RunOptions,
    reporter: Reporter
  ) -> void | Failure {
    let mut executed_suite_keys: Array string = Array.new()
    let mut idx = 0
    loop {
      if idx >= plan.descriptors.len() { break }
      match plan.descriptors.get(idx) {
        case nil => {},
        case descriptor: TestDescriptor => {
          match find_example(descriptor.test_id) {
            case nil => {
              run_after_all_for_suites(executed_suite_keys, reporter)
              return Failure {
                message: `unknown test id ${descriptor.test_id}`,
                details: nil,
                location: nil
              }
            },
            case example: ExampleDefinition => {
              if tag_list_contains(descriptor.tags, "skip") {
                reporter.emit(TestEvent.case_skipped { descriptor, reason: "skipped" })
                idx = idx + 1
                continue
              } else {
                reporter.emit(TestEvent.case_started { descriptor })

              let prefix_keys = suite_prefix_keys(example.suite_path)
              let mut prefix_idx = 0
              loop {
                if prefix_idx >= prefix_keys.len() { break }
                match prefix_keys.get(prefix_idx) {
                  case nil => {},
                  case key: string => {
                    match run_before_all_for_suite(key, executed_suite_keys) {
                      case nil => {
                        if !contains_string(executed_suite_keys, key) {
                          executed_suite_keys.push(key)
                        }
                      },
                      case failure: Failure => {
                        reporter.emit(TestEvent.case_failed {
                          descriptor,
                          duration_ms: 0,
                          failure
                        })
                        run_after_all_for_suites(executed_suite_keys, reporter)
                        return nil
                      }
                    }
                  }
                }
                prefix_idx = prefix_idx + 1
              }

              let ctx = ExampleContext {}
              let before_failure = run_hook_sequence(example.before_each, ctx)
              let mut failure: ?Failure = before_failure

              if failure == nil {
                let mut body_failure: ?Failure = nil
                let _ = do { example.body(ctx) } rescue {
                  case assertion: AssertionError => {
                    body_failure = failure_from_assertion(assertion)
                    nil
                  },
                  case err: Error => {
                    body_failure = Failure { message: err.message(), details: nil, location: nil }
                    nil
                  }
                }
                match body_failure {
                  case nil => {},
                  case _ => { failure = body_failure }
                }
              }

              let after_failure = run_hook_sequence_reverse(example.after_each, ctx)
              if failure == nil {
                failure = after_failure
              }

                match failure {
                  case nil => reporter.emit(TestEvent.case_passed { descriptor, duration_ms: 0 }),
                  case fail: Failure => reporter.emit(TestEvent.case_failed {
                    descriptor,
                    duration_ms: 0,
                    failure: fail
                  })
                }

                if options.fail_fast {
                  match failure {
                    case nil => {},
                    case _ => {
                      run_after_all_for_suites(executed_suite_keys, reporter)
                      return nil
                    }
                  }
                }
              }
            }
          }
        }
      }
      idx = idx + 1
    }

    run_after_all_for_suites(executed_suite_keys, reporter)
    nil
  }
}

