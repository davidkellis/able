fn push_suite(name: String) -> SuiteBuilder {
  parent_index := SUITE_STACK.len() - 1
  path: Array String := Array.new()
  module_path := ""
  tags: Array String := Array.new()
  before_each: Array (ExampleContext -> void) := Array.new()
  after_each: Array (ExampleContext -> void) := Array.new()
  before_all: Array (ExampleContext -> void) := Array.new()
  after_all: Array (ExampleContext -> void) := Array.new()
  config := SuiteConfig { allow_parallel: false }

  if parent_index >= 0 {
    SUITE_STACK.get(parent_index) match {
      case nil => {},
      case parent: SuiteState => {
        path = clone_string_array(parent.path)
        module_path = parent.module_path
        tags = clone_string_array(parent.tags)
        before_each = clone_hook_array(parent.before_each)
        after_each = clone_hook_array(parent.after_each)
        config = parent.config
      }
    }
  }

  path.push(name)
  if module_path == "" {
    module_path = build_suite_key(path)
  }
  state := SuiteState {
    key: build_suite_key(path),
    path,
    module_path,
    tags,
    before_each,
    after_each,
    before_all,
    after_all,
    config
  }

  SUITE_STACK.push(state);
  return SuiteBuilder { state_index: (SUITE_STACK.len() - 1) as i32 }
}

fn pop_suite() -> void {
  SUITE_STACK.pop() match {
    case nil => {},
    case state: SuiteState => register_suite(state)
  }
}

fn register_suite(state: SuiteState) -> void {
  definition := SuiteDefinition {
    key: state.key,
    path: clone_string_array(state.path),
    before_all: clone_hook_array(state.before_all),
    after_all: clone_hook_array(state.after_all)
  }

  idx := 0
  loop {
    if idx >= SUITES.len() { break }
    SUITES.get(idx) match {
      case nil => {},
      case existing: SuiteDefinition => {
        if existing.key == state.key {
          SUITES.set(idx, definition)
          archive_idx := 0
          loop {
            if archive_idx >= SUITES_ARCHIVE.len() { break }
            SUITES_ARCHIVE.get(archive_idx) match {
              case nil => {},
              case archived: SuiteDefinition => {
                if archived.key == state.key {
                  SUITES_ARCHIVE.set(archive_idx, definition)
                  return
                }
              }
            }
            archive_idx = archive_idx + 1
          }
          SUITES_ARCHIVE.push(definition)
          return
        }
      }
    }
    idx = idx + 1
  }

  SUITES.push(definition)
  archive_idx := 0
  loop {
    if archive_idx >= SUITES_ARCHIVE.len() { break }
    SUITES_ARCHIVE.get(archive_idx) match {
      case nil => {},
      case archived: SuiteDefinition => {
        if archived.key == state.key {
          SUITES_ARCHIVE.set(archive_idx, definition)
          return
        }
      }
    }
    archive_idx = archive_idx + 1
  }
  SUITES_ARCHIVE.push(definition)
}

fn find_suite(key: String) -> ?SuiteDefinition {
  idx := 0
  loop {
    if idx >= SUITES.len() { break }
    SUITES.get(idx) match {
      case nil => {},
      case suite: SuiteDefinition => {
        if suite.key == key { return suite }
      }
    }
    idx = idx + 1
  }
  idx = 0
  loop {
    if idx >= SUITES_ARCHIVE.len() { break }
    SUITES_ARCHIVE.get(idx) match {
      case nil => {},
      case suite: SuiteDefinition => {
        if suite.key == key { return suite }
      }
    }
    idx = idx + 1
  }
  nil
}

fn find_example(id: String) -> ?ExampleDefinition {
  idx := 0
  loop {
    if idx >= EXAMPLES.len() { break }
    EXAMPLES.get(idx) match {
      case nil => {},
      case example: ExampleDefinition => {
        if example.id == id { return example }
      }
    }
    idx = idx + 1
  }
  idx = 0
  loop {
    if idx >= EXAMPLES_ARCHIVE.len() { break }
    EXAMPLES_ARCHIVE.get(idx) match {
      case nil => {},
      case example: ExampleDefinition => {
        if example.id == id { return example }
      }
    }
    idx = idx + 1
  }
  nil
}

fn build_suite_key(path: Array String) -> String {
  join_segments(path, "::")
}

fn build_example_id(path: Array String, name: String) -> String {
  segments := clone_string_array(path)
  segments.push(name)
  join_segments(segments, "::")
}

fn build_example_display(path: Array String, name: String) -> String {
  segments := clone_string_array(path)
  segments.push(name)
  join_segments(segments, " ")
}

fn join_segments(segments: Array String, separator: String) -> String {
  result := ""
  idx := 0
  loop {
    if idx >= segments.len() { break }
    segments.get(idx) match {
      case nil => {},
      case segment: String => {
        if result == "" {
          result = segment
        } else {
          result = `${result}${separator}${segment}`
        }
      }
    }
    idx = idx + 1
  }
  result
}
