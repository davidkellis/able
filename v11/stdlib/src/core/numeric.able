package core.numeric

import able.core.interfaces.{Error}
import able.core.options.{Result}

## Shared result returned by Integral#div_mod implementations.
struct DivModResult {
  quotient: i64,
  remainder: i64
}

## Error raised when a numeric conversion cannot be performed without loss.
struct NumericConversionError {
  message: string
}

impl Error for NumericConversionError {
  fn message(self: Self) -> string { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

methods NumericConversionError {
  fn message(self: Self) -> string { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

## Basic algebraic hierarchy (mirrors the design document terminology).
interface Semigroup for T {
  fn combine(self: Self, other: Self) -> Self;
}

interface Monoid for T {
  fn empty() -> Self;
  fn combine(self: Self, other: Self) -> Self;
}

interface AdditiveMonoid for T {
  fn zero() -> Self;
  fn add(self: Self, other: Self) -> Self;
}

interface AdditiveGroup for T {
  fn zero() -> Self;
  fn add(self: Self, other: Self) -> Self;
  fn negate(self: Self) -> Self;
}

interface MultiplicativeMonoid for T {
  fn one() -> Self;
  fn mul(self: Self, other: Self) -> Self;
}

interface MultiplicativeGroup for T {
  fn one() -> Self;
  fn mul(self: Self, other: Self) -> Self;
  fn reciprocal(self: Self) -> Self;
}

## Core numeric surface shared across integers/floats.
interface Numeric for T {
  fn zero() -> Self;
  fn one() -> Self;
  fn abs(self: Self) -> Self;
  fn sign(self: Self) -> i32;
  fn min(self: Self, other: Self) -> Self;
  fn max(self: Self, other: Self) -> Self;
  fn clamp(self: Self, min_value: Self, max_value: Self) -> Self;
}

interface Signed for T {
  fn is_positive(self: Self) -> bool;
  fn is_negative(self: Self) -> bool;
}

interface Unsigned for T {
  fn leading_zeros(self: Self) -> i32;
  fn trailing_zeros(self: Self) -> i32;
}

interface Integral for T {
  fn div_mod(self: Self, other: Self) -> DivModResult;
  fn bit_length(self: Self) -> i32;
  fn bit_count(self: Self) -> i32;
  fn is_even(self: Self) -> bool;
  fn is_odd(self: Self) -> bool;
}

interface Fractional for T {
  fn floor(self: Self) -> Self;
  fn ceil(self: Self) -> Self;
  fn round(self: Self) -> Self;
  fn reciprocal(self: Self) -> Self;
  fn fract(self: Self) -> Self;
}

interface NumericConversions for T {
  fn to_i32(self: Self) -> Result i32;
  fn to_u32(self: Self) -> Result u32;
  fn to_i64(self: Self) -> Result i64;
  fn to_u64(self: Self) -> Result u64;
  fn to_f64(self: Self) -> Result f64;
}
