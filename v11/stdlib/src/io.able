package io

import able.kernel.{Array, __able_String_from_builtin}
import able.core.interfaces.{Error}
import able.text.string.{String}

prelude go {
import (
  "errors"
  "io"
  "os"
  "strings"
  "syscall"
)

func ioErrorKind(err error) string {
  if err == nil {
    return "Other"
  }
  switch {
  case os.IsPermission(err) || errors.Is(err, os.ErrPermission) || errors.Is(err, syscall.EACCES) || errors.Is(err, syscall.EPERM) || strings.Contains(strings.ToLower(err.Error()), "permission denied"):
    return "PermissionDenied"
  case errors.Is(err, os.ErrNotExist):
    return "NotFound"
  case errors.Is(err, os.ErrExist):
    return "AlreadyExists"
  case errors.Is(err, os.ErrInvalid):
    return "InvalidInput"
  case errors.Is(err, os.ErrClosed):
    return "Closed"
  case errors.Is(err, syscall.EPIPE):
    return "BrokenPipe"
  case errors.Is(err, io.EOF):
    return "EOF"
  case os.IsTimeout(err):
    return "TimedOut"
  default:
    return "Other"
  }
}

func ioErrorFrom(err error, path *string) map[string]any {
  var pathVal any = nil
  if path != nil {
    pathVal = *path
  }
  return map[string]any{
    "kind": ioErrorKind(err),
    "message": err.Error(),
    "path": pathVal,
  }
}
}

prelude typescript {
import * as fs from "node:fs";
import process from "node:process";

function ioErrorKind(err) {
  const code = err && err.code ? String(err.code) : "";
  switch (code) {
    case "ENOENT": return "NotFound";
    case "EACCES": return "PermissionDenied";
    case "EPERM": return "PermissionDenied";
    case "EEXIST": return "AlreadyExists";
    case "EINVAL": return "InvalidInput";
    case "ETIMEDOUT": return "TimedOut";
    case "EPIPE": return "BrokenPipe";
    case "EBADF": return "Closed";
    case "ENOTTY": return "Unsupported";
    default: return "Other";
  }
}

function ioErrorFrom(err, path) {
  return {
    kind: ioErrorKind(err),
    message: err && err.message ? String(err.message) : String(err),
    path: path ?? null,
  };
}

function ioHandleFd(handle) {
  if (handle && typeof handle.fd === "number") {
    return handle.fd;
  }
  return null;
}

function ioHandleStream(handle) {
  if (handle && handle.stream) {
    return handle.stream;
  }
  return null;
}

function ioHandleFile(handle) {
  if (handle && handle.handle) {
    return handle.handle;
  }
  return null;
}

function normalizeBuffer(chunk) {
  if (Buffer.isBuffer(chunk)) return chunk;
  if (chunk instanceof Uint8Array) return Buffer.from(chunk);
  if (typeof chunk === "string") return Buffer.from(chunk);
  return Buffer.from([]);
}

const streamStateMap = new WeakMap();

function getStreamState(stream) {
  let state = streamStateMap.get(stream);
  if (!state) {
    state = { queue: [], pending: null, ended: false, error: null, listening: false };
    streamStateMap.set(stream, state);
  }
  if (!state.listening) {
    state.listening = true;
    stream.on("data", (chunk) => {
      const buf = normalizeBuffer(chunk);
      if (buf.length === 0) return;
      state.queue.push(buf);
      drainPending(state);
    });
    stream.once("end", () => {
      state.ended = true;
      drainPending(state);
    });
    stream.once("error", (err) => {
      state.error = err;
      drainPending(state);
    });
    if (typeof stream.resume === "function") {
      stream.resume();
    }
  }
  return state;
}

function takeFromQueue(state, size) {
  if (!state.queue.length) return null;
  const buf = state.queue[0];
  if (buf.length <= size) {
    state.queue.shift();
    return buf;
  }
  state.queue[0] = buf.subarray(size);
  return buf.subarray(0, size);
}

function drainPending(state) {
  if (!state.pending) return;
  const { size, resolve, reject } = state.pending;
  if (state.error) {
    state.pending = null;
    reject(state.error);
    return;
  }
  const chunk = takeFromQueue(state, size);
  if (chunk) {
    state.pending = null;
    resolve(chunk);
    return;
  }
  if (state.ended) {
    state.pending = null;
    resolve(null);
  }
}

function readStreamChunk(stream, size) {
  if (size <= 0) return Promise.resolve(Buffer.alloc(0));
  const state = getStreamState(stream);
  if (state.error) return Promise.reject(state.error);
  const chunk = takeFromQueue(state, size);
  if (chunk) return Promise.resolve(chunk);
  if (state.ended) return Promise.resolve(null);
  return new Promise((resolve, reject) => {
    state.pending = { size, resolve, reject };
  });
}

function writeStreamChunk(stream, buffer) {
  if (!buffer || buffer.length === 0) return Promise.resolve(0);
  return new Promise((resolve, reject) => {
    let settled = false;
    const finish = (err) => {
      if (settled) return;
      settled = true;
      if (err) reject(err); else resolve(buffer.length);
    };
    const ok = stream.write(buffer, finish);
    if (stream && stream.isTTY) {
      if (typeof queueMicrotask === "function") {
        queueMicrotask(() => finish(null));
      } else {
        setTimeout(() => finish(null), 0);
      }
      return;
    }
    if (!ok) {
      stream.once("drain", () => finish(null));
    }
  });
}

function flushStream(stream) {
  if (!stream || !stream.writableNeedDrain) return Promise.resolve(null);
  return new Promise((resolve, reject) => {
    stream.once("drain", () => resolve(null));
    stream.once("error", reject);
  });
}
}

struct NotFound {}
struct PermissionDenied {}
struct AlreadyExists {}
struct InvalidInput {}
struct TimedOut {}
struct BrokenPipe {}
struct Closed {}
struct EOF {}
struct Unsupported {}
struct Other {}

union IOErrorKind =
  NotFound |
  PermissionDenied |
  AlreadyExists |
  InvalidInput |
  TimedOut |
  BrokenPipe |
  Closed |
  EOF |
  Unsupported |
  Other

struct IOError {
  kind: IOErrorKind,
  message: String,
  path: ?String
}

impl Error for IOError {
  fn message(self: Self) -> String { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

fn unwrap<T>(value: IOError | T) -> T {
  value match {
    case err: IOError => { raise err },
    case ok: T => ok
  }
}

fn unwrap_void(value: IOError | void) -> void {
  value match {
    case err: IOError => { raise err },
    case _ => {}
  }
}

fn string_to_bytes(value: String) -> Array u8 {
  __able_String_from_builtin(value)
}

fn bytes_to_string(bytes: Array u8) -> String {
  String.from_bytes(bytes) match {
    case err: Error => { raise err },
    case text: String => {
      text.to_builtin() match {
        case err: Error => { raise err },
        case builtin: String => builtin
      }
    }
  }
}

extern typescript fn io_stdin() -> IoHandle { return { fd: process.stdin.fd, stream: process.stdin }; }
extern go fn io_stdin() -> IoHandle { return os.Stdin }
extern typescript fn io_stdout() -> IoHandle { return { fd: process.stdout.fd, stream: process.stdout }; }
extern go fn io_stdout() -> IoHandle { return os.Stdout }
extern typescript fn io_stderr() -> IoHandle { return { fd: process.stderr.fd, stream: process.stderr }; }
extern go fn io_stderr() -> IoHandle { return os.Stderr }

extern typescript fn io_read(handle: IoHandle, max_bytes: i32) -> IOError | ?Array u8 {
  return (async () => {
    try {
      const size = Math.max(0, Math.trunc(max_bytes));
      if (size === 0) return [];
      const stream = ioHandleStream(handle);
      if (stream) {
        const chunk = await readStreamChunk(stream, size);
        if (chunk === null) return null;
        return Array.from(chunk);
      }
      const fd = ioHandleFd(handle);
      if (fd === null) throw new Error("invalid IoHandle");
      const buffer = Buffer.alloc(size);
      const bytesRead = await new Promise((resolve, reject) => {
        fs.read(fd, buffer, 0, size, null, (err, count) => {
          if (err) reject(err); else resolve(count);
        });
      });
      if (bytesRead === 0) return null;
      return Array.from(buffer.subarray(0, bytesRead));
    } catch (err) {
      return ioErrorFrom(err, null);
    }
  })();
}

extern go fn io_read(handle: IoHandle, max_bytes: i32) -> IOError | ?Array u8 {
  file, ok := handle.(*os.File)
  if !ok { return ioErrorFrom(errors.New("invalid IoHandle"), nil) }
  if max_bytes <= 0 { return []byte{} }
  buf := make([]byte, max_bytes)
  n, err := file.Read(buf)
  if err != nil && !errors.Is(err, io.EOF) {
    return ioErrorFrom(err, nil)
  }
  if n == 0 {
    return nil
  }
  return buf[:n]
}

extern typescript fn io_write(handle: IoHandle, bytes: Array u8) -> IOError | i32 {
  return (async () => {
    try {
      const buffer = Buffer.from(bytes ?? []);
      if (buffer.length === 0) return 0;
      const stream = ioHandleStream(handle);
      if (stream) {
        const written = await writeStreamChunk(stream, buffer);
        return Math.trunc(written);
      }
      const fd = ioHandleFd(handle);
      if (fd === null) throw new Error("invalid IoHandle");
      const written = await new Promise((resolve, reject) => {
        fs.write(fd, buffer, 0, buffer.length, null, (err, count) => {
          if (err) reject(err); else resolve(count);
        });
      });
      return Math.trunc(written);
    } catch (err) {
      return ioErrorFrom(err, null);
    }
  })();
}

extern go fn io_write(handle: IoHandle, bytes: Array u8) -> IOError | i32 {
  file, ok := handle.(*os.File)
  if !ok { return ioErrorFrom(errors.New("invalid IoHandle"), nil) }
  if len(bytes) == 0 { return int32(0) }
  n, err := file.Write(bytes)
  if err != nil {
    return ioErrorFrom(err, nil)
  }
  return int32(n)
}

extern typescript fn io_flush(handle: IoHandle) -> IOError | void {
  return (async () => {
    try {
      const stream = ioHandleStream(handle);
      if (stream) {
        await flushStream(stream);
        return null;
      }
      const fd = ioHandleFd(handle);
      if (fd === null) throw new Error("invalid IoHandle");
      await new Promise((resolve, reject) => {
        fs.fsync(fd, (err) => {
          if (err) reject(err); else resolve(null);
        });
      });
      return null;
    } catch (err) {
      return ioErrorFrom(err, null);
    }
  })();
}

extern go fn io_flush(handle: IoHandle) -> IOError | void {
  file, ok := handle.(*os.File)
  if !ok { return ioErrorFrom(errors.New("invalid IoHandle"), nil) }
  if err := file.Sync(); err != nil {
    return ioErrorFrom(err, nil)
  }
  return nil
}

extern typescript fn io_close(handle: IoHandle) -> IOError | void {
  return (async () => {
    try {
      const stream = ioHandleStream(handle);
      if (stream) {
        if (typeof stream.end === "function") {
          stream.end();
        } else if (typeof stream.destroy === "function") {
          stream.destroy();
        }
        return null;
      }
      const fileHandle = ioHandleFile(handle);
      if (fileHandle && typeof fileHandle.close === "function") {
        await fileHandle.close();
        return null;
      }
      const fd = ioHandleFd(handle);
      if (fd === null) throw new Error("invalid IoHandle");
      await new Promise((resolve, reject) => {
        fs.close(fd, (err) => {
          if (err) reject(err); else resolve(null);
        });
      });
      return null;
    } catch (err) {
      return ioErrorFrom(err, null);
    }
  })();
}

extern go fn io_close(handle: IoHandle) -> IOError | void {
  file, ok := handle.(*os.File)
  if !ok { return ioErrorFrom(errors.New("invalid IoHandle"), nil) }
  if err := file.Close(); err != nil {
    return ioErrorFrom(err, nil)
  }
  return nil
}

fn stdin() -> IoHandle { io_stdin() }
fn stdout() -> IoHandle { io_stdout() }
fn stderr() -> IoHandle { io_stderr() }

fn try_read(handle: IoHandle, max_bytes: i32) -> IOError | ?Array u8 {
  io_read(handle, max_bytes)
}

fn read(handle: IoHandle, max_bytes: i32) -> ?Array u8 {
  unwrap(io_read(handle, max_bytes))
}

fn try_write(handle: IoHandle, bytes: Array u8) -> IOError | i32 {
  io_write(handle, bytes)
}

fn write(handle: IoHandle, bytes: Array u8) -> i32 {
  unwrap(io_write(handle, bytes))
}

fn write_all(handle: IoHandle, bytes: Array u8) -> void {
  offset := 0
  total := bytes.len()
  loop {
    if offset >= total { break }
    written := write(handle, slice_bytes_from_offset(bytes, offset))
    if written <= 0 { raise IOError { kind: BrokenPipe {}, message: "io_write returned 0", path: nil } }
    offset = offset + written
  }
}

fn try_flush(handle: IoHandle) -> IOError | void { io_flush(handle) }
fn flush(handle: IoHandle) -> void { unwrap_void(io_flush(handle)) }
fn try_close(handle: IoHandle) -> IOError | void { io_close(handle) }
fn close(handle: IoHandle) -> void { unwrap_void(io_close(handle)) }

fn read_all(handle: IoHandle, chunk_size: ?i32) -> Array u8 {
  size := chunk_size match { case nil => 4096, case n: i32 => if n <= 0 { 4096 } else { n } }
  out := Array.new()
  loop {
    read(handle, size) match {
      case nil => { break },
      case data: Array u8 => {
        for byte in data { out.push(byte) }
      }
    }
  }
  out
}

fn read_line(handle: IoHandle) -> ?String {
  reader := BufferedReader.new(handle, 1)
  reader.read_line()
}

fn write_line(handle: IoHandle, line: String) -> void {
  write_all(handle, string_to_bytes(line))
  write_all(handle, [10_u8])
}

fn gets() -> ?String {
  read_line(stdin())
}

fn puts(line: String) -> void {
  write_line(stdout(), line)
}

struct BufferedReader {
  handle: IoHandle,
  buffer: Array u8,
  offset: i32,
  eof: bool,
  chunk_size: i32
}

methods BufferedReader {
  fn new(handle: IoHandle, chunk_size: ?i32) -> BufferedReader {
    size := chunk_size match { case nil => 4096, case n: i32 => if n <= 0 { 4096 } else { n } }
    BufferedReader { handle, buffer: Array.new(), offset: 0, eof: false, chunk_size: size }
  }

  fn fill(self: Self) -> void {
    if self.eof { return }
    read(self.handle, self.chunk_size) match {
      case nil => {
        self.eof = true
        self.buffer.clear()
        self.offset = 0
      },
      case data: Array u8 => {
        self.buffer = data
        self.offset = 0
      }
    }
  }

  fn read_line(self: Self) -> ?String {
    line := Array.new()
    loop {
      if self.offset < self.buffer.len() {
        byte := self.buffer.read_slot(self.offset)
        self.offset = self.offset + 1
        if byte == 10_u8 { break }
        if byte == 13_u8 {
          if self.offset >= self.buffer.len() {
            self.fill()
          }
          if self.offset < self.buffer.len() {
            next := self.buffer.read_slot(self.offset)
            if next == 10_u8 { self.offset = self.offset + 1 }
          }
          break
        }
        line.push(byte)
        continue
      }
      if self.eof { break }
      self.fill()
      if self.eof && self.buffer.len() == 0 { break }
    }
    if line.len() == 0 && self.eof { return nil }
    bytes_to_string(line)
  }
}

struct BufferedWriter {
  handle: IoHandle,
  buffer: Array u8,
  capacity: i32
}

methods BufferedWriter {
  fn new(handle: IoHandle, capacity: ?i32) -> BufferedWriter {
    size := capacity match { case nil => 4096, case n: i32 => if n <= 0 { 4096 } else { n } }
    BufferedWriter { handle, buffer: Array.new(), capacity: size }
  }

  fn write_bytes(self: Self, bytes: Array u8) -> void {
    for byte in bytes {
      self.buffer.push(byte)
      if self.buffer.len() >= self.capacity {
        self.flush()
      }
    }
  }

  fn write_line(self: Self, line: String) -> void {
    self.write_bytes(string_to_bytes(line))
    self.write_bytes([10_u8])
  }

  fn flush(self: Self) -> void {
    if self.buffer.len() == 0 { return }
    write_all(self.handle, self.buffer)
    self.buffer.clear()
  }
}

fn slice_bytes_from_offset(bytes: Array u8, offset: i32) -> Array u8 {
  out := Array.new()
  idx := offset
  loop {
    if idx >= bytes.len() { break }
    bytes.get(idx) match {
      case nil => { break },
      case value: u8 => out.push(value)
    }
    idx = idx + 1
  }
  out
}
