package bit_set
import able.kernel.{Array}
import able.collections.array
import able.core.iteration.{Iterable, Iterator}

struct BitSet {
  words: Array u64
}

fn word_bits() -> i32 { 64 }

fn word_index(bit: i32) -> i32 {
  bit // word_bits()
}

fn bit_mask(bit: i32) -> u64 {
  1_u64 .<< ((bit % word_bits()) as u64)
}

fn visit_bits(set: BitSet, visit: i32 -> void) -> void {
  bits_per_word := word_bits()
  idx := 0
  while idx < set.words.len() {
    word := set.words.get(idx) match {
      case nil => 0_u64,
      case value: u64 => value
    }
    if word != 0 {
      bit := 0
      while bit < bits_per_word {
        global_bit := (idx * bits_per_word) + bit
        if (word .& (1_u64 .<< (bit as u64))) != 0 {
          visit(global_bit)
        }
        bit = bit + 1
      }
    }
    idx = idx + 1
  }
}

methods BitSet {
  fn new() -> BitSet {
    BitSet { words: Array.new() }
  }

  fn ensure_capacity(self: Self, bit: i32) -> void {
    idx := word_index(bit)
    while idx >= self.words.len() {
      self.words.push(0_u64)
    }
  }

  fn set(self: Self, bit: i32) -> void {
    if bit < 0 { return }
    self.ensure_capacity(bit)
    idx := word_index(bit)
    value := self.words.get(idx)!
    self.words.write_slot(idx, value .| bit_mask(bit))
  }

  fn reset(self: Self, bit: i32) -> void {
    if bit < 0 { return }
    idx := word_index(bit)
    if idx >= self.words.len() { return }
    value := self.words.get(idx)!
    self.words.write_slot(idx, value .& .~bit_mask(bit))
  }

  fn flip(self: Self, bit: i32) -> void {
    if bit < 0 { return }
    if self.contains(bit) {
      self.reset(bit)
    } else {
      self.set(bit)
    }
  }

  fn contains(self: Self, bit: i32) -> bool {
    if bit < 0 { return false }
    idx := word_index(bit)
    if idx >= self.words.len() { return false }
    (self.words.get(idx)! .& bit_mask(bit)) != 0
  }

  fn clear(self: Self) -> void {
    i := 0
    while i < self.words.len() {
      self.words.write_slot(i, 0_u64)
      i = i + 1
    }
  }

  fn each(self: Self, visit: i32 -> void) -> void {
    visit_bits(self, visit)
  }
}

impl Iterable i32 for BitSet {
  fn iterator(self: Self) -> (Iterator i32) {
    Iterator { gen =>
      idx := 0
      bits_per_word := word_bits()
      while idx < self.words.len() {
        word := self.words.get(idx)!
        if word != 0 {
          bit := 0
          while bit < bits_per_word {
            global_bit := (idx * bits_per_word) + bit
            if (word .& (1_u64 .<< (bit as u64))) != 0 {
              gen.yield(global_bit)
            }
            bit = bit + 1
          }
        }
        idx = idx + 1
      }
    }
  }
}
