package collections.range

import able.core.iteration.{Iterator, Iterable, Range}

struct IntRange {
  start: i32,
  end: i32,
  inclusive: bool
}

impl Iterable i32 for IntRange {
  fn iterator(self: Self) -> (Iterator i32) {
    Iterator i32 { gen =>
      step := 1
      if self.end < self.start { step = -1 }

      current := self.start
      limit := self.end
      loop {
        if step > 0 {
          if self.inclusive {
            if current > limit { gen.stop(); break }
          } else {
            if current >= limit { gen.stop(); break }
          }
        } else {
          if self.inclusive {
            if current < limit { gen.stop(); break }
          } else {
            if current <= limit { gen.stop(); break }
          }
        }

        gen.yield(current)
        current = current + step
      }
    }
  }
}

struct IntRangeFactory {}

impl Range i32 i32 i32 for IntRangeFactory {
  fn inclusive_range(start: i32, finish: i32) -> Iterable i32 {
    IntRange { start: start, end: finish, inclusive: true }
  }

  fn exclusive_range(start: i32, finish: i32) -> Iterable i32 {
    IntRange { start: start, end: finish, inclusive: false }
  }
}
