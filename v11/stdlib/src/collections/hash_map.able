package hash_map
import able.kernel.{HashMap::KernelHashMap, raw_get, raw_set, raw_remove, raw_contains, raw_size, raw_clear, raw_for_each, raw_clone}
import able.collections.map.{Map}
import able.core.interfaces.{Clone, Default, Hash, Eq, Index, IndexMut}
import able.core.errors.{IndexError}

## Re-export kernel HashMap under the stdlib namespace.
type HashMap K V = KernelHashMap K V
HashMap := KernelHashMap

methods HashMap K V {
  fn get(self: Self, key: K) -> ?V { self.raw_get(key) }
  fn set(self: Self, key: K, value: V) -> void { self.raw_set(key, value) }
  fn remove(self: Self, key: K) -> ?V { self.raw_remove(key) }
  fn contains(self: Self, key: K) -> bool { self.raw_contains(key) }
  fn size(self: Self) -> i32 { self.raw_size() }
  fn is_empty(self: Self) -> bool { self.raw_size() == 0 }
  fn clear(self: Self) -> void { self.raw_clear() }
  fn for_each(self: Self, visit: (K, V) -> void) -> void { self.raw_for_each(visit) }
  fn clone_shallow(self: Self) -> HashMap K V { self.raw_clone() }
}

impl Map K V for HashMap K V where K: Hash + Eq K {
  fn get(self: Self, key: K) -> ?V { self.raw_get(key) }
  fn set(self: Self, key: K, value: V) -> void { self.raw_set(key, value) }
  fn remove(self: Self, key: K) -> ?V { self.raw_remove(key) }
  fn contains(self: Self, key: K) -> bool { self.raw_contains(key) }
  fn size(self: Self) -> i32 { self.raw_size() }
}

impl Index K V for HashMap K V where K: Hash + Eq K {
  fn get(self: Self, key: K) -> !V {
    self.raw_get(key) match {
      case nil => IndexError { index: -1, length: self.raw_size() },
      case value: V => value
    }
  }
}

impl IndexMut K V for HashMap K V where K: Hash + Eq K {
  fn set(self: Self, key: K, value: V) -> !void {
    self.raw_set(key, value)
  }
}

impl Default for HashMap K V where K: Hash + Eq K {
  fn default() -> HashMap K V { HashMap.new() }
}

impl Clone for HashMap K V where K: Hash + Eq K {
  fn clone(self: Self) -> HashMap K V { self.clone_shallow() }
}
