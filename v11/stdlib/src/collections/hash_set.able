package collections.hash_set

import able.collections.array.{Array}
import able.collections.hash_map.{HashMap}
import able.collections.set.{Set}
import able.collections.enumerable.{Enumerable}
import able.core.interfaces.{Clone, Default, Hash, Eq}
import able.core.iteration.{Iterable, Iterator, IteratorEnd}

struct HashSet T {
  map: HashMap T bool
}

struct HashSetIterator T {
  keys: Array T,
  index: i32
}

fn collect_keys<T>(source: HashMap T bool) -> HashSetIterator T where T: Hash + Eq T {
  keys: Array T := Array.with_capacity(source.size())
  source.for_each({ key, _value => keys.push(key) })
  HashSetIterator { keys: keys, index: 0 }
}

fn visit_keys<T>(source: HashMap T bool, visit: T -> void) -> void where T: Hash + Eq T {
  source.for_each({ key, _value => visit(key) })
}

methods HashSet T where T: Hash + Eq T {
  fn new() -> HashSet T {
    HashSet { map: HashMap.new() }
  }

  fn with_capacity(capacity: i32) -> HashSet T {
    HashSet { map: HashMap.with_capacity(capacity) }
  }

  fn add(self: Self, value: T) -> bool {
    existed := self.map.contains(value)
    self.map.set(value, true)
    !existed
  }

  fn remove(self: Self, value: T) -> bool { self.map.remove(value) != nil }

  fn contains(self: Self, value: T) -> bool { self.map.contains(value) }
  fn size(self: Self) -> i32 { self.map.size() }
  fn clear(self: Self) -> void { self.map.clear() }
  fn is_empty(self: Self) -> bool { self.map.size() == 0 }
}

impl Default for HashSet T where T: Hash + Eq T {
  fn default() -> HashSet T { HashSet.new() }
}

impl Clone for HashSet T where T: Hash + Eq T {
  fn clone(self: Self) -> HashSet T { HashSet { map: self.map.clone() } }
}

impl Set T for HashSet T where T: Hash + Eq T {
  fn add(self: Self, value: T) -> bool {
    existed := self.map.contains(value)
    self.map.set(value, true)
    !existed
  }

  fn remove(self: Self, value: T) -> bool { self.map.remove(value) != nil }

  fn contains(self: Self, value: T) -> bool { self.map.contains(value) }
  fn size(self: Self) -> i32 { self.map.size() }
  fn clear(self: Self) -> void { self.map.clear() }
  fn is_empty(self: Self) -> bool { self.map.size() == 0 }
}

impl Iterable T for HashSet T where T: Hash + Eq T {
  fn iterator(self: Self) -> (Iterator T) {
    collect_keys(self.map)
  }

  fn each(self: Self, visit: T -> void) -> void {
    visit_keys(self.map, visit)
  }
}

impl Enumerable T for HashSet T where T: Hash + Eq T {
  fn each(self: Self, visit: T -> void) -> void {
    visit_keys(self.map, visit)
  }
}

impl Iterator T for HashSetIterator T {
  fn next(self: Self) -> T | IteratorEnd {
    if self.index >= self.keys.len() { return IteratorEnd {} }
    value := self.keys.read_slot(self.index)
    self.index = self.index + 1
    value
  }
}
