package collections.array

import able.core.interfaces.{Default, Clone, Index, IndexMut}
import able.core.iteration.{Iterable, Iterator, IteratorEnd}
import able.core.errors.{IndexError}

extern typescript fn __able_array_new() -> i64 {}
extern typescript fn __able_array_with_capacity(capacity: i32) -> i64 {}
extern typescript fn __able_array_size(handle: i64) -> i64 {}
extern typescript fn __able_array_capacity(handle: i64) -> i64 {}
extern typescript fn __able_array_set_len(handle: i64, length: i32) -> void {}
extern typescript fn __able_array_read(handle: i64, idx: i32) -> _ {}
extern typescript fn __able_array_write(handle: i64, idx: i32, value: _) -> void {}
extern typescript fn __able_array_reserve(handle: i64, capacity: i32) -> i64 {}
extern typescript fn __able_array_clone(handle: i64) -> i64 {}

## Opaque runtime-managed array storing contiguous elements of type T.
struct Array T {
  length: i32,
  capacity: i32,
  storage_handle: i64 ## Runtime handle for the backing buffer.
}

struct ArrayIterator T {
  array: Array T,
  index: i32,
  length: i32,
}

## Constructors and mutation helpers will be provided by the host runtime.
methods Array T {
  fn new() -> Array T {
    handle := __able_array_new()
    arr := Array { length: 0, capacity: 0, storage_handle: handle }
    arr.refresh_metadata()
    arr
  }

  fn with_capacity(capacity: i32) -> Array T {
    handle := __able_array_with_capacity(capacity)
    arr := Array { length: 0, capacity: capacity, storage_handle: handle }
    arr.refresh_metadata()
    arr
  }

  fn size(self: Self) -> u64 {
    self.refresh_metadata()
    __able_array_size(self.storage_handle)
  }

  fn push(self: Self, value: T) -> void {
    self.refresh_metadata()
    __able_array_write(self.storage_handle, self.length, value)
    self.refresh_metadata()
  }

  fn pop(self: Self) -> ?T {
    self.refresh_metadata()
    if self.length <= 0 { return nil }
    idx := self.length - 1
    value := __able_array_read(self.storage_handle, idx)
    __able_array_set_len(self.storage_handle, idx)
    self.refresh_metadata()
    value
  }

  fn clear(self: Self) -> void {
    __able_array_set_len(self.storage_handle, 0)
    self.refresh_metadata()
  }

  fn read_slot(self: Self, idx: i32) -> T {
    __able_array_read(self.storage_handle, idx)
  }

  fn write_slot(self: Self, idx: i32, value: T) -> void {
    __able_array_write(self.storage_handle, idx, value)
  }

  fn len(self: Self) -> i32 {
    self.length = __able_array_size(self.storage_handle)
    self.length
  }

  fn capacity(self: Self) -> i32 {
    self.capacity = __able_array_capacity(self.storage_handle)
    self.capacity
  }
  fn is_empty(self: Self) -> bool { self.len() == 0 }

  fn get(self: Self, idx: i32) -> ?T {
    arr := self
    arr.refresh_metadata()
    count := arr.len()
    if idx < 0 || idx >= count { return nil }
    arr.read_slot(idx)
  }

  fn set(self: Self, idx: i32, value: T) -> !nil {
    arr := self
    arr.refresh_metadata()
    count := arr.len()
    if idx < 0 || idx >= count { return IndexError { index: idx, length: count } }
    arr.write_slot(idx, value)
    nil
  }

  fn first(self: Self) -> ?T {
    self.get(0)
  }

  fn last(self: Self) -> ?T {
    count := self.len()
    if count == 0 { return nil }
    self.get(count - 1)
  }

  fn push_all(self: Self, values: Array T) -> void {
    i := 0
    loop {
      if i >= values.len() { break }
      values.get(i) match {
        case nil => {},
        case value: T => self.push(value)
      }
      i = i + 1
    }
  }

  fn map<U>(self: Self, f: T -> U) -> Array U {
    count := self.len()
    result: Array U := Array.with_capacity(count)
    i := 0
    loop {
      if i >= count { break }
      self.get(i) match {
        case nil => {},
        case item: T => result.push(f(item))
      }
      i = i + 1
    }
    result
  }
}

methods Array T where T: Clone {
  fn filter(self: Self, predicate: T -> bool) -> Array T {
    count := self.len()
    result: Array T := Array.with_capacity(count)
    i := 0
    loop {
      if i >= count { break }
      self.get(i) match {
        case nil => {},
        case item: T => {
          if predicate(item.clone()) {
            result.push(item)
          }
        }
      }
      i = i + 1
    }
    result
  }
}

impl Default for Array T {
  fn default() -> Array T { Array { length: 0, capacity: 0, storage_handle: 0 } }
}

impl Clone for Array T {
  fn clone(self: Self) -> Array T {
    handle := __able_array_clone(self.storage_handle)
    cloned := Array { length: self.length, capacity: self.capacity, storage_handle: handle }
    cloned.refresh_metadata()
    cloned
  }
}

impl Iterable T for Array T {
  fn iterator(self: Self) -> (Iterator T) {
    snapshot := self
    snapshot.refresh_metadata()
    ArrayIterator { array: snapshot, index: 0, length: snapshot.length }
  }
}

impl Iterator T for ArrayIterator T {
  fn next(self: Self) -> T | IteratorEnd {
    if self.index >= self.length { return IteratorEnd {} }
    value := self.array.read_slot(self.index)
    self.index = self.index + 1
    value
  }

  fn close(self: Self) -> void { }
}

impl Index i32 T for Array T {
  fn index(self: Self, idx: i32) -> T | IndexError {
    if idx < 0 || idx >= self.len() { IndexError { index: idx, length: self.len() } } else { self.read_slot(idx) }
  }
}

impl IndexMut i32 T for Array T {
  fn assign(self: Self, idx: i32, value: T) -> void | IndexError {
    if idx < 0 || idx >= self.len() { IndexError { index: idx, length: self.len() } } else { self.write_slot(idx, value) }
  }
}

methods Array T {
  fn refresh_metadata(self: Self) -> void {
    self.length = __able_array_size(self.storage_handle)
    self.capacity = __able_array_capacity(self.storage_handle)
  }
}
