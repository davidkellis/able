package text.string

import able.collections.array.{Array}
import able.core.interfaces.{Clone, Error}
import able.core.iteration.{Iterable, Iterator, IteratorEnd}
import able.core.options.{Result}
import able.core.errors.{RangeError}

extern typescript fn __able_string_from_builtin(value: string) -> Array u8 {}
extern typescript fn __able_string_to_builtin(bytes: Array u8) -> string {}
extern typescript fn __able_char_from_codepoint(value: i32) -> char {}

private struct String {
  bytes: Array u8,
  len_bytes: i32
}

struct Grapheme {
  bytes: Array u8
}

struct StringBuilder {
  buffer: Array u8
}

private struct StringBytesIter {
  string: String,
  offset: i32
}

private struct StringCharsIter {
  string: String,
  offset: i32
}

private struct StringGraphemesIter {
  string: String,
  offset: i32
}

private struct Utf8DecodeResult {
  codepoint: char,
  next_offset: i32
}

struct StringEncodingError {
  message: string,
  offset: ?i32
}

impl Error for StringEncodingError {
  fn message(self: Self) -> string { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

methods String {
  fn empty() -> String {
    String { bytes: Array.with_capacity(0), len_bytes: 0 }
  }

  fn from_bytes_unchecked(bytes: Array u8) -> String {
    String { len_bytes: bytes.len(), bytes }
  }

  fn from_bytes(bytes: Array u8) -> Result String {
    utf8_validate(bytes) match {
      case err: StringEncodingError => err,
      case nil => String.from_bytes_unchecked(bytes)
    }
  }

  fn from_builtin(value: string) -> Result String {
    data := __able_string_from_builtin(value)
    utf8_validate(data) match {
      case err: StringEncodingError => err,
      case nil => String.from_bytes_unchecked(data)
    }
  }

  fn len_bytes(self: Self) -> i32 { self.len_bytes }

  fn len_chars(self: Self) -> i32 {
    count_chars(self.bytes, self.len_bytes)
  }

  fn len_graphemes(self: Self) -> i32 {
    count_graphemes(self.bytes, self.len_bytes)
  }
  fn is_empty(self: Self) -> bool { self.len_bytes == 0 }

  fn bytes(self: Self) -> Array u8 { self.bytes.clone() }

  fn byte_iter(self: Self) -> StringBytesIter {
    StringBytesIter { string: self, offset: 0 }
  }

  fn chars(self: Self) -> StringCharsIter {
    StringCharsIter { string: self, offset: 0 }
  }

  fn graphemes(self: Self) -> StringGraphemesIter {
    StringGraphemesIter { string: self, offset: 0 }
  }

  fn to_builtin(self: Self) -> Result string {
    __able_string_to_builtin(self.bytes.clone())
  }

  fn to_builder(self: Self) -> StringBuilder {
    builder := StringBuilder.with_capacity(self.len_bytes)
    builder.push_bytes(self.bytes.clone())
    builder
  }

  fn substring(self: Self, start: i32, length: ?i32) -> Result String {
    if start < 0 { return RangeError { message: "substring start must be non-negative" } }
    total := self.len_chars()
    if start > total { return RangeError { message: "substring start out of range" } }

    offset := 0
    codepoint_offset(self.bytes, self.len_bytes, start) match {
      case err: Error => { return err },
      case value: i32 => offset = value
    }
    target_end := self.len_bytes
    if length != nil {
      if length < 0 { return RangeError { message: "substring length must be non-negative" } }
      limit := start + length
      if limit > total { return RangeError { message: "substring range out of bounds" } }
      codepoint_offset(self.bytes, self.len_bytes, limit) match {
        case err: Error => { return err },
        case value: i32 => { target_end = value }
      }
    }
    slice := slice_bytes(self.bytes, offset, target_end)
    String.from_bytes(slice)
  }

  fn starts_with(self: Self, prefix: String) -> bool {
    if prefix.len_bytes > self.len_bytes { return false }
    compare_length := prefix.len_bytes
    idx := 0
    loop {
      if idx >= compare_length { break }
      read_byte(prefix.bytes, idx) match {
        case nil => { return false },
        case pb: u8 => {
          read_byte(self.bytes, idx) match {
            case nil => { return false },
            case sb: u8 => { if pb != sb { return false } }
          }
        }
      }
      idx = idx + 1
    }
    true
  }

  fn ends_with(self: Self, suffix: String) -> bool {
    if suffix.len_bytes > self.len_bytes { return false }
    offset := self.len_bytes - suffix.len_bytes
    idx := 0
    loop {
      if idx >= suffix.len_bytes { break }
      read_byte(suffix.bytes, idx) match {
        case nil => { return false },
        case sb: u8 => {
          read_byte(self.bytes, offset + idx) match {
            case nil => { return false },
            case pb: u8 => { if sb != pb { return false } }
          }
        }
      }
      idx = idx + 1
    }
    true
  }

  fn concat(strings: Array String) -> String {
    builder := StringBuilder.new()
    idx := 0
    loop {
      strings.get(idx) match {
        case nil => { break },
        case value: String => builder.push_string(to_builtin_string(value))
      }
      idx = idx + 1
    }
    builder.finish() match {
      case result: string => to_string_value(result),
      case err: Error => { raise err }
    }
  }

  fn join(strings: Array String, separator: String) -> String {
    builder := StringBuilder.new()
    idx := 0
    loop {
      strings.get(idx) match {
        case nil => { break },
        case value: String => {
          if idx > 0 { builder.push_string(to_builtin_string(separator.clone())) }
          builder.push_string(to_builtin_string(value))
        }
      }
      idx = idx + 1
    }
    builder.finish() match {
      case result: string => to_string_value(result),
      case err: Error => { raise err }
    }
  }

  fn split(self: Self, delimiter: String) -> Array String {
    result: Array String := Array.new()
    if delimiter.len_bytes() == 0 {
      for g in self.graphemes() {
        result.push(String.from_bytes_unchecked(g.bytes.clone()))
      }
      return result
    }

    haystack := self.bytes
    needle := delimiter.bytes
    hay_len := self.len_bytes
    needle_len := delimiter.len_bytes

    start := 0
    idx := 0
    loop {
      if idx > hay_len - needle_len { break }
      matched := true
      j := 0
      loop {
        if j >= needle_len { break }
        read_byte(haystack, idx + j) match {
          case nil => { matched = false; break },
          case hb: u8 => {
            read_byte(needle, j) match {
              case nil => { matched = false; break },
              case nb: u8 => {
                if hb != nb { matched = false; break }
              }
            }
          }
        }
        j = j + 1
      }
      if matched {
        segment := slice_bytes(haystack, start, idx)
        String.from_bytes(segment) match {
          case s: String => result.push(s),
          case err: Error => { raise err }
        }
        idx = idx + needle_len
        start = idx
      } else {
        idx = idx + 1
      }
    }

    tail := slice_bytes(haystack, start, hay_len)
    String.from_bytes(tail) match {
      case s: String => result.push(s),
      case err: Error => { raise err }
    }

    result
  }

  fn replace(self: Self, old: String, new: String) -> String {
    haystack := self.bytes
    needle := old.bytes
    replacement := new.bytes
    hay_len := self.len_bytes
    needle_len := old.len_bytes
    if needle_len == 0 { return self.clone() }

    builder := StringBuilder.with_capacity(hay_len)
    idx := 0
    start := 0
    loop {
      if idx > hay_len - needle_len { break }
      matched := true
      j := 0
      loop {
        if j >= needle_len { break }
        read_byte(haystack, idx + j) match {
          case nil => { matched = false; break },
          case hb: u8 => {
            read_byte(needle, j) match {
              case nil => { matched = false; break },
              case nb: u8 => { if hb != nb { matched = false; break } }
            }
          }
        }
        j = j + 1
      }
      if matched {
        prefix := slice_bytes(haystack, start, idx)
        builder.push_bytes(prefix)
        builder.push_bytes(replacement.clone())
        idx = idx + needle_len
        start = idx
      } else {
        idx = idx + 1
      }
    }
    trailing := slice_bytes(haystack, start, hay_len)
    builder.push_bytes(trailing)
    builder.finish() match {
      case s: string => to_string_value(s),
      case err: Error => { raise err }
    }
  }
}

private fn to_string_value(value: string) -> String {
  String.from_builtin(value) match {
    case err: Error => { raise err },
    case s: String => s
  }
}

private fn to_builtin_string(value: String) -> string {
  value.to_builtin() match {
    case err: Error => { raise err },
    case text: string => text
  }
}

private fn to_result_string(value: Result String) -> Result string {
  value match {
    case err: Error => err,
    case s: String => s.to_builtin()
  }
}

private fn to_u64(value: i32) -> u64 {
  if value <= 0 { 0 } else { value }
}

methods string {
  fn len_bytes(self: Self) -> u64 { to_u64(to_string_value(self).len_bytes()) }
  fn len_chars(self: Self) -> u64 { to_u64(to_string_value(self).len_chars()) }
  fn len_graphemes(self: Self) -> u64 { to_u64(to_string_value(self).len_graphemes()) }

  fn substring(self: Self, start: u64, length: ?u64) -> Result string {
    start_idx: i32 = 0
    len_arg: ?i32 := nil
    if start > 2147483647 {
      return RangeError { message: "substring start out of range" }
    }
    start_idx = start

    if length != nil {
      if length > 2147483647 {
        return RangeError { message: "substring length out of range" }
      }
      len_arg = length
    }
    to_result_string(to_string_value(self).substring(start_idx, len_arg))
  }

  fn split(self: Self, delimiter: string) -> Array string {
    haystack := to_string_value(self)
    needle := to_string_value(delimiter)
    segments := haystack.split(needle)
    result: Array string := Array.new()
    idx := 0
    loop {
      segments.get(idx) match {
        case nil => { break },
        case piece: String => result.push(to_builtin_string(piece))
      }
      idx = idx + 1
    }
    result
  }

  fn replace(self: Self, old: string, new: string) -> string {
    hay := to_string_value(self)
    old_value := to_string_value(old)
    new_value := to_string_value(new)
    to_builtin_string(hay.replace(old_value, new_value))
  }

  fn starts_with(self: Self, prefix: string) -> bool {
    to_string_value(self).starts_with(to_string_value(prefix))
  }

  fn ends_with(self: Self, suffix: string) -> bool {
    to_string_value(self).ends_with(to_string_value(suffix))
  }

  fn bytes(self: Self) -> (Iterator u8) { to_string_value(self).byte_iter() }
  fn chars(self: Self) -> (Iterator char) { to_string_value(self).chars() }
  fn graphemes(self: Self) -> (Iterator Grapheme) { to_string_value(self).graphemes() }
}

impl Clone for String {
  fn clone(self: Self) -> String {
    String { bytes: self.bytes.clone(), len_bytes: self.len_bytes }
  }
}

impl Clone for Grapheme {
  fn clone(self: Self) -> Grapheme {
    Grapheme { bytes: self.bytes.clone() }
  }
}

methods Grapheme {
  fn len_bytes(self: Self) -> u64 { to_u64(self.bytes.len()) }
  fn bytes(self: Self) -> Array u8 { self.bytes.clone() }
  fn as_string(self: Self) -> string { to_builtin_string(String.from_bytes_unchecked(self.bytes.clone())) }
}

methods StringBuilder {
  fn new() -> StringBuilder { StringBuilder { buffer: Array.with_capacity(0) } }

  fn with_capacity(capacity: i32) -> StringBuilder {
    StringBuilder { buffer: Array.with_capacity(capacity) }
  }

  fn clear(self: Self) -> void {
    self.buffer.clear()
  }

  fn push_char(self: Self, value: char) -> void {
    bytes := char_to_utf8(value)
    self.buffer.push_all(bytes)
  }

  fn push_byte(self: Self, value: u8) -> void {
    self.buffer.push(value)
  }

  fn push_bytes(self: Self, bytes: Array u8) -> void {
    self.buffer.push_all(bytes)
  }

  fn push_string(self: Self, value: string) -> void {
    self.buffer.push_all(to_string_value(value).bytes())
  }

  fn append_builder(self: Self, other: StringBuilder) -> void {
    self.buffer.push_all(other.buffer)
  }

  fn len_bytes(self: Self) -> u64 { to_u64(self.buffer.len()) }

  fn finish(self: Self) -> Result string {
    to_result_string(String.from_bytes(self.buffer))
  }
}

impl Iterable u8 for String {
  fn iterator(self: Self) -> (Iterator u8) { self.byte_iter() }
}

impl Iterator u8 for StringBytesIter {
  fn next(self: Self) -> u8 | IteratorEnd {
    if self.offset >= self.string.len_bytes {
      return IteratorEnd {}
    }

    read_byte(self.string.bytes, self.offset) match {
      case nil => IteratorEnd {},
      case value: u8 => {
        self.offset = self.offset + 1
        value
      }
    }
  }

  fn size(self: Self) -> u64 {
    remaining := self.string.len_bytes - self.offset
    if remaining <= 0 { 0 } else { remaining }
  }
}

impl Iterable char for String {
  fn iterator(self: Self) -> (Iterator char) { self.chars() }
}

impl Iterable u8 for StringBytesIter {
  fn iterator(self: Self) -> (Iterator u8) { self }
}

impl Iterator char for StringCharsIter {
  fn next(self: Self) -> char | IteratorEnd {
    if self.offset >= self.string.len_bytes {
      return IteratorEnd {}
    }

    utf8_decode(self.string.bytes, self.offset, self.string.len_bytes) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        self.offset = result.next_offset
        result.codepoint
      }
    }
  }

  fn size(self: Self) -> u64 {
    count := 0
    idx := self.offset
    loop {
      if idx >= self.string.len_bytes { break }
      utf8_decode(self.string.bytes, idx, self.string.len_bytes) match {
        case err: StringEncodingError => { raise err },
        case result: Utf8DecodeResult => {
          idx = result.next_offset
          count = count + 1
        }
      }
    }
    count
  }
}

impl Iterable Grapheme for String {
  fn iterator(self: Self) -> (Iterator Grapheme) { self.graphemes() }
}

impl Iterable char for StringCharsIter {
  fn iterator(self: Self) -> (Iterator char) { self }
}

impl Iterator Grapheme for StringGraphemesIter {
  fn next(self: Self) -> Grapheme | IteratorEnd {
    if self.offset >= self.string.len_bytes {
      return IteratorEnd {}
    }

    start := self.offset

    utf8_decode(self.string.bytes, self.offset, self.string.len_bytes) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        end := result.next_offset
        ## TODO: expand to full grapheme cluster detection once unicode tables land.
        self.offset = end
        Grapheme { bytes: slice_bytes(self.string.bytes, start, end) }
      }
    }
  }

  fn size(self: Self) -> u64 {
    count := 0
    idx := self.offset
    loop {
      if idx >= self.string.len_bytes { break }
      utf8_decode(self.string.bytes, idx, self.string.len_bytes) match {
        case err: StringEncodingError => { raise err },
        case result: Utf8DecodeResult => {
          idx = result.next_offset
          count = count + 1
        }
      }
    }
    count
  }
}

impl Iterable Grapheme for StringGraphemesIter {
  fn iterator(self: Self) -> (Iterator Grapheme) { self }
}

fn utf8_validate(bytes: Array u8) -> ?StringEncodingError {
  len := bytes.len()
  idx := 0
  loop {
    if idx >= len { break }
    utf8_decode(bytes, idx, len) match {
      case err: StringEncodingError => { return err },
      case result: Utf8DecodeResult => idx = result.next_offset
    }
  }
  nil
}

fn utf8_decode(bytes: Array u8, offset: i32, length: i32) -> Utf8DecodeResult | StringEncodingError {
  if offset >= length {
    return encoding_error("unexpected end of UTF-8 sequence", offset)
  }

  read_byte(bytes, offset) match {
    case nil => encoding_error("unexpected end of UTF-8 sequence", offset),
    case raw: u8 => {
      first := raw
      if (first & 0x80) == 0 {
        return Utf8DecodeResult {
          codepoint: __able_char_from_codepoint(first),
          next_offset: offset + 1
        }
      }

      if (first & 0xE0) == 0xC0 {
        return decode_multibyte(bytes, offset, length, first & 0x1F, 1, 0x80, offset + 1, 0x110000)
      }

      if (first & 0xF0) == 0xE0 {
        return decode_multibyte(bytes, offset, length, first & 0x0F, 2, 0x800, offset + 1, 0x110000)
      }

      if (first & 0xF8) == 0xF0 {
        return decode_multibyte(bytes, offset, length, first & 0x07, 3, 0x10000, offset + 1, 0x110000)
      }

      encoding_error("invalid UTF-8 leading byte", offset)
    }
  }
}

fn decode_multibyte(
  bytes: Array u8,
  start: i32,
  length: i32,
  initial: i32,
  required_continuations: i32,
  min_value: i32,
  offset: i32,
  max_value: i32
) -> Utf8DecodeResult | StringEncodingError {
  codepoint := initial
  remaining := required_continuations

  loop {
    if remaining <= 0 { break }
    if offset >= length {
      return encoding_error("unexpected end of UTF-8 sequence", offset)
    }

    read_byte(bytes, offset) match {
      case nil => { return encoding_error("unexpected end of UTF-8 sequence", offset) },
      case raw: u8 => {
        value := raw
        if (value & 0xC0) != 0x80 {
          return encoding_error("invalid UTF-8 continuation byte", offset)
        }
        codepoint = (codepoint << 6) | (value & 0x3F)
      }
    }

    offset = offset + 1
    remaining = remaining - 1
  }

  if codepoint < min_value {
    return encoding_error("overlong UTF-8 encoding detected", start)
  }

  if codepoint >= 0xD800 && codepoint <= 0xDFFF {
    return encoding_error("UTF-8 sequence encodes surrogate half", start)
  }

  if codepoint >= max_value {
    return encoding_error("codepoint exceeds Unicode range", start)
  }

  Utf8DecodeResult {
    codepoint: __able_char_from_codepoint(codepoint),
    next_offset: offset
  }
}

fn read_byte(bytes: Array u8, idx: i32) -> ?u8 {
  bytes.get(idx)
}

fn slice_bytes(bytes: Array u8, start: i32, end: i32) -> Array u8 {
  length := end - start
  if length <= 0 {
    return Array.with_capacity(0)
  }

  result: Array u8 := Array.with_capacity(length)
  idx := start
  loop {
    if idx >= end { break }
    bytes.get(idx) match {
      case nil => { break },
      case value: u8 => result.push(value)
    }
    idx = idx + 1
  }
  result
}

fn char_to_utf8(value: char) -> Array u8 {
  bytes := Array.with_capacity(4)
  code := value
  if code <= 0x7F {
    bytes.push(code)
  } else {
    if code <= 0x7FF {
      bytes.push(((code >> 6) | 0xC0))
      bytes.push(((code & 0x3F) | 0x80))
    } else {
      if code <= 0xFFFF {
        bytes.push(((code >> 12) | 0xE0))
        bytes.push((((code >> 6) & 0x3F) | 0x80))
        bytes.push(((code & 0x3F) | 0x80))
      } else {
        bytes.push(((code >> 18) | 0xF0))
        bytes.push((((code >> 12) & 0x3F) | 0x80))
        bytes.push((((code >> 6) & 0x3F) | 0x80))
        bytes.push(((code & 0x3F) | 0x80))
      }
    }
  }
  bytes
}

fn encoding_error(message: string, offset: ?i32) -> StringEncodingError {
  StringEncodingError { message, offset }
}

fn count_chars(bytes: Array u8, length: i32) -> i32 {
  idx := 0
  count := 0
  loop {
    if idx >= length { break }
    utf8_decode(bytes, idx, length) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        idx = result.next_offset
        count = count + 1
      }
    }
  }
  count
}

fn count_graphemes(bytes: Array u8, length: i32) -> i32 {
  idx := 0
  count := 0
  loop {
    if idx >= length { break }
    utf8_decode(bytes, idx, length) match {
      case err: StringEncodingError => { raise err },
      case result: Utf8DecodeResult => {
        idx = result.next_offset
        count = count + 1
      }
    }
  }
  count
}

fn codepoint_offset(bytes: Array u8, length: i32, target: i32) -> Result i32 {
  if target == 0 { return 0 }
  idx := 0
  offset := 0
  loop {
    if idx >= target { break }
    utf8_decode(bytes, offset, length) match {
      case err: StringEncodingError => { return err },
      case result: Utf8DecodeResult => {
        offset = result.next_offset
        idx = idx + 1
      }
    }
  }
  offset
}
