package regex
import able.kernel.{Array}
import able.collections.hash_map.{HashMap}
import able.core.interfaces.{Error}
import able.core.iteration.{Iterator, IteratorEnd}
import able.core.options.{Result}

struct Span {
  start: u64,
  end: u64
}

struct RegexOptions {
  case_insensitive: bool,
  multiline: bool,
  dot_matches_newline: bool,
  unicode: bool,
  anchored: bool,
  unicode_case: bool,
  grapheme_mode: bool
}

methods RegexOptions {
  fn default() -> RegexOptions {
    RegexOptions {
      case_insensitive: false,
      multiline: false,
      dot_matches_newline: false,
      unicode: true,
      anchored: false,
      unicode_case: false,
      grapheme_mode: false
    }
  }
}

struct RegexHandle {}

struct Regex {
  pattern: String,
  options: RegexOptions,
  program: RegexHandle
}

struct RegexInvalidPattern {
  message: String,
  span: Span
}

struct RegexUnsupportedFeature {
  message: String,
  hint: ?String
}

struct RegexCompileFailure {
  message: String
}

union RegexError =
  RegexInvalidPattern |
  RegexUnsupportedFeature |
  RegexCompileFailure

impl Error for RegexInvalidPattern {
  fn message(self: Self) -> String { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

impl Error for RegexUnsupportedFeature {
  fn message(self: Self) -> String { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

impl Error for RegexCompileFailure {
  fn message(self: Self) -> String { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

fn unsupported(feature: String) -> RegexUnsupportedFeature {
  RegexUnsupportedFeature {
    message: `regex ${feature} is not implemented yet`,
    hint: nil
  }
}

fn validate_options(options: RegexOptions) -> ?RegexUnsupportedFeature {
  if options.unicode == false { return unsupported("unicode=false") }
  if options.anchored { return unsupported("anchored") }
  if options.unicode_case { return unsupported("unicode_case") }
  if options.grapheme_mode { return unsupported("grapheme_mode") }
  nil
}

struct Group {
  name: ?String,
  value: ?String,
  span: ?Span
}

struct Match {
  matched: String,
  span: Span,
  groups: Array Group,
  named_groups: HashMap String Group
}

union Replacement =
  ReplacementLiteral String |
  ReplacementFunction (Match -> String)

struct RegexIter {
  haystack: String,
  regex: Regex,
  offset: u64,
  done: bool
}

impl Iterator Match for RegexIter {
  fn next(self: Self) -> Match | IteratorEnd {
    raise unsupported("find_all")
  }
}

struct RegexSet {
  patterns: Array Regex
}

struct RegexScanner {
  regex: Regex,
  buffer: String,
  offset: u64
}

methods RegexScanner {
  fn feed(self: Self, chunk: String) -> void {
    raise unsupported("scan")
  }

  fn next(self: Self) -> Match | IteratorEnd {
    raise unsupported("scan")
  }
}

methods Regex {
  fn compile(pattern: String) -> Regex | Error {
    Regex.compile_with_options(pattern, RegexOptions.default())
  }

  fn compile_with_options(pattern: String, options: RegexOptions) -> Regex | Error {
    validate_options(options) match {
      case err: RegexUnsupportedFeature => err,
      case nil => unsupported("compile")
    }
  }

  fn is_match(self: Self, haystack: String) -> bool {
    self.match(haystack) match {
      case nil => false,
      case _: Match => true
    }
  }

  fn match(self: Self, haystack: String) -> ?Match {
    raise unsupported("match")
  }

  fn find_all(self: Self, haystack: String) -> RegexIter {
    raise unsupported("find_all")
  }

  fn replace(self: Self, haystack: String, replacement: Replacement) -> Result String {
    unsupported("replace")
  }

  fn split(self: Self, haystack: String, limit: ?u64) -> Array String {
    raise unsupported("split")
  }

  fn scan(self: Self, haystack: String) -> RegexScanner {
    raise unsupported("scan")
  }
}

fn regex_is_match(pattern: String, haystack: String) -> Result bool {
  Regex.compile(pattern) match {
    case err: Error => err,
    case regex: Regex => regex.is_match(haystack)
  }
}
