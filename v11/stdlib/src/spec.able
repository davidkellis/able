## This file is generated by stdlib/src/spec/build.mjs
## Do not edit directly; update the files under stdlib/src/spec/parts and rerun the builder.
package spec
import able.collections.array.{Array}
import able.core.interfaces.{Error}
import able.text.string.{String}
import able.spec.assertions.{
  AssertionError,
  BeFalseMatcher,
  BeNilMatcher,
  BeTruthyMatcher,
  BeEmptyArrayMatcher,
  BeWithinMatcher,
  ContainMatcher,
  ContainAllMatcher,
  BeGreaterThanMatcher,
  BeLessThanMatcher,
  BeBetweenMatcher,
  StartsWithMatcher,
  EndsWithMatcher,
  IncludeSubstringMatcher,
  MatchRegexMatcher,
  CustomMatcher,
  EqMatcher,
  Expectation,
  RaiseErrorMatcher,
  StringEqMatcher,
  be_false::assertions_be_false,
  be_nil::assertions_be_nil,
  be_truthy::assertions_be_truthy,
  be_empty_array::assertions_be_empty_array,
  be_within::assertions_be_within,
  contain::assertions_contain,
  contain_all::assertions_contain_all,
  be_greater_than::assertions_be_greater_than,
  be_less_than::assertions_be_less_than,
  be_between::assertions_be_between,
  start_with::assertions_start_with,
  end_with::assertions_end_with,
  include_substring::assertions_include_substring,
  match_regex::assertions_match_regex,
  matcher::assertions_matcher,
  matcher_with_details::assertions_matcher_with_details,
  eq::assertions_eq,
  eq_string::assertions_eq_string,
  expect::assertions_expect,
  to::assertions_to,
  not_to::assertions_not_to,
  failure_from_assertion,
  raise_error::assertions_raise_error,
  raise_error_with_message::assertions_raise_error_with_message
}
import able.test.protocol.{
  DiscoveryRequest,
  Failure,
  Framework,
  MetadataEntry,
  Reporter,
  RunOptions,
  TestDescriptor,
  TestEvent,
  TestPlan,
  case_started,
  case_passed,
  case_failed,
  case_skipped,
  framework_error
}
import able.test.registry.{register_framework}
FRAMEWORK_ID := "able.spec"
to := assertions_to
not_to := assertions_not_to
struct SpecFramework {}
struct SuiteConfig {
  allow_parallel: bool
}
struct SuiteState {
  key: String,
  path: Array String,
  module_path: String,
  tags: Array String,
  before_each: Array (ExampleContext -> void),
  after_each: Array (ExampleContext -> void),
  before_all: Array (ExampleContext -> void),
  after_all: Array (ExampleContext -> void),
  config: SuiteConfig
}
struct SuiteDefinition {
  key: String,
  path: Array String,
  before_all: Array (ExampleContext -> void),
  after_all: Array (ExampleContext -> void)
}
struct SuiteBuilder {
  state_index: i32
}
struct ExampleContext {}
struct ExampleDefinition {
  id: String,
  display_name: String,
  suite_key: String,
  suite_path: Array String,
  tags: Array String,
  before_each: Array (ExampleContext -> void),
  after_each: Array (ExampleContext -> void),
  body: ExampleContext -> void,
  module_path: String,
  skip: bool,
  focus: bool
}
SUITE_STACK: Array SuiteState := Array.new()
SUITES: Array SuiteDefinition := Array.new()
SUITES_ARCHIVE: Array SuiteDefinition := Array.new()
EXAMPLES: Array ExampleDefinition := Array.new()
EXAMPLES_ARCHIVE: Array ExampleDefinition := Array.new()
struct ExampleOptions {
  tags: Array String,
  skip: bool,
  focus: bool
}
fn example_options() -> ExampleOptions {
  ExampleOptions { tags: Array.new(), skip: false, focus: false }
}
methods ExampleOptions {
  fn tag(self: ExampleOptions, tag: String) -> ExampleOptions {
    self.tags.push(tag)
    self
  }
  fn tags(self: ExampleOptions, tags: Array String) -> ExampleOptions {
    idx := 0
    loop {
      if idx >= tags.len() { break }
      tags.get(idx) match {
        case nil => {},
        case value: String => self.tags.push(value)
      }
      idx = idx + 1
    }
    self
  }
  fn skip(self: ExampleOptions) -> ExampleOptions {
    self.skip = true
    self
  }
  fn focus(self: ExampleOptions) -> ExampleOptions {
    self.focus = true
    self
  }
}
fn expect<T>(value: T) -> Expectation T {
  assertions_expect(value)
}
fn eq<T>(expected: T) -> EqMatcher T {
  assertions_eq(expected)
}
fn eq_string(expected: String) -> StringEqMatcher {
  assertions_eq_string(expected)
}
fn be_nil() -> BeNilMatcher {
  assertions_be_nil()
}
fn be_truthy() -> BeTruthyMatcher {
  assertions_be_truthy()
}
fn be_false() -> BeFalseMatcher {
  assertions_be_false()
}
fn be_empty_array<T>() -> BeEmptyArrayMatcher T {
  assertions_be_empty_array()
}
fn contain<T>(value: T) -> ContainMatcher T {
  assertions_contain(value)
}
fn be_within(delta: f64, target: f64) -> BeWithinMatcher {
  assertions_be_within(delta, target)
}
fn contain_all<T>(values: Array T) -> ContainAllMatcher T {
  assertions_contain_all(values)
}
fn be_greater_than(value: i64) -> BeGreaterThanMatcher i64 {
  assertions_be_greater_than(value)
}
fn be_less_than(value: i64) -> BeLessThanMatcher i64 {
  assertions_be_less_than(value)
}
fn match_regex(pattern: String) -> MatchRegexMatcher {
  assertions_match_regex(pattern)
}
fn be_between(lower: i64, upper: i64) -> BeBetweenMatcher i64 {
  assertions_be_between(lower, upper)
}
fn start_with(prefix: String) -> StartsWithMatcher {
  assertions_start_with(prefix)
}
fn end_with(suffix: String) -> EndsWithMatcher {
  assertions_end_with(suffix)
}
fn include_substring(substring: String) -> IncludeSubstringMatcher {
  assertions_include_substring(substring)
}
fn matcher<T>(
  message: String,
  negated_message: String,
  predicate: T -> bool
) -> CustomMatcher T {
  assertions_matcher(message, negated_message, predicate)
}
fn matcher_with_details<T>(
  message: String,
  negated_message: String,
  predicate: T -> bool,
  detail: T -> ?String
) -> CustomMatcher T {
  assertions_matcher_with_details(message, negated_message, predicate, detail)
}
fn raise_error() -> RaiseErrorMatcher {
  assertions_raise_error()
}
fn raise_error_with_message(message: String) -> RaiseErrorMatcher {
  assertions_raise_error_with_message(message)
}
fn describe(name: String, body: SuiteBuilder -> void) -> void {
  builder := push_suite(name)
  body(builder)
  pop_suite()
}
fn context(name: String, body: SuiteBuilder -> void) -> void {
  describe(name, body)
}
methods SuiteBuilder {
  fn it(self: Self, name: String, body: ExampleContext -> void) -> void {
    self.register_example(name, empty_string_array(), body, false, false)
  }
  fn it_tags(self: Self, name: String, tags: Array String, body: ExampleContext -> void) -> void {
    self.register_example(name, tags, body, false, false)
  }
  fn it_skip(self: Self, name: String, body: ExampleContext -> void) -> void {
    self.register_example(name, empty_string_array(), body, true, false)
  }
  fn it_only(self: Self, name: String, body: ExampleContext -> void) -> void {
    self.register_example(name, empty_string_array(), body, false, true)
  }
  fn it_opts(self: Self, name: String, options: ExampleOptions, body: ExampleContext -> void) -> void {
    self.register_example(name, clone_string_array(options.tags), body, options.skip, options.focus)
  }
  fn describe(self: Self, name: String, body: SuiteBuilder -> void) -> void {
    describe(name, body)
  }
  fn context(self: Self, name: String, body: SuiteBuilder -> void) -> void {
    describe(name, body)
  }
  fn before_each(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    SUITE_STACK.get(self.state_index) match {
      case nil => {},
      case state: SuiteState => {
        updated := state
        updated.before_each.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }
  fn after_each(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    SUITE_STACK.get(self.state_index) match {
      case nil => {},
      case state: SuiteState => {
        updated := state
        updated.after_each.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }
  fn before_all(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    SUITE_STACK.get(self.state_index) match {
      case nil => {},
      case state: SuiteState => {
        updated := state
        updated.before_all.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }
  fn after_all(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    SUITE_STACK.get(self.state_index) match {
      case nil => {},
      case state: SuiteState => {
        updated := state
        updated.after_all.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }
  fn tag(self: Self, tag: String) -> void {
    if self.state_index < 0 { return }
    SUITE_STACK.get(self.state_index) match {
      case nil => {},
      case state: SuiteState => {
        updated := state
        updated.tags.push(tag)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }
  fn tags(self: Self, tags: Array String) -> void {
    idx := 0
    loop {
      if idx >= tags.len() { break }
      tags.get(idx) match {
        case nil => {},
        case tag: String => self.tag(tag)
      }
      idx = idx + 1
    }
  }
  fn module_path(self: Self, path: String) -> void {
    if self.state_index < 0 { return }
    SUITE_STACK.get(self.state_index) match {
      case nil => {},
      case state: SuiteState => {
        updated := state
        updated.module_path = path
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }
  fn register_example(
    self: Self,
    name: String,
    tags: Array String,
    body: ExampleContext -> void,
    skip: bool,
    focus: bool
  ) -> void {
    if self.state_index < 0 { return }
    SUITE_STACK.get(self.state_index) match {
      case nil => {},
      case state: SuiteState => {
        stored_path := clone_string_array(state.path)
        suite_key := build_suite_key(stored_path)
        example_id := build_example_id(stored_path, name)
        display_name := build_example_display(stored_path, name)
        full_tags := if tags.len() == 0 {
          clone_string_array(state.tags)
        } else {
          clone_string_array(tags)
        }
        if skip { full_tags.push("skip") }
        if focus { full_tags.push("focus") }
        example := ExampleDefinition {
          id: example_id,
          display_name,
          suite_key,
          suite_path: stored_path,
          tags: full_tags,
          before_each: clone_hook_array(state.before_each),
          after_each: clone_hook_array(state.after_each),
          body,
          module_path: state.module_path,
          skip,
          focus
        }
        EXAMPLES.push(example)
        archive_idx := 0
        loop {
          if archive_idx >= EXAMPLES_ARCHIVE.len() { break }
          EXAMPLES_ARCHIVE.get(archive_idx) match {
            case nil => {},
            case existing: ExampleDefinition => {
              if existing.id == example_id {
                EXAMPLES_ARCHIVE.set(archive_idx, example)
                return
              }
            }
          }
          archive_idx = archive_idx + 1
        }
        EXAMPLES_ARCHIVE.push(example)
      }
    }
  }
}
fn push_suite(name: String) -> SuiteBuilder {
  parent_index := SUITE_STACK.len() - 1
  path: Array String := Array.new()
  module_path := ""
  tags: Array String := Array.new()
  before_each: Array (ExampleContext -> void) := Array.new()
  after_each: Array (ExampleContext -> void) := Array.new()
  before_all: Array (ExampleContext -> void) := Array.new()
  after_all: Array (ExampleContext -> void) := Array.new()
  config := SuiteConfig { allow_parallel: false }
  if parent_index >= 0 {
    SUITE_STACK.get(parent_index) match {
      case nil => {},
      case parent: SuiteState => {
        path = clone_string_array(parent.path)
        module_path = parent.module_path
        tags = clone_string_array(parent.tags)
        before_each = clone_hook_array(parent.before_each)
        after_each = clone_hook_array(parent.after_each)
        config = parent.config
      }
    }
  }
  path.push(name)
  if module_path == "" {
    module_path = build_suite_key(path)
  }
  state := SuiteState {
    key: build_suite_key(path),
    path,
    module_path,
    tags,
    before_each,
    after_each,
    before_all,
    after_all,
    config
  }
  SUITE_STACK.push(state);
  return SuiteBuilder { state_index: (SUITE_STACK.len() - 1) as i32 }
}
fn pop_suite() -> void {
  SUITE_STACK.pop() match {
    case nil => {},
    case state: SuiteState => register_suite(state)
  }
}
fn register_suite(state: SuiteState) -> void {
  definition := SuiteDefinition {
    key: state.key,
    path: clone_string_array(state.path),
    before_all: clone_hook_array(state.before_all),
    after_all: clone_hook_array(state.after_all)
  }
  idx := 0
  loop {
    if idx >= SUITES.len() { break }
    SUITES.get(idx) match {
      case nil => {},
      case existing: SuiteDefinition => {
        if existing.key == state.key {
          SUITES.set(idx, definition)
          archive_idx := 0
          loop {
            if archive_idx >= SUITES_ARCHIVE.len() { break }
            SUITES_ARCHIVE.get(archive_idx) match {
              case nil => {},
              case archived: SuiteDefinition => {
                if archived.key == state.key {
                  SUITES_ARCHIVE.set(archive_idx, definition)
                  return
                }
              }
            }
            archive_idx = archive_idx + 1
          }
          SUITES_ARCHIVE.push(definition)
          return
        }
      }
    }
    idx = idx + 1
  }
  SUITES.push(definition)
  archive_idx := 0
  loop {
    if archive_idx >= SUITES_ARCHIVE.len() { break }
    SUITES_ARCHIVE.get(archive_idx) match {
      case nil => {},
      case archived: SuiteDefinition => {
        if archived.key == state.key {
          SUITES_ARCHIVE.set(archive_idx, definition)
          return
        }
      }
    }
    archive_idx = archive_idx + 1
  }
  SUITES_ARCHIVE.push(definition)
}
fn find_suite(key: String) -> ?SuiteDefinition {
  idx := 0
  loop {
    if idx >= SUITES.len() { break }
    SUITES.get(idx) match {
      case nil => {},
      case suite: SuiteDefinition => {
        if suite.key == key { return suite }
      }
    }
    idx = idx + 1
  }
  idx = 0
  loop {
    if idx >= SUITES_ARCHIVE.len() { break }
    SUITES_ARCHIVE.get(idx) match {
      case nil => {},
      case suite: SuiteDefinition => {
        if suite.key == key { return suite }
      }
    }
    idx = idx + 1
  }
  nil
}
fn find_example(id: String) -> ?ExampleDefinition {
  idx := 0
  loop {
    if idx >= EXAMPLES.len() { break }
    EXAMPLES.get(idx) match {
      case nil => {},
      case example: ExampleDefinition => {
        if example.id == id { return example }
      }
    }
    idx = idx + 1
  }
  idx = 0
  loop {
    if idx >= EXAMPLES_ARCHIVE.len() { break }
    EXAMPLES_ARCHIVE.get(idx) match {
      case nil => {},
      case example: ExampleDefinition => {
        if example.id == id { return example }
      }
    }
    idx = idx + 1
  }
  nil
}
fn build_suite_key(path: Array String) -> String {
  join_segments(path, "::")
}
fn build_example_id(path: Array String, name: String) -> String {
  segments := clone_string_array(path)
  segments.push(name)
  join_segments(segments, "::")
}
fn build_example_display(path: Array String, name: String) -> String {
  segments := clone_string_array(path)
  segments.push(name)
  join_segments(segments, " ")
}
fn join_segments(segments: Array String, separator: String) -> String {
  result := ""
  idx := 0
  loop {
    if idx >= segments.len() { break }
    segments.get(idx) match {
      case nil => {},
      case segment: String => {
        if result == "" {
          result = segment
        } else {
          result = `${result}${separator}${segment}`
        }
      }
    }
    idx = idx + 1
  }
  result
}
fn clone_string_array(source: Array String) -> Array String {
  result: Array String := Array.new()
  idx := 0
  loop {
    if idx >= source.len() { break }
    source.get(idx) match {
      case nil => {},
      case value: String => result.push(value)
    }
    idx = idx + 1
  }
  result
}
fn clone_hook_array(source: Array (ExampleContext -> void)) -> Array (ExampleContext -> void) {
  result: Array (ExampleContext -> void) := Array.new()
  idx := 0
  loop {
    if idx >= source.len() { break }
    source.get(idx) match {
      case nil => {},
      case hook: (ExampleContext -> void) => result.push(hook)
    }
    idx = idx + 1
  }
  result
}
fn merge_tags(base: Array String, extra: Array String) -> Array String {
  result := clone_string_array(base)
  idx := 0
  loop {
    if idx >= extra.len() { break }
    extra.get(idx) match {
      case nil => {},
      case value: String => result.push(value)
    }
    idx = idx + 1
  }
  result
}
fn empty_string_array() -> Array String { Array.new() }
fn contains_substring(target: String, needles: Array String) -> bool {
  if needles.len() == 0 { return false }
  idx := 0
  loop {
    if idx >= needles.len() { break }
    needles.get(idx) match {
      case nil => {},
      case needle: String => {
        if needle == "" { return true }
        if target == needle { return true }
      }
    }
    idx = idx + 1
  }
  false
}
fn array_contains(array: Array String, value: String) -> bool {
  idx := 0
  loop {
    if idx >= array.len() { break }
    array.get(idx) match {
      case nil => {},
      case element: String => {
        if element == value { return true }
      }
    }
    idx = idx + 1
  }
  false
}
fn matches_tags(tags: Array String, include: Array String, exclude: Array String) -> bool {
  idx := 0
  loop {
    if idx >= include.len() { break }
    include.get(idx) match {
      case nil => {},
      case tag: String => {
        if !array_contains(tags, tag) { return false }
      }
    }
    idx = idx + 1
  }
  idx = 0
  loop {
    if idx >= exclude.len() { break }
    exclude.get(idx) match {
      case nil => {},
      case tag: String => {
        if array_contains(tags, tag) { return false }
      }
    }
    idx = idx + 1
  }
  true
}
fn matches_names(example: ExampleDefinition, include: Array String, exclude: Array String) -> bool {
  id := example.id
  name := example.display_name
  if include.len() > 0 {
    if !contains_substring(id, include) && !contains_substring(name, include) {
      return false
    }
  }
  if contains_substring(id, exclude) || contains_substring(name, exclude) {
    return false
  }
  true
}
fn matches_paths(module_path: String, include: Array String, exclude: Array String) -> bool {
  if include.len() > 0 {
    if module_path == "" { return false }
    if !contains_substring(module_path, include) { return false }
  }
  if module_path != "" && contains_substring(module_path, exclude) { return false }
  true
}
fn matches_filters(example: ExampleDefinition, request: DiscoveryRequest) -> bool {
  if !matches_tags(example.tags, request.include_tags, request.exclude_tags) {
    return false
  }
  if !matches_names(example, request.include_names, request.exclude_names) {
    return false
  }
  if !matches_paths(example.module_path, request.include_paths, request.exclude_paths) {
    return false
  }
  true
}
fn suite_prefix_keys(path: Array String) -> Array String {
  keys: Array String := Array.new()
  idx := 0
  loop {
    if idx >= path.len() { break }
    prefix: Array String := Array.new()
    inner := 0
    loop {
      if inner > idx { break }
      path.get(inner) match {
        case nil => {},
        case segment: String => prefix.push(segment)
      }
      inner = inner + 1
    }
    keys.push(build_suite_key(prefix))
    idx = idx + 1
  }
  keys
}
fn contains_string(array: Array String, needle: String) -> bool {
  idx := 0
  loop {
    if idx >= array.len() { break }
    array.get(idx) match {
      case nil => {},
      case value: String => {
        if value == needle { return true }
      }
    }
    idx = idx + 1
  }
  false
}
fn run_hook_sequence(hooks: Array (ExampleContext -> void), ctx: ExampleContext) -> ?Failure {
  idx := 0
  loop {
    if idx >= hooks.len() { break }
    hook := hooks.read_slot(idx)
    failure: ?Failure := nil
    do { hook(ctx) } rescue {
      case err: Error => {
        err.value match {
          case assertion: AssertionError => { failure = failure_from_assertion(assertion) },
          case _ => { failure = Failure { message: err.message(), details: nil, location: nil } }
        }
        nil
      }
    }
    failure match {
      case nil => {},
      case _ => { return failure }
    }
    idx = idx + 1
  }
  nil
}
fn run_hook_sequence_reverse(hooks: Array (ExampleContext -> void), ctx: ExampleContext) -> ?Failure {
  idx := hooks.len() - 1
  loop {
    if idx < 0 { break }
    hook := hooks.read_slot(idx)
    failure: ?Failure := nil
    do { hook(ctx) } rescue {
      case err: Error => {
        err.value match {
          case assertion: AssertionError => { failure = failure_from_assertion(assertion) },
          case _ => { failure = Failure { message: err.message(), details: nil, location: nil } }
        }
        nil
      }
    }
    failure match {
      case nil => {},
      case _ => { return failure }
    }
    idx = idx - 1
  }
  nil
}
fn run_before_all_for_suite(key: String, executed: Array String) -> ?Failure {
  find_suite(key) match {
    case nil => nil,
    case suite: SuiteDefinition => {
      if contains_string(executed, key) { return nil }
      ctx := ExampleContext {}
      failure := run_hook_sequence(suite.before_all, ctx)
      failure match {
        case nil => {},
        case _ => { return failure }
      }
      nil
    }
  }
}
fn run_after_all_for_suites(keys: Array String, reporter: Reporter) -> void {
  idx := keys.len() - 1
  loop {
    if idx < 0 { break }
    keys.get(idx) match {
      case nil => {},
      case key: String => {
        find_suite(key) match {
          case nil => {},
          case suite: SuiteDefinition => {
            ctx := ExampleContext {}
            run_hook_sequence_reverse(suite.after_all, ctx) match {
              case nil => {},
              case failure: Failure => reporter.emit(framework_error { message: failure.message })
            }
          }
        }
      }
    }
    idx = idx - 1
  }
}
impl Framework for SpecFramework {
  fn id(self: Self) -> String { FRAMEWORK_ID }
  fn discover(
    self: Self,
    request: DiscoveryRequest,
    register: TestDescriptor -> void
  ) -> ?Failure {
    idx := 0
    loop {
      if idx >= EXAMPLES.len() { break }
      EXAMPLES.get(idx) match {
        case nil => {},
        case example: ExampleDefinition => {
          if !matches_filters(example, request) {
            idx = idx + 1
            continue
          }
          metadata: Array MetadataEntry := Array.new()
          metadata.push(MetadataEntry { key: "suite_path", value: build_suite_key(example.suite_path) })
          if example.module_path != "" {
            metadata.push(MetadataEntry { key: "module_path", value: example.module_path })
          }
          if example.tags.len() > 0 {
            metadata.push(MetadataEntry { key: "tags", value: join_segments(example.tags, ",") })
          }
          register(TestDescriptor {
            framework_id: FRAMEWORK_ID,
            module_path: example.module_path,
            test_id: example.id,
            display_name: example.display_name,
            location: nil,
            tags: clone_string_array(example.tags),
            metadata
          })
        }
      }
      idx = idx + 1
    }
  }
  fn run(
    self: Self,
    plan: TestPlan,
    options: RunOptions,
    reporter: Reporter
  ) -> ?Failure {
    executed_suite_keys: Array String := Array.new()
    idx := 0
    loop {
      if idx >= plan.descriptors.len() { break }
      plan.descriptors.get(idx) match {
        case nil => {},
        case descriptor: TestDescriptor => {
          find_example(descriptor.test_id) match {
            case nil => {
              run_after_all_for_suites(executed_suite_keys, reporter)
              return Failure {
                message: `unknown test id ${descriptor.test_id}`,
                details: nil,
                location: nil
              }
            },
            case example: ExampleDefinition => {
              if tag_list_contains(descriptor.tags, "skip") {
                reporter.emit(case_skipped { descriptor, reason: "skipped" })
                idx = idx + 1
                continue
              } else {
                reporter.emit(case_started { descriptor })
              prefix_keys := suite_prefix_keys(example.suite_path)
              prefix_idx := 0
              loop {
                if prefix_idx >= prefix_keys.len() { break }
                prefix_keys.get(prefix_idx) match {
                  case nil => {},
                  case key: String => {
                    run_before_all_for_suite(key, executed_suite_keys) match {
                      case nil => {
                        if !contains_string(executed_suite_keys, key) {
                          executed_suite_keys.push(key)
                        }
                      },
                      case failure: Failure => {
                        reporter.emit(case_failed {
                          descriptor,
                          duration_ms: 0,
                          failure
                        })
                        run_after_all_for_suites(executed_suite_keys, reporter)
                        return nil
                      }
                    }
                  }
                }
                prefix_idx = prefix_idx + 1
              }
              ctx := ExampleContext {}
              before_failure := run_hook_sequence(example.before_each, ctx)
              failure: ?Failure := before_failure
              if failure == nil {
                body_failure: ?Failure := nil
                do { example.body(ctx) } rescue {
                  case err: Error => {
                    err.value match {
                      case assertion: AssertionError => { body_failure = failure_from_assertion(assertion) },
                      case _ => { body_failure = Failure { message: err.message(), details: nil, location: nil } }
                    }
                    nil
                  }
                }
                body_failure match {
                  case nil => {},
                  case _ => { failure = body_failure }
                }
              }
              after_failure := run_hook_sequence_reverse(example.after_each, ctx)
              if failure == nil {
                failure = after_failure
              }
                failure match {
                  case nil => reporter.emit(case_passed { descriptor, duration_ms: 0 }),
                  case fail: Failure => reporter.emit(case_failed {
                    descriptor,
                    duration_ms: 0,
                    failure: fail
                  })
                }
                if options.fail_fast {
                  failure match {
                    case nil => {},
                    case _ => {
                      run_after_all_for_suites(executed_suite_keys, reporter)
                      return nil
                    }
                  }
                }
              }
            }
          }
        }
      }
      idx = idx + 1
    }
    run_after_all_for_suites(executed_suite_keys, reporter)
    nil
  }
}
fn tag_list_contains(tags: Array String, needle: String) -> bool {
  idx := 0
  loop {
    if idx >= tags.len() { break }
    tags.get(idx) match {
      case nil => {},
      case value: String => {
        if value == needle { return true }
      }
    }
    idx = idx + 1
  }
  false
}
fn __clear_examples_for_tests() -> void {
  EXAMPLES = Array.new()
  SUITES = Array.new()
  SUITE_STACK = Array.new()
}
register_framework(SpecFramework {})
