package fs

import able.kernel.{Array}
import able.io.{IOError, IOErrorKind, unwrap, unwrap_void, read_all, string_to_bytes, bytes_to_string, close}
import able.io.Path
import able.text.string.{String}

prelude go {
import (
  "errors"
  "os"
  "path/filepath"
  "syscall"
)

func fsErrorKind(err error) string {
  if err == nil {
    return "Other"
  }
  switch {
  case errors.Is(err, os.ErrNotExist):
    return "NotFound"
  case errors.Is(err, os.ErrPermission):
    return "PermissionDenied"
  case errors.Is(err, os.ErrExist):
    return "AlreadyExists"
  case errors.Is(err, os.ErrInvalid):
    return "InvalidInput"
  case errors.Is(err, os.ErrClosed):
    return "Closed"
  case errors.Is(err, syscall.EPIPE):
    return "BrokenPipe"
  case os.IsTimeout(err):
    return "TimedOut"
  default:
    return "Other"
  }
}

func fsErrorFrom(err error, path *string) map[string]any {
  var pathVal any = nil
  if path != nil {
    pathVal = *path
  }
  return map[string]any{
    "kind": fsErrorKind(err),
    "message": err.Error(),
    "path": pathVal,
  }
}

func boolField(value map[string]any, name string) bool {
  if value == nil {
    return false
  }
  if raw, ok := value[name]; ok {
    if b, ok := raw.(bool); ok {
      return b
    }
  }
  return false
}

func intField(value map[string]any, name string) int {
  if value == nil {
    return 0
  }
  if raw, ok := value[name]; ok {
    switch v := raw.(type) {
    case int:
      return v
    case int32:
      return int(v)
    case int64:
      return int(v)
    }
  }
  return 0
}
}

prelude typescript {
import * as fs from "node:fs";
import * as path from "node:path";

function fsErrorKind(err) {
  const code = err && err.code ? String(err.code) : "";
  switch (code) {
    case "ENOENT": return "NotFound";
    case "EACCES": return "PermissionDenied";
    case "EPERM": return "PermissionDenied";
    case "EEXIST": return "AlreadyExists";
    case "EINVAL": return "InvalidInput";
    case "ETIMEDOUT": return "TimedOut";
    case "EPIPE": return "BrokenPipe";
    case "EBADF": return "Closed";
    case "ENOTTY": return "Unsupported";
    default: return "Other";
  }
}

function fsErrorFrom(err, pathValue) {
  return {
    kind: fsErrorKind(err),
    message: err && err.message ? String(err.message) : String(err),
    path: pathValue ?? null,
  };
}
}

struct FsOpenFlags {
  read: bool,
  write: bool,
  append: bool,
  create: bool,
  truncate: bool
}

struct FsMode {
  bits: i32
}

struct FsMetadata {
  size: i64,
  is_dir: bool,
  is_file: bool,
  modified_ms: ?i64
}

struct DirEntry {
  name: String,
  path: String,
  is_dir: bool,
  is_file: bool
}

fn mode(bits: i32) -> FsMode { FsMode { bits } }

fn read_only() -> FsOpenFlags {
  FsOpenFlags { read: true, write: false, append: false, create: false, truncate: false }
}

fn write_only(create: bool, truncate: bool) -> FsOpenFlags {
  FsOpenFlags { read: false, write: true, append: false, create, truncate }
}

fn append_only(create: bool) -> FsOpenFlags {
  FsOpenFlags { read: false, write: true, append: true, create, truncate: false }
}

extern typescript fn fs_open(path: String, flags: FsOpenFlags, mode: ?FsMode) -> IOError | IoHandle {
  return (async () => {
    try {
      const read = !!flags.read;
      const write = !!flags.write;
      const append = !!flags.append;
      const create = !!flags.create;
      const truncate = !!flags.truncate;
      const access = read && write ? "r+" : write ? "w" : "r";
      const options = { flag: append ? "a" : access, mode: mode ? mode.bits : undefined };
      const handle = await fs.promises.open(path, options.flag, options.mode);
      return { fd: handle.fd, handle };
    } catch (err) {
      return fsErrorFrom(err, path);
    }
  })();
}

extern go fn fs_open(path: String, flags: FsOpenFlags, mode: ?FsMode) -> IOError | IoHandle {
  flagMap, _ := flags.(map[string]any)
  read := boolField(flagMap, "read")
  write := boolField(flagMap, "write")
  append := boolField(flagMap, "append")
  create := boolField(flagMap, "create")
  truncate := boolField(flagMap, "truncate")
  openFlags := 0
  if read && write {
    openFlags = openFlags | os.O_RDWR
  } else if write || append {
    openFlags = openFlags | os.O_WRONLY
  } else {
    openFlags = openFlags | os.O_RDONLY
  }
  if append { openFlags = openFlags | os.O_APPEND }
  if create { openFlags = openFlags | os.O_CREATE }
  if truncate { openFlags = openFlags | os.O_TRUNC }

  perm := os.FileMode(0o644)
  if mode != nil {
    if raw, ok := (*mode).(map[string]any); ok {
      bits := intField(raw, "bits")
      if bits != 0 { perm = os.FileMode(bits) }
    }
  }

  file, err := os.OpenFile(path, openFlags, perm)
  if err != nil {
    return fsErrorFrom(err, &path)
  }
  return file
}

extern typescript fn fs_stat(path: String) -> IOError | FsMetadata {
  return (async () => {
    try {
      const info = await fs.promises.stat(path);
      return {
        size: Math.trunc(info.size),
        is_dir: info.isDirectory(),
        is_file: info.isFile(),
        modified_ms: info.mtimeMs ? Math.trunc(info.mtimeMs) : null,
      };
    } catch (err) {
      return fsErrorFrom(err, path);
    }
  })();
}

extern go fn fs_stat(path: String) -> IOError | FsMetadata {
  info, err := os.Stat(path)
  if err != nil {
    return fsErrorFrom(err, &path)
  }
  return map[string]any{
    "size": info.Size(),
    "is_dir": info.IsDir(),
    "is_file": info.Mode().IsRegular(),
    "modified_ms": info.ModTime().UnixMilli(),
  }
}

extern typescript fn fs_read_dir(path: String) -> IOError | Array DirEntry {
  return (async () => {
    try {
      const entries = await fs.promises.readdir(path, { withFileTypes: true });
      return entries.map((entry) => ({
        name: entry.name,
        path: path ? path + "/" + entry.name : entry.name,
        is_dir: entry.isDirectory(),
        is_file: entry.isFile(),
      }));
    } catch (err) {
      return fsErrorFrom(err, path);
    }
  })();
}

extern go fn fs_read_dir(path: String) -> IOError | Array DirEntry {
  entries, err := os.ReadDir(path)
  if err != nil {
    return fsErrorFrom(err, &path)
  }
  results := make([]map[string]any, 0, len(entries))
  for _, entry := range entries {
    info, infoErr := entry.Info()
    if infoErr != nil {
      return fsErrorFrom(infoErr, &path)
    }
    results = append(results, map[string]any{
      "name": entry.Name(),
      "path": filepath.Join(path, entry.Name()),
      "is_dir": entry.IsDir(),
      "is_file": info.Mode().IsRegular(),
    })
  }
  return results
}

extern typescript fn fs_mkdir(path: String, recursive: bool) -> IOError | void {
  return (async () => {
    try {
      await fs.promises.mkdir(path, { recursive });
      return null;
    } catch (err) {
      return fsErrorFrom(err, path);
    }
  })();
}

extern go fn fs_mkdir(path: String, recursive: bool) -> IOError | void {
  var err error
  if recursive {
    err = os.MkdirAll(path, 0o755)
  } else {
    err = os.Mkdir(path, 0o755)
  }
  if err != nil {
    return fsErrorFrom(err, &path)
  }
  return nil
}

extern typescript fn fs_remove(path: String, recursive: bool) -> IOError | void {
  return (async () => {
    try {
      await fs.promises.rm(path, { recursive, force: false });
      return null;
    } catch (err) {
      return fsErrorFrom(err, path);
    }
  })();
}

extern go fn fs_remove(path: String, recursive: bool) -> IOError | void {
  var err error
  if recursive {
    err = os.RemoveAll(path)
  } else {
    err = os.Remove(path)
  }
  if err != nil {
    return fsErrorFrom(err, &path)
  }
  return nil
}

extern typescript fn fs_rename(src: String, dst: String) -> IOError | void {
  return (async () => {
    try {
      await fs.promises.rename(src, dst);
      return null;
    } catch (err) {
      return fsErrorFrom(err, src);
    }
  })();
}

extern go fn fs_rename(src: String, dst: String) -> IOError | void {
  if err := os.Rename(src, dst); err != nil {
    return fsErrorFrom(err, &src)
  }
  return nil
}

fn fs_path(path: Path | String) -> String {
  path match {
    case p: Path => p.to_native(),
    case s: String => s,
  }
}

fn open(path: Path | String, flags: FsOpenFlags, mode: ?FsMode) -> IoHandle {
  unwrap(fs_open(fs_path(path), flags, mode))
}

fn stat(path: Path | String) -> FsMetadata {
  unwrap(fs_stat(fs_path(path)))
}

fn read_dir(path: Path | String) -> Array DirEntry {
  unwrap(fs_read_dir(fs_path(path)))
}

fn mkdir(path: Path | String, recursive: bool) -> void {
  unwrap_void(fs_mkdir(fs_path(path), recursive))
}

fn remove(path: Path | String, recursive: bool) -> void {
  unwrap_void(fs_remove(fs_path(path), recursive))
}

fn rename(src: Path | String, dst: Path | String) -> void {
  unwrap_void(fs_rename(fs_path(src), fs_path(dst)))
}

fn exists(path: Path | String) -> bool {
  fs_stat(fs_path(path)) match {
    case IOError { kind: NotFound } => false,
    case err: IOError => { raise err },
    case _: FsMetadata => true,
  }
}

fn read_bytes(path: Path | String) -> Array u8 {
  handle := open(path, read_only(), nil)
  do {
    read_all(handle, nil)
  } ensure {
    close(handle)
  }
}

fn write_bytes(path: Path | String, bytes: Array u8, create_dirs: bool) -> void {
  if create_dirs {
    parent := Path.new(path).parent()
    if parent.to_string() != "" { mkdir(parent, true) }
  }
  handle := open(path, write_only(true, true), nil)
  do {
    able.io.write_all(handle, bytes)
  } ensure {
    close(handle)
  }
}

fn read_text(path: Path | String) -> String {
  bytes_to_string(read_bytes(path))
}

fn write_text(path: Path | String, contents: String, create_dirs: bool) -> void {
  write_bytes(path, string_to_bytes(contents), create_dirs)
}
