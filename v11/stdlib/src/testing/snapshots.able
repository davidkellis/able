package testing

import able.collections.array.{Array}

struct SnapshotEntry {
  name: string,
  value: string
}

struct SnapshotStore {
  read_fn: string -> ?string,
  write_fn: (string, string) -> void,
  update_fn: () -> bool
}

fn SnapshotStore(
  read_fn: string -> ?string,
  write_fn: (string, string) -> void,
  update_fn: () -> bool
) -> SnapshotStore {
  SnapshotStore { read_fn, write_fn, update_fn }
}

impl SnapshotStore {
  fn read(self: Self, name: string) -> ?string {
    self.read_fn(name)
  }

  fn write(self: Self, name: string, value: string) -> void {
    self.write_fn(name, value)
  }

  fn update_mode(self: Self) -> bool {
    self.update_fn()
  }
}

let mut DEFAULT_ENTRIES: Array SnapshotEntry = Array.new()
let mut DEFAULT_UPDATE_MODE: bool = false

fn default_snapshot_store() -> SnapshotStore {
  SnapshotStore(default_read, default_write, default_update_mode)
}

fn snapshot_set_update_mode(enabled: bool) -> void {
  DEFAULT_UPDATE_MODE = enabled
}

fn snapshot_clear() -> void {
  DEFAULT_ENTRIES = Array.new()
}

fn default_update_mode() -> bool { DEFAULT_UPDATE_MODE }

fn default_read(name: string) -> ?string {
  let mut idx = 0
  loop {
    if idx >= DEFAULT_ENTRIES.len() { break }
    match DEFAULT_ENTRIES.get(idx) {
      case nil => {},
      case entry: SnapshotEntry => {
        if entry.name == name { return entry.value }
      }
    }
    idx = idx + 1
  }
  nil
}

fn default_write(name: string, value: string) -> void {
  let mut idx = 0
  loop {
    if idx >= DEFAULT_ENTRIES.len() { break }
    match DEFAULT_ENTRIES.get(idx) {
      case nil => {},
      case entry: SnapshotEntry => {
        if entry.name == name {
          DEFAULT_ENTRIES.set(idx, SnapshotEntry { name, value })
          return
        }
      }
    }
    idx = idx + 1
  }
  DEFAULT_ENTRIES.push(SnapshotEntry { name, value })
}

