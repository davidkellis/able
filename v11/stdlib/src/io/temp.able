package temp

import able.core.interfaces.{Error}
import able.fs
import able.io.{IOError, NotFound, close, unwrap}
import able.text.string.{String}

prelude go {
import (
  "errors"
  "io"
  "os"
  "strings"
  "syscall"
)

func ioErrorKind(err error) string {
  if err == nil {
    return "Other"
  }
  switch {
  case os.IsPermission(err) || errors.Is(err, os.ErrPermission) || errors.Is(err, syscall.EACCES) || errors.Is(err, syscall.EPERM) || strings.Contains(strings.ToLower(err.Error()), "permission denied"):
    return "PermissionDenied"
  case errors.Is(err, os.ErrNotExist):
    return "NotFound"
  case errors.Is(err, os.ErrExist):
    return "AlreadyExists"
  case errors.Is(err, os.ErrInvalid):
    return "InvalidInput"
  case errors.Is(err, os.ErrClosed):
    return "Closed"
  case errors.Is(err, syscall.EPIPE):
    return "BrokenPipe"
  case errors.Is(err, io.EOF):
    return "EOF"
  case os.IsTimeout(err):
    return "TimedOut"
  default:
    return "Other"
  }
}

func ioErrorFrom(err error, path *string) map[string]any {
  var pathVal any = nil
  if path != nil {
    pathVal = *path
  }
  return map[string]any{
    "kind": ioErrorKind(err),
    "message": err.Error(),
    "path": pathVal,
  }
}
}

prelude typescript {
import * as crypto from "node:crypto";
import * as fs from "node:fs";
import * as os from "node:os";
import * as path from "node:path";

function ioErrorKind(err) {
  const code = err && err.code ? String(err.code) : "";
  switch (code) {
    case "ENOENT": return "NotFound";
    case "EACCES": return "PermissionDenied";
    case "EPERM": return "PermissionDenied";
    case "EEXIST": return "AlreadyExists";
    case "EINVAL": return "InvalidInput";
    case "ETIMEDOUT": return "TimedOut";
    case "EPIPE": return "BrokenPipe";
    case "EBADF": return "Closed";
    case "ENOTTY": return "Unsupported";
    default: return "Other";
  }
}

function ioErrorFrom(err, pathValue) {
  return {
    kind: ioErrorKind(err),
    message: err && err.message ? String(err.message) : String(err),
    path: pathValue ?? null,
  };
}

function tempFilePath(prefix) {
  const name = `${prefix}${crypto.randomUUID()}`;
  return path.join(os.tmpdir(), name);
}
}

struct TempDir { path: String }
struct TempFile { path: String, handle: IoHandle }

fn temp_prefix(prefix: ?String) -> String {
  prefix match {
    case nil => "able-temp-",
    case value: String => if value == "" { "able-temp-" } else { value }
  }
}

extern typescript fn io_temp_dir(prefix: String) -> IOError | String {
  return (async () => {
    try {
      const dir = await fs.promises.mkdtemp(path.join(os.tmpdir(), String(prefix)));
      return dir;
    } catch (err) {
      return ioErrorFrom(err, null);
    }
  })();
}

extern go fn io_temp_dir(prefix: String) -> IOError | String {
  dir, err := os.MkdirTemp("", prefix)
  if err != nil {
    return ioErrorFrom(err, nil)
  }
  return dir
}

extern typescript fn io_temp_file(prefix: String) -> IOError | TempFile {
  return (async () => {
    try {
      const prefixValue = String(prefix);
      for (let attempt = 0; attempt < 8; attempt += 1) {
        const target = tempFilePath(prefixValue);
        try {
          const handle = await fs.promises.open(target, "wx+");
          return { path: target, handle: { fd: handle.fd, handle } };
        } catch (err) {
          if (err && err.code === "EEXIST") continue;
          throw err;
        }
      }
      throw new Error("temp file collision");
    } catch (err) {
      return ioErrorFrom(err, null);
    }
  })();
}

extern go fn io_temp_file(prefix: String) -> IOError | TempFile {
  file, err := os.CreateTemp("", prefix)
  if err != nil {
    return ioErrorFrom(err, nil)
  }
  return map[string]any{
    "path": file.Name(),
    "handle": file,
  }
}

fn try_dir(prefix: ?String) -> IOError | TempDir {
  io_temp_dir(temp_prefix(prefix)) match {
    case err: IOError => err,
    case path: String => TempDir { path }
  }
}

fn dir(prefix: ?String) -> TempDir {
  unwrap(try_dir(prefix))
}

fn try_file(prefix: ?String) -> IOError | TempFile {
  io_temp_file(temp_prefix(prefix)) match {
    case err: IOError => err,
    case value: TempFile => value
  }
}

fn file(prefix: ?String) -> TempFile {
  unwrap(try_file(prefix))
}

fn cleanup(target: TempFile | TempDir | String) -> void {
  target match {
    case value: TempFile => {
      close_quiet(value.handle)
      cleanup_path(value.path)
    },
    case value: TempDir => cleanup_path(value.path),
    case value: String => cleanup_path(value)
  }
}

fn cleanup_path(path: String) -> void {
  do {
    fs.remove(path, true)
  } rescue {
    case err: Error => {
      err.value match {
        case io_err: IOError => {
          io_err.kind match {
            case NotFound => {},
            case _ => { raise io_err }
          }
        },
        case _ => { raise err }
      }
    }
  }
}

fn close_quiet(handle: IoHandle) -> void {
  do {
    close(handle)
  } rescue {
    case err: Error => {
      err.value match {
        case _: IOError => {},
        case _ => { raise err }
      }
    }
  }
}
