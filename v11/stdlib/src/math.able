package math

import able.core.errors.{OverflowError}
import able.core.interfaces.{Error}
import able.numbers.primitives

## Domain error raised when a math function receives an input outside its definition range.
struct MathDomainError {
  message: String,
  value: ?f64
}

impl Error for MathDomainError {
  fn message(self: Self) -> String { self.message }
  fn cause(self: Self) -> ?Error { nil }
}

fn __math_default_tolerance() -> f64 { 1e-12 }
fn __math_default_compare_tolerance() -> f64 { 1e-10 }

## Fundamental constants kept as functions to avoid global mutable state.
fn pi() -> f64 { 3.1415926535897932384626433832795 }
fn tau() -> f64 { 6.2831853071795864769252867665590 } ## 2Ï€
fn half_pi() -> f64 { 1.5707963267948966192313216916398 }
fn e() -> f64 { 2.7182818284590452353602874713527 }

fn abs(value: f64) -> f64 {
  if value < 0.0 { -value } else { value }
}

fn abs_i64(value: i64) -> i64 {
  min_value := (-9223372036854775807_i64) - 1
  if value == min_value {
    raise OverflowError { operation: "abs_i64" }
  }
  if value < 0 { -value } else { value }
}

fn min(a: f64, b: f64) -> f64 {
  if a <= b { a } else { b }
}

fn max(a: f64, b: f64) -> f64 {
  if a >= b { a } else { b }
}

fn clamp(value: f64, min_value: f64, max_value: f64) -> f64 {
  if min_value > max_value {
    raise MathDomainError {
      message: "clamp requires min_value <= max_value",
      value: value
    }
  }
  if value < min_value { return min_value }
  if value > max_value { return max_value }
  value
}

fn clamp_i64(value: i64, min_value: i64, max_value: i64) -> i64 {
  if min_value > max_value {
    raise MathDomainError {
      message: "clamp_i64 requires min_value <= max_value",
      value: nil
    }
  }
  if value < min_value { return min_value }
  if value > max_value { return max_value }
  value
}

fn floor(value: f64) -> f64 { value.floor() }

fn ceil(value: f64) -> f64 { value.ceil() }

fn round(value: f64) -> f64 { value.round() }

fn trunc(value: f64) -> f64 {
  if value >= 0.0 { floor(value) } else { ceil(value) }
}

fn fract(value: f64) -> f64 { value.fract() }

fn clamp01(value: f64) -> f64 { clamp(value, 0.0, 1.0) }

fn gcd(a: i64, b: i64) -> i64 {
  if a == 0 && b == 0 {
    raise MathDomainError {
      message: "gcd undefined when both arguments are zero",
      value: nil
    }
  }
  x := abs_i64(a)
  y := abs_i64(b)
  loop {
    if y == 0 { break }
    remainder := x % y
    x = y
    y = remainder
  }
  x
}

fn lcm(a: i64, b: i64) -> i64 {
  if a == 0 || b == 0 { return 0 }
  divisor := gcd(a, b)
  normalized: i128 := ((a / divisor) as i128)
  product: i128 := normalized * (b as i128)
  min := (((-9223372036854775807_i64) - 1) as i128)
  max := (9223372036854775807_i64 as i128)
  if product < min || product > max {
    raise OverflowError { operation: "lcm" }
  }
  abs_i64(product as i64)
}

fn inverse_lerp(start: f64, end: f64, value: f64) -> f64 {
  if start == end {
    raise MathDomainError {
      message: "inverse_lerp requires start != end",
      value
    }
  }
  (value - start) / (end - start)
}

fn remap(value: f64, from_start: f64, from_end: f64, to_start: f64, to_end: f64) -> f64 {
  t := inverse_lerp(from_start, from_end, value)
  lerp(to_start, to_end, t)
}

fn remap_clamped(
  value: f64,
  from_start: f64,
  from_end: f64,
  to_start: f64,
  to_end: f64
) -> f64 {
  t := clamp01(inverse_lerp(from_start, from_end, value))
  lerp(to_start, to_end, t)
}

fn wrap(value: f64, min_value: f64, max_value: f64) -> f64 {
  if min_value >= max_value {
    raise MathDomainError {
      message: "wrap requires min_value < max_value",
      value
    }
  }
  width := max_value - min_value
  offset := value - min_value
  cycles := floor(offset / width)
  wrapped := offset - (cycles * width)
  result := wrapped + min_value
  if result >= max_value {
    result + (-width)
  } elsif result < min_value {
    result + width
  } else {
    result
  }
}

fn wrap_angle_radians(value: f64) -> f64 {
  wrap(value, -pi(), pi())
}

fn sign(value: f64) -> i32 {
  if value > 0.0 { 1 }
  elsif value < 0.0 { -1 }
  else { 0 }
}

fn sign_i64(value: i64) -> i32 {
  if value > 0 { 1 }
  elsif value < 0 { -1 }
  else { 0 }
}

fn deg_to_rad(value: f64) -> f64 {
  value * pi() / 180.0
}

fn rad_to_deg(value: f64) -> f64 {
  value * 180.0 / pi()
}

fn lerp(start: f64, end: f64, t: f64) -> f64 {
  start + (end - start) * t
}

fn approx_eq(a: f64, b: f64, tolerance: f64) -> bool {
  abs(a - b) <= abs(tolerance)
}

fn approx_eq_default(a: f64, b: f64) -> bool {
  approx_eq(a, b, __math_default_compare_tolerance())
}

fn hypot(a: f64, b: f64) -> f64 {
  sqrt(a * a + b * b)
}

fn sqrt(value: f64) -> f64 {
  if value < 0.0 {
    raise MathDomainError { message: "sqrt undefined for negative inputs", value }
  }
  if value == 0.0 { return 0.0 }

  guess := if value < 1.0 { 1.0 } else { value }
  tolerance := __math_default_tolerance()
  prev := guess
  iteration := 0
  loop {
    guess = 0.5 * (guess + value / guess)
    if abs(guess - prev) <= tolerance || iteration > 1000 {
      return guess
    }
    prev = guess
    iteration = iteration + 1
  }
  guess
}

fn pow(base: f64, exponent: i32) -> f64 {
  if exponent == 0 { return 1.0 }
  if base == 0.0 {
    if exponent < 0 {
      raise MathDomainError {
        message: "pow undefined for zero base with negative exponent",
        value: base
      }
    }
    return 0.0
  }

  negative := exponent < 0
  exp_value: i64 := exponent as i64
  if negative { exp_value = -exp_value }
  result := 1.0
  factor := base
  while exp_value > 0 {
    if exp_value % 2 == 1 { result = result * factor }
    factor = factor * factor
    exp_value = exp_value // 2
  }

  if negative { 1.0 / result } else { result }
}
