package linked_list_tests

import able.kernel.{Array}
import able.collections.array
import able.collections.linked_list.{LinkedList}

fn assert(condition: bool, message: String) -> void {
  if condition { return }
  raise message
}

fn expect_string(value: ?String, expected: String, message: String) -> void {
  value match {
    case actual: String => assert(actual == expected, message),
    case nil => { raise message }
  }
}

fn expect_i32(value: ?i32, expected: i32, message: String) -> void {
  value match {
    case actual: i32 => assert(actual == expected, message),
    case nil => { raise message }
  }
}

fn check_push_and_pop() -> void {
  list := LinkedList.new()
  list.push_front("b")
  list.push_front("a")
  list.push_back("c")

  assert(list.len() == 3, "len tracks pushes at both ends")
  expect_string(list.pop_front(), "a", "pop_front removes the head")
  expect_string(list.pop_back(), "c", "pop_back removes the tail")
  expect_string(list.pop_back(), "b", "pop_back clears the final element")
  assert(list.is_empty(), "list should be empty after pops")
}

fn check_insert_and_remove() -> void {
  list := LinkedList.new()
  head := list.push_back(1)
  middle := list.insert_after(head, 2)
  list.insert_after(middle, 3)

  assert(list.len() == 3, "insert_after links the new node")
  expect_i32(list.remove_node(middle), 2, "remove_node returns the removed value")
  assert(list.len() == 2, "remove_node updates length")

  acc := Array.new();
  for value in list {
    acc.push(value)
  }
  expect_i32(acc.get(0), 1, "for_each walks nodes in order")
  expect_i32(acc.get(1), 3, "for_each includes remaining nodes")
}

fn check_iteration() -> void {
  list := LinkedList.new()
  list.push_back(5)
  list.push_back(7)
  list.push_back(9)

  total := 0
  for value in list {
    total = total + value
  }
  assert(total == 21, "Iterable impl drives for-in loops")
}

fn main() -> void {
  check_push_and_pop()
  check_insert_and_remove()
  check_iteration()
}

main()
