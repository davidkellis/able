package range_tests

import able.kernel.{Range, RangeFactory}
import able.collections.range
import able.core.iteration.{IteratorEnd}

fn assert(condition: bool, message: String) -> void {
  if condition { return }
  raise message
}

fn check_inclusive_increasing() -> void {
  iter := RangeFactory.inclusive_range(1, 3).iterator()
  iter.next() match {
    case value: i32 => assert(value == 1, "inclusive range should start at the lower bound"),
    case IteratorEnd {} => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i32 => assert(value == 2, "inclusive range should include interior values"),
    case IteratorEnd {} => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i32 => assert(value == 3, "inclusive range should include the upper bound"),
    case IteratorEnd {} => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case IteratorEnd {} => {},
    case _ => { raise "expected iterator to be exhausted" }
  }
}

fn check_exclusive_decreasing() -> void {
  iter := RangeFactory.exclusive_range(3, 0).iterator()
  iter.next() match {
    case value: i32 => assert(value == 3, "exclusive range should start at the first value"),
    case IteratorEnd {} => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i32 => assert(value == 2, "exclusive descending range steps backward"),
    case IteratorEnd {} => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i32 => assert(value == 1, "exclusive descending range stops before the end bound"),
    case IteratorEnd {} => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case IteratorEnd {} => {},
    case _ => { raise "expected iterator to be exhausted" }
  }
}

fn main() -> void {
  check_inclusive_increasing()
  check_exclusive_decreasing()
}

main()
