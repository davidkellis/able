package collections.range.tests

import able.collections.range.{IntRangeFactory}
import able.core.iteration.{IteratorEnd}

fn assert(condition: bool, message: string) -> void {
  if condition { return }
  raise message
}

fn check_inclusive_increasing() -> void {
  iter := IntRangeFactory.inclusive_range(1, 3).iterator()
  iter.next() match {
    case value: i64 => assert(value == 1, "inclusive range should start at the lower bound"),
    case IteratorEnd => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i64 => assert(value == 2, "inclusive range should include interior values"),
    case IteratorEnd => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i64 => assert(value == 3, "inclusive range should include the upper bound"),
    case IteratorEnd => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case IteratorEnd => {},
    case _ => { raise "expected iterator to be exhausted" }
  }
}

fn check_exclusive_decreasing() -> void {
  iter := IntRangeFactory.exclusive_range(3, 0).iterator()
  iter.next() match {
    case value: i64 => assert(value == 3, "exclusive range should start at the first value"),
    case IteratorEnd => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i64 => assert(value == 2, "exclusive descending range steps backward"),
    case IteratorEnd => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case value: i64 => assert(value == 1, "exclusive descending range stops before the end bound"),
    case IteratorEnd => { raise "unexpected end of iterator" }
  }
  iter.next() match {
    case IteratorEnd => {},
    case _ => { raise "expected iterator to be exhausted" }
  }
}

fn main() -> void {
  check_inclusive_increasing()
  check_exclusive_decreasing()
}

main()
