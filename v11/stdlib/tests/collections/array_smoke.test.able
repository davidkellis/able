package collections.array.tests

import able.collections.array.{Array}
import able.core.errors.{IndexError}

fn assert(condition: bool, message: string) -> void {
  if condition { return }
  raise message
}

fn check_basic_ops() -> void {
  arr := Array.new()
  assert(arr.size() == 0, "new array should start empty")

  arr.push(1)
  arr.push(2)
  assert(arr.size() == 2, "push should grow size")

  arr.get(0) match {
    case value: i32 => assert(value == 1, "get should return first element"),
    case nil => { raise "expected value at index 0" }
  }

  arr.get(5) match {
    case nil => {},
    case _ => { raise "get should return nil for out-of-bounds index" }
  }

  arr.set(5, 9) match {
    case _: IndexError => {},
    case nil => { raise "set should return IndexError when out of bounds" }
  }

  arr.set(1, 7) match {
    case nil => {},
    case _: IndexError => { raise "set within bounds should return nil" }
  }

  arr.get(1) match {
    case value: i32 => assert(value == 7, "set should write updated value"),
    case nil => { raise "expected value at index 1 after set" }
  }

  popped := arr.pop()
  popped match {
    case value: i32 => assert(value == 7, "pop should return last element"),
    case nil => { raise "pop should return value when not empty" }
  }
  arr.pop()
  assert(arr.size() == 0, "pop should shrink size")

  arr.clear()
  assert(arr.size() == 0, "clear should empty the array")
  arr.pop() match {
    case nil => {},
    case _ => { raise "pop on empty array should return nil" }
  }
}

fn main() -> void {
  check_basic_ops()
}

main()
