package text.string_methods.specs

import able.testing.rspec.{describe, expect, eq}
import able.core.interfaces{Error}
import able.core.errors{RangeError}
import able.text.string.{String}

fn s(value: String) -> String {
  match String::from_builtin(value) {
    case ok: String => ok,
    case err: Error => raise err
  }
}

describe("String methods") { suite =>
  suite.it("reports lengths and prefixes/suffixes") { _ctx =>
    value := s("hello")
    expect(value.len_bytes()).to(eq(5))
    expect(value.len_chars()).to(eq(5))
    expect(value.len_graphemes()).to(eq(5))
    expect(value.starts_with(s("he"))).to(eq(true))
    expect(value.ends_with(s("lo"))).to(eq(true))
  }

  suite.it("slices substrings with bounds checking") { _ctx =>
    word := s("hello")
    match word.substring(1, 3) {
      case result: String => expect(result.to_builtin().unwrap()).to(eq("ell")),
      case err: Error => raise err
    }
    match word.substring(10) {
      case err: RangeError => expect(err.message()).to(eq("substring start out of range")),
      case other => raise other as Error
    }
  }

  suite.it("replaces all occurrences") { _ctx =>
    text := s("abcabc")
    replaced := text.replace(s("ab"), s("X"))
    expect(replaced.to_builtin().unwrap()).to(eq("XcXc"))
  }

  suite.it("splits on empty delimiter into graphemes") { _ctx =>
    parts := s("ab").split(s(""))
    expect(parts.len()).to(eq(2))
    expect(parts.get(0)!.to_builtin().unwrap()).to(eq("a"))
    expect(parts.get(1)!.to_builtin().unwrap()).to(eq("b"))
  }
}
