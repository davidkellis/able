package text.string_builder.specs

import able.testing.rspec.{describe, expect, eq}
import able.core.interfaces{Error}
import able.text.string.{String, StringBuilder}

fn make_string(value: String) -> String {
  match String::from_builtin(value) {
    case s: String => s,
    case err: Error => raise err
  }
}

describe("StringBuilder") { suite =>
  suite.it("pushes strings and finishes") { _ctx =>
    builder := StringBuilder::new()
    builder.push_string(make_string("Hello"))
    builder.push_string(make_string(" World"))
    match builder.finish() {
      case result: String => expect(result.to_builtin().unwrap()).to(eq("Hello World")),
      case err: Error => raise err
    }
  }

  suite.it("supports push_bytes and len") { _ctx =>
    bytes := make_string("!").bytes()
    builder := StringBuilder::with_capacity(4)
    builder.push_string(make_string("Hi"))
    builder.push_bytes(bytes)
    expect(builder.len_bytes()).to(eq(3))
  }

  suite.it("pushes chars, clears, and appends builders") { _ctx =>
    builder := StringBuilder::new()
    builder.push_char('A')
    builder.push_char('B')
    other := StringBuilder::new()
    other.push_string(make_string("C"))
    builder.append_builder(other)
    match builder.finish() {
      case s: String => expect(s.to_builtin().unwrap()).to(eq("ABC")),
      case err: Error => raise err
    }

    cleared := StringBuilder::new()
    cleared.push_char('Z')
    cleared.clear()
    cleared.push_char('Y')
    match cleared.finish() {
      case s: String => expect(s.to_builtin().unwrap()).to(eq("Y")),
      case err: Error => raise err
    }
  }
}
