package testing.specs

import able.testing.rspec.{describe, expect, be_truthy, be_false}
import able.core.interfaces.{Error}
import able.text.string.{String}
import able.text.automata.{
  NFABuilder,
  NFAChar,
  NFAEpsilon
}
import able.text.automata_dsl.{AutomataDSL}

fn make_string(value: string) -> String {
  match String::from_builtin(value) {
    case err: Error => raise err,
    case created: String => created
  }
}

describe("able.text.automata") { suite =>
  suite.module_path("text/automata")

  suite.it("matches literal sequences with loops") { _ctx =>
    builder := NFABuilder::new()
    start := builder.add_state()
    accept := builder.add_state()

    builder.set_start(start)
    builder.add_accept(accept)

    builder.add_transition(start, accept, NFAChar 'a')
    builder.add_transition(accept, accept, NFAChar 'b')

    nfa := builder.build()

    expect(nfa.matches(make_string("a"))).to(be_truthy())
    expect(nfa.matches(make_string("abbb"))).to(be_truthy())
    expect(nfa.matches(make_string("b"))).to(be_false())
  }

  suite.it("supports epsilon transitions and determinisation") { _ctx =>
    builder := NFABuilder::new()
    start := builder.add_state()
    mid := builder.add_state()
    accept := builder.add_state()

    builder.set_start(start)
    builder.add_accept(accept)

    builder.add_transition(start, accept, NFAEpsilon {})
    builder.add_transition(start, mid, NFAChar 'a')
    builder.add_transition(mid, accept, NFAChar 'b')

    nfa := builder.build()
    dfa := nfa.to_dfa()

    expect(nfa.matches(make_string(""))).to(be_truthy())
    expect(nfa.matches(make_string("ab"))).to(be_truthy())
    expect(nfa.matches(make_string("a"))).to(be_false())

    expect(dfa.matches(make_string(""))).to(be_truthy())
    expect(dfa.matches(make_string("ab"))).to(be_truthy())
    expect(dfa.matches(make_string("a"))).to(be_false())
  }

  suite.it("builds NFAs via the DSL") { _ctx =>
    expr := AutomataDSL.literal_string(make_string("ab")).concat(AutomataDSL.literal_char('c').star())
    nfa := expr.to_nfa()
    expect(nfa.matches(make_string("ab"))).to(be_truthy())
    expect(nfa.matches(make_string("abccc"))).to(be_truthy())
    expect(nfa.matches(make_string("a"))).to(be_false())
    expect(expr.to_dfa().matches(make_string("abccc"))).to(be_truthy())
  }

  suite.it("supports union and optional helpers") { _ctx =>
    expr := AutomataDSL.union(
      AutomataDSL.literal_char('x'),
      AutomataDSL.literal_char('y')
    ).optional()
    nfa := expr.to_nfa()
    expect(nfa.matches(make_string(""))).to(be_truthy())
    expect(nfa.matches(make_string("x"))).to(be_truthy())
    expect(nfa.matches(make_string("y"))).to(be_truthy())
    expect(nfa.matches(make_string("xy"))).to(be_false())
  }
}
