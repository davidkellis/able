package testing

import able.collections.array.{Array}

struct SnapshotEntry {
  name: String,
  value: String
}

struct SnapshotStore {
  read_fn: String -> ?String,
  write_fn: (String, String) -> void,
  update_fn: () -> bool
}

fn SnapshotStore(
  read_fn: String -> ?String,
  write_fn: (String, String) -> void,
  update_fn: () -> bool
) -> SnapshotStore {
  SnapshotStore { read_fn, write_fn, update_fn }
}

impl SnapshotStore {
  fn read(self: Self, name: String) -> ?String {
    self.read_fn(name)
  }

  fn write(self: Self, name: String, value: String) -> void {
    self.write_fn(name, value)
  }

  fn update_mode(self: Self) -> bool {
    self.update_fn()
  }
}

let mut DEFAULT_ENTRIES: Array SnapshotEntry = Array.new()
let mut DEFAULT_UPDATE_MODE: bool = false

fn default_snapshot_store() -> SnapshotStore {
  SnapshotStore(default_read, default_write, default_update_mode)
}

fn snapshot_set_update_mode(enabled: bool) -> void {
  DEFAULT_UPDATE_MODE = enabled
}

fn snapshot_clear() -> void {
  DEFAULT_ENTRIES = Array.new()
}

fn default_update_mode() -> bool { DEFAULT_UPDATE_MODE }

fn default_read(name: String) -> ?String {
  let mut idx = 0
  loop {
    if idx >= DEFAULT_ENTRIES.len() { break }
    match DEFAULT_ENTRIES.get(idx) {
      case nil => {},
      case entry: SnapshotEntry => {
        if entry.name == name { return entry.value }
      }
    }
    idx = idx + 1
  }
  nil
}

fn default_write(name: String, value: String) -> void {
  let mut idx = 0
  loop {
    if idx >= DEFAULT_ENTRIES.len() { break }
    match DEFAULT_ENTRIES.get(idx) {
      case nil => {},
      case entry: SnapshotEntry => {
        if entry.name == name {
          DEFAULT_ENTRIES.set(idx, SnapshotEntry { name, value })
          return
        }
      }
    }
    idx = idx + 1
  }
  DEFAULT_ENTRIES.push(SnapshotEntry { name, value })
}

