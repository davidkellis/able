## This file is generated by stdlib/src/testing/rspec/build.mjs
## Do not edit directly; update the files under stdlib/src/testing/rspec/parts and rerun the builder.
package rspec

import able.kernel.{Array}
import able.collections.array
import able.core.interfaces.{Error}
import able.testing.assertions.{
  AssertionError,
  BeFalseMatcher,
  BeNilMatcher,
  BeTruthyMatcher,
  BeEmptyArrayMatcher,
  BeWithinMatcher,
  ContainMatcher,
  ContainAllMatcher,
  BeGreaterThanMatcher,
  BeLessThanMatcher,
  BeBetweenMatcher,
  StartsWithMatcher,
  EndsWithMatcher,
  IncludeSubstringMatcher,
  SnapshotMatcher,
  MatchRegexMatcher,
  CustomMatcher,
  EqMatcher,
  Expectation,
  RaiseErrorMatcher,
  StringEqMatcher,
  be_false as assertions_be_false,
  be_nil as assertions_be_nil,
  be_truthy as assertions_be_truthy,
  be_empty_array as assertions_be_empty_array,
  be_within as assertions_be_within,
  contain as assertions_contain,
  contain_all as assertions_contain_all,
  be_greater_than as assertions_be_greater_than,
  be_less_than as assertions_be_less_than,
  be_between as assertions_be_between,
  start_with as assertions_start_with,
  end_with as assertions_end_with,
  include_substring as assertions_include_substring,
  match_snapshot as assertions_match_snapshot,
  match_snapshot_with_store as assertions_match_snapshot_with_store,
  match_regex as assertions_match_regex,
  matcher as assertions_matcher,
  matcher_with_details as assertions_matcher_with_details,
  eq as assertions_eq,
  eq_string as assertions_eq_string,
  expect as assertions_expect,
  failure_from_assertion,
  raise_error as assertions_raise_error,
  raise_error_with_message as assertions_raise_error_with_message
}
import able.testing.protocol.{
  DiscoveryRequest,
  Failure,
  Framework,
  MetadataEntry,
  Reporter,
  RunOptions,
  TestDescriptor,
  TestEvent,
  TestPlan
}
import able.testing.snapshots.{SnapshotStore}
import able.testing.registry.{register_framework}

const FRAMEWORK_ID = "able.testing.rspec"

struct RspecFramework;

struct SuiteConfig {
  allow_parallel: bool
}

struct SuiteState {
  key: String,
  path: Array String,
  module_path: String,
  tags: Array String,
  before_each: Array (ExampleContext -> void),
  after_each: Array (ExampleContext -> void),
  before_all: Array (ExampleContext -> void),
  after_all: Array (ExampleContext -> void),
  config: SuiteConfig
}

struct SuiteDefinition {
  key: String,
  path: Array String,
  before_all: Array (ExampleContext -> void),
  after_all: Array (ExampleContext -> void)
}

struct SuiteBuilder {
  state_index: i32
}

struct ExampleContext {}

struct ExampleDefinition {
  id: String,
  display_name: String,
  suite_key: String,
  suite_path: Array String,
  tags: Array String,
  before_each: Array (ExampleContext -> void),
  after_each: Array (ExampleContext -> void),
  body: ExampleContext -> void,
  module_path: String,
  skip: bool,
  focus: bool
}

let mut SUITE_STACK: Array SuiteState = Array.new()
let mut SUITES: Array SuiteDefinition = Array.new()
let mut EXAMPLES: Array ExampleDefinition = Array.new()

struct ExampleOptions {
  tags: Array String,
  skip: bool,
  focus: bool
}

fn example_options() -> ExampleOptions {
  ExampleOptions { tags: Array.new(), skip: false, focus: false }
}

impl ExampleOptions {
  fn tag(mut self: ExampleOptions, tag: String) -> ExampleOptions {
    self.tags.push(tag)
    self
  }

  fn tags(mut self: ExampleOptions, tags: Array String) -> ExampleOptions {
    let mut idx = 0
    loop {
      if idx >= tags.len() { break }
      match tags.get(idx) {
        case nil => {},
        case value: String => self.tags.push(value)
      }
      idx = idx + 1
    }
    self
  }

  fn skip(mut self: ExampleOptions) -> ExampleOptions {
    self.skip = true
    self
  }

  fn focus(mut self: ExampleOptions) -> ExampleOptions {
    self.focus = true
    self
  }
}

fn expect T (value: T) -> Expectation T {
  assertions_expect(value)
}

fn eq T (expected: T) -> EqMatcher T {
  assertions_eq(expected)
}

fn eq_string(expected: String) -> StringEqMatcher {
  assertions_eq_string(expected)
}

fn be_nil() -> BeNilMatcher {
  assertions_be_nil()
}

fn be_truthy() -> BeTruthyMatcher {
  assertions_be_truthy()
}

fn be_false() -> BeFalseMatcher {
  assertions_be_false()
}

fn be_empty_array T () -> BeEmptyArrayMatcher T {
  assertions_be_empty_array()
}

fn contain T (value: T) -> ContainMatcher T {
  assertions_contain(value)
}

fn be_within(delta: f64, target: f64) -> BeWithinMatcher {
  assertions_be_within(delta, target)
}

fn contain_all T (values: Array T) -> ContainAllMatcher T {
  assertions_contain_all(values)
}

fn be_greater_than(value: i64) -> BeGreaterThanMatcher i64 {
  assertions_be_greater_than(value)
}

fn be_less_than(value: i64) -> BeLessThanMatcher i64 {
  assertions_be_less_than(value)
}

fn match_snapshot(name: String) -> SnapshotMatcher {
  assertions_match_snapshot(name)
}

fn match_snapshot_with_store(name: String, store: SnapshotStore) -> SnapshotMatcher {
  assertions_match_snapshot_with_store(name, store)
}

fn match_regex(pattern: String) -> MatchRegexMatcher {
  assertions_match_regex(pattern)
}

fn be_between(lower: i64, upper: i64) -> BeBetweenMatcher i64 {
  assertions_be_between(lower, upper)
}

fn start_with(prefix: String) -> StartsWithMatcher {
  assertions_start_with(prefix)
}

fn end_with(suffix: String) -> EndsWithMatcher {
  assertions_end_with(suffix)
}

fn include_substring(substring: String) -> IncludeSubstringMatcher {
  assertions_include_substring(substring)
}

fn matcher T (
  message: String,
  negated_message: String,
  predicate: T -> bool
) -> CustomMatcher T {
  assertions_matcher(message, negated_message, predicate)
}

fn matcher_with_details T (
  message: String,
  negated_message: String,
  predicate: T -> bool,
  detail: T -> ?String
) -> CustomMatcher T {
  assertions_matcher_with_details(message, negated_message, predicate, detail)
}

fn raise_error() -> RaiseErrorMatcher {
  assertions_raise_error()
}

fn raise_error_with_message(message: String) -> RaiseErrorMatcher {
  assertions_raise_error_with_message(message)
}

fn describe(name: String, body: SuiteBuilder -> void) -> void {
  let builder = push_suite(name)
  body(builder)
  pop_suite()
}

fn context(name: String, body: SuiteBuilder -> void) -> void {
  describe(name, body)
}

impl SuiteBuilder {
  fn it(self: Self, name: String, body: ExampleContext -> void) -> void {
    self.register_example(name, empty_string_array(), body, false, false)
  }

  fn it_tags(self: Self, name: String, tags: Array String, body: ExampleContext -> void) -> void {
    self.register_example(name, tags, body, false, false)
  }

  fn it_skip(self: Self, name: String, body: ExampleContext -> void) -> void {
    self.register_example(name, empty_string_array(), body, true, false)
  }

  fn it_only(self: Self, name: String, body: ExampleContext -> void) -> void {
    self.register_example(name, empty_string_array(), body, false, true)
  }

  fn it_opts(self: Self, name: String, options: ExampleOptions, body: ExampleContext -> void) -> void {
    self.register_example(name, clone_string_array(options.tags), body, options.skip, options.focus)
  }

  fn describe(self: Self, name: String, body: SuiteBuilder -> void) -> void {
    describe(name, body)
  }

  fn context(self: Self, name: String, body: SuiteBuilder -> void) -> void {
    describe(name, body)
  }

  fn before_each(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    match SUITE_STACK.get(self.state_index) {
      case nil => {},
      case state: SuiteState => {
        let mut updated = state
        updated.before_each.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }

  fn after_each(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    match SUITE_STACK.get(self.state_index) {
      case nil => {},
      case state: SuiteState => {
        let mut updated = state
        updated.after_each.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }

  fn before_all(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    match SUITE_STACK.get(self.state_index) {
      case nil => {},
      case state: SuiteState => {
        let mut updated = state
        updated.before_all.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }

  fn after_all(self: Self, hook: ExampleContext -> void) -> void {
    if self.state_index < 0 { return }
    match SUITE_STACK.get(self.state_index) {
      case nil => {},
      case state: SuiteState => {
        let mut updated = state
        updated.after_all.push(hook)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }

  fn tag(self: Self, tag: String) -> void {
    if self.state_index < 0 { return }
    match SUITE_STACK.get(self.state_index) {
      case nil => {},
      case state: SuiteState => {
        let mut updated = state
        updated.tags.push(tag)
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }

  fn tags(self: Self, tags: Array String) -> void {
    let mut idx = 0
    loop {
      if idx >= tags.len() { break }
      match tags.get(idx) {
        case nil => {},
        case tag: String => self.tag(tag)
      }
      idx = idx + 1
    }
  }

  fn module_path(self: Self, path: String) -> void {
    if self.state_index < 0 { return }
    match SUITE_STACK.get(self.state_index) {
      case nil => {},
      case state: SuiteState => {
        let mut updated = state
        updated.module_path = path
        SUITE_STACK.set(self.state_index, updated)
      }
    }
  }

  fn register_example(
    self: Self,
    name: String,
    tags: Array String,
    body: ExampleContext -> void,
    skip: bool,
    focus: bool
  ) -> void {
    if self.state_index < 0 { return }
    match SUITE_STACK.get(self.state_index) {
      case nil => {},
      case state: SuiteState => {
        let stored_path = clone_string_array(state.path)
        let suite_key = build_suite_key(stored_path)
        let mut full_tags = merge_tags(state.tags, tags)
        if skip { full_tags.push("skip") }
        if focus { full_tags.push("focus") }
        EXAMPLES.push(ExampleDefinition {
          id: build_example_id(stored_path, name),
          display_name: build_example_display(stored_path, name),
          suite_key,
          suite_path: stored_path,
          tags: full_tags,
          before_each: clone_hook_array(state.before_each),
          after_each: clone_hook_array(state.after_each),
          body,
          module_path: state.module_path,
          skip,
          focus
        })
      }
    }
  }
}

fn push_suite(name: String) -> SuiteBuilder {
  let parent_index = SUITE_STACK.len() - 1
  let mut path: Array String = Array.new()
  let mut module_path = ""
  let mut tags: Array String = Array.new()
  let mut before_each: Array (ExampleContext -> void) = Array.new()
  let mut after_each: Array (ExampleContext -> void) = Array.new()
  let mut before_all: Array (ExampleContext -> void) = Array.new()
  let mut after_all: Array (ExampleContext -> void) = Array.new()
  let mut config = SuiteConfig { allow_parallel: false }

  if parent_index >= 0 {
    match SUITE_STACK.get(parent_index) {
      case nil => {},
      case parent: SuiteState => {
        path = clone_string_array(parent.path)
        module_path = parent.module_path
        tags = clone_string_array(parent.tags)
        before_each = clone_hook_array(parent.before_each)
        after_each = clone_hook_array(parent.after_each)
        config = parent.config
      }
    }
  }

  path.push(name)
  if module_path == "" {
    module_path = build_suite_key(path)
  }
  let state = SuiteState {
    key: build_suite_key(path),
    path,
    module_path,
    tags,
    before_each,
    after_each,
    before_all,
    after_all,
    config
  }

  SUITE_STACK.push(state)
  SuiteBuilder { state_index: (SUITE_STACK.len() - 1) as i32 }
}

fn pop_suite() -> void {
  match SUITE_STACK.pop() {
    case nil => {},
    case state: SuiteState => register_suite(state)
  }
}

fn register_suite(state: SuiteState) -> void {
  let definition = SuiteDefinition {
    key: state.key,
    path: clone_string_array(state.path),
    before_all: clone_hook_array(state.before_all),
    after_all: clone_hook_array(state.after_all)
  }

  let mut idx = 0
  loop {
    if idx >= SUITES.len() { break }
    match SUITES.get(idx) {
      case nil => {},
      case existing: SuiteDefinition => {
        if existing.key == state.key {
          SUITES.set(idx, definition)
          return
        }
      }
    }
    idx = idx + 1
  }

  SUITES.push(definition)
}

fn find_suite(key: String) -> ?SuiteDefinition {
  let mut idx = 0
  loop {
    if idx >= SUITES.len() { break }
    match SUITES.get(idx) {
      case nil => {},
      case suite: SuiteDefinition => {
        if suite.key == key { return suite }
      }
    }
    idx = idx + 1
  }
  nil
}

fn find_example(id: String) -> ?ExampleDefinition {
  let mut idx = 0
  loop {
    if idx >= EXAMPLES.len() { break }
    match EXAMPLES.get(idx) {
      case nil => {},
      case example: ExampleDefinition => {
        if example.id == id { return example }
      }
    }
    idx = idx + 1
  }
  nil
}

fn build_suite_key(path: Array String) -> String {
  join_segments(path, "::")
}

fn build_example_id(path: Array String, name: String) -> String {
  let mut segments = clone_string_array(path)
  segments.push(name)
  join_segments(segments, "::")
}

fn build_example_display(path: Array String, name: String) -> String {
  let mut segments = clone_string_array(path)
  segments.push(name)
  join_segments(segments, " ")
}

fn join_segments(segments: Array String, separator: String) -> String {
  let mut result = ""
  let mut idx = 0
  loop {
    if idx >= segments.len() { break }
    match segments.get(idx) {
      case nil => {},
      case segment: String => {
        if result == "" {
          result = segment
        } else {
          result = `${result}${separator}${segment}`
        }
      }
    }
    idx = idx + 1
  }
  result
}

fn clone_string_array(source: Array String) -> Array String {
  let mut result: Array String = Array.new()
  let mut idx = 0
  loop {
    if idx >= source.len() { break }
    match source.get(idx) {
      case nil => {},
      case value: String => result.push(value)
    }
    idx = idx + 1
  }
  result
}

fn clone_hook_array(source: Array (ExampleContext -> void)) -> Array (ExampleContext -> void) {
  let mut result: Array (ExampleContext -> void) = Array.new()
  let mut idx = 0
  loop {
    if idx >= source.len() { break }
    match source.get(idx) {
      case nil => {},
      case hook: (ExampleContext -> void) => result.push(hook)
    }
    idx = idx + 1
  }
  result
}

fn merge_tags(base: Array String, extra: Array String) -> Array String {
  let mut result = clone_string_array(base)
  let mut idx = 0
  loop {
    if idx >= extra.len() { break }
    match extra.get(idx) {
      case nil => {},
      case value: String => result.push(value)
    }
    idx = idx + 1
  }
  result
}

fn empty_string_array() -> Array String { Array.new() }

fn contains_substring(target: String, needles: Array String) -> bool {
  if needles.len() == 0 { return true }
  let mut idx = 0
  loop {
    if idx >= needles.len() { break }
    match needles.get(idx) {
      case nil => {},
      case needle: String => {
        if needle == "" { return true }
        if target == needle { return true }
      }
    }
    idx = idx + 1
  }
  false
}

fn array_contains(array: Array String, value: String) -> bool {
  let mut idx = 0
  loop {
    if idx >= array.len() { break }
    match array.get(idx) {
      case nil => {},
      case element: String => {
        if element == value { return true }
      }
    }
    idx = idx + 1
  }
  false
}

fn matches_tags(tags: Array String, include: Array String, exclude: Array String) -> bool {
  let mut idx = 0
  loop {
    if idx >= include.len() { break }
    match include.get(idx) {
      case nil => {},
      case tag: String => {
        if !array_contains(tags, tag) { return false }
      }
    }
    idx = idx + 1
  }

  idx = 0
  loop {
    if idx >= exclude.len() { break }
    match exclude.get(idx) {
      case nil => {},
      case tag: String => {
        if array_contains(tags, tag) { return false }
      }
    }
    idx = idx + 1
  }
  true
}

fn matches_names(example: ExampleDefinition, include: Array String, exclude: Array String) -> bool {
  let id = example.id
  let name = example.display_name
  if include.len() > 0 {
    if !contains_substring(id, include) && !contains_substring(name, include) {
      return false
    }
  }
  if contains_substring(id, exclude) || contains_substring(name, exclude) {
    return false
  }
  true
}

fn matches_paths(module_path: String, include: Array String, exclude: Array String) -> bool {
  if include.len() > 0 {
    if module_path == "" { return false }
    if !contains_substring(module_path, include) { return false }
  }
  if module_path != "" && contains_substring(module_path, exclude) { return false }
  true
}

fn matches_filters(example: ExampleDefinition, request: DiscoveryRequest) -> bool {
  if !matches_tags(example.tags, request.include_tags, request.exclude_tags) {
    return false
  }
  if !matches_names(example, request.include_names, request.exclude_names) {
    return false
  }
  if !matches_paths(example.module_path, request.include_paths, request.exclude_paths) {
    return false
  }
  true
}

fn suite_prefix_keys(path: Array String) -> Array String {
  let mut keys: Array String = Array.new()
  let mut idx = 0
  loop {
    if idx >= path.len() { break }
    let mut prefix: Array String = Array.new()
    let mut inner = 0
    loop {
      if inner > idx { break }
      match path.get(inner) {
        case nil => {},
        case segment: String => prefix.push(segment)
      }
      inner = inner + 1
    }
    keys.push(build_suite_key(prefix))
    idx = idx + 1
  }
  keys
}

fn contains_string(array: Array String, needle: String) -> bool {
  let mut idx = 0
  loop {
    if idx >= array.len() { break }
    match array.get(idx) {
      case nil => {},
      case value: String => {
        if value == needle { return true }
      }
    }
    idx = idx + 1
  }
  false
}

fn run_hook_sequence(hooks: Array (ExampleContext -> void), ctx: ExampleContext) -> ?Failure {
  let mut idx = 0
  loop {
    if idx >= hooks.len() { break }
    match hooks.get(idx) {
      case nil => {},
      case hook: (ExampleContext -> void) => {
        let mut failure: ?Failure = nil
        let _ = do { hook(ctx) } rescue {
          case assertion: AssertionError => {
            failure = failure_from_assertion(assertion)
            nil
          },
          case err: Error => {
            failure = Failure { message: err.message(), details: nil, location: nil }
            nil
          }
        }
        match failure {
          case nil => {},
          case _ => { return failure }
        }
      }
    }
    idx = idx + 1
  }
  nil
}

fn run_hook_sequence_reverse(hooks: Array (ExampleContext -> void), ctx: ExampleContext) -> ?Failure {
  let mut idx = hooks.len() - 1
  loop {
    if idx < 0 { break }
    match hooks.get(idx) {
      case nil => {},
      case hook: (ExampleContext -> void) => {
        let mut failure: ?Failure = nil
        let _ = do { hook(ctx) } rescue {
          case assertion: AssertionError => {
            failure = failure_from_assertion(assertion)
            nil
          },
          case err: Error => {
            failure = Failure { message: err.message(), details: nil, location: nil }
            nil
          }
        }
        match failure {
          case nil => {},
          case _ => { return failure }
        }
      }
    }
    idx = idx - 1
  }
  nil
}

fn run_before_all_for_suite(key: String, executed: Array String) -> ?Failure {
  match find_suite(key) {
    case nil => nil,
    case suite: SuiteDefinition => {
      if contains_string(executed, key) { return nil }
      let ctx = ExampleContext {}
      let failure = run_hook_sequence(suite.before_all, ctx)
      match failure {
        case nil => {},
        case _ => { return failure }
      }
      nil
    }
  }
}

fn run_after_all_for_suites(keys: Array String, reporter: Reporter) -> void {
  let mut idx = keys.len() - 1
  loop {
    if idx < 0 { break }
    match keys.get(idx) {
      case nil => {},
      case key: String => {
        match find_suite(key) {
          case nil => {},
          case suite: SuiteDefinition => {
            let ctx = ExampleContext {}
            match run_hook_sequence_reverse(suite.after_all, ctx) {
              case nil => {},
              case failure: Failure => reporter.emit(TestEvent.framework_error { message: failure.message })
            }
          }
        }
      }
    }
    idx = idx - 1
  }
}

impl Framework for RspecFramework {
  fn id(self: Self) -> String { FRAMEWORK_ID }

  fn discover(
    self: Self,
    request: DiscoveryRequest,
    register: TestDescriptor -> void
  ) -> void | Failure {
    let mut idx = 0
    loop {
      if idx >= EXAMPLES.len() { break }
      match EXAMPLES.get(idx) {
        case nil => {},
        case example: ExampleDefinition => {
          if !matches_filters(example, request) {
            idx = idx + 1
            continue
          }

          let mut metadata: Array MetadataEntry = Array.new()
          metadata.push(MetadataEntry { key: "suite_path", value: build_suite_key(example.suite_path) })
          if example.module_path != "" {
            metadata.push(MetadataEntry { key: "module_path", value: example.module_path })
          }
          if example.tags.len() > 0 {
            metadata.push(MetadataEntry { key: "tags", value: join_segments(example.tags, ",") })
          }

          register(TestDescriptor {
            framework_id: FRAMEWORK_ID,
            module_path: example.module_path,
            test_id: example.id,
            display_name: example.display_name,
            location: nil,
            tags: clone_string_array(example.tags),
            metadata
          })
        }
      }
      idx = idx + 1
    }
  }

  fn run(
    self: Self,
    plan: TestPlan,
    options: RunOptions,
    reporter: Reporter
  ) -> void | Failure {
    let mut executed_suite_keys: Array String = Array.new()
    let mut idx = 0
    loop {
      if idx >= plan.descriptors.len() { break }
      match plan.descriptors.get(idx) {
        case nil => {},
        case descriptor: TestDescriptor => {
          match find_example(descriptor.test_id) {
            case nil => {
              run_after_all_for_suites(executed_suite_keys, reporter)
              return Failure {
                message: `unknown test id ${descriptor.test_id}`,
                details: nil,
                location: nil
              }
            },
            case example: ExampleDefinition => {
              if tag_list_contains(descriptor.tags, "skip") {
                reporter.emit(TestEvent.case_skipped { descriptor, reason: "skipped" })
                idx = idx + 1
                continue
              } else {
                reporter.emit(TestEvent.case_started { descriptor })

              let prefix_keys = suite_prefix_keys(example.suite_path)
              let mut prefix_idx = 0
              loop {
                if prefix_idx >= prefix_keys.len() { break }
                match prefix_keys.get(prefix_idx) {
                  case nil => {},
                  case key: String => {
                    match run_before_all_for_suite(key, executed_suite_keys) {
                      case nil => {
                        if !contains_string(executed_suite_keys, key) {
                          executed_suite_keys.push(key)
                        }
                      },
                      case failure: Failure => {
                        reporter.emit(TestEvent.case_failed {
                          descriptor,
                          duration_ms: 0,
                          failure
                        })
                        run_after_all_for_suites(executed_suite_keys, reporter)
                        return nil
                      }
                    }
                  }
                }
                prefix_idx = prefix_idx + 1
              }

              let ctx = ExampleContext {}
              let before_failure = run_hook_sequence(example.before_each, ctx)
              let mut failure: ?Failure = before_failure

              if failure == nil {
                let mut body_failure: ?Failure = nil
                let _ = do { example.body(ctx) } rescue {
                  case assertion: AssertionError => {
                    body_failure = failure_from_assertion(assertion)
                    nil
                  },
                  case err: Error => {
                    body_failure = Failure { message: err.message(), details: nil, location: nil }
                    nil
                  }
                }
                match body_failure {
                  case nil => {},
                  case _ => { failure = body_failure }
                }
              }

              let after_failure = run_hook_sequence_reverse(example.after_each, ctx)
              if failure == nil {
                failure = after_failure
              }

                match failure {
                  case nil => reporter.emit(TestEvent.case_passed { descriptor, duration_ms: 0 }),
                  case fail: Failure => reporter.emit(TestEvent.case_failed {
                    descriptor,
                    duration_ms: 0,
                    failure: fail
                  })
                }

                if options.fail_fast {
                  match failure {
                    case nil => {},
                    case _ => {
                      run_after_all_for_suites(executed_suite_keys, reporter)
                      return nil
                    }
                  }
                }
              }
            }
          }
        }
      }
      idx = idx + 1
    }

    run_after_all_for_suites(executed_suite_keys, reporter)
    nil
  }
}

fn tag_list_contains(tags: Array String, needle: String) -> bool {
  let mut idx = 0
  loop {
    if idx >= tags.len() { break }
    match tags.get(idx) {
      case nil => {},
      case value: String => {
        if value == needle { return true }
      }
    }
    idx = idx + 1
  }
  false
}

struct RspecFramework;

fn __clear_examples_for_tests() -> void {
  EXAMPLES = Array.new()
  SUITES = Array.new()
  SUITE_STACK = Array.new()
}

register_framework(RspecFramework)
