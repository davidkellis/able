package collections

import able.core.iteration{Iterator, Iterable, Range}

struct IntRange {
  start: i32,
  end: i32,
  inclusive: bool
}

impl Iterable i32 for IntRange {
  fn iterator(self: Self) -> (Iterator i32) {
    Iterator i32 { gen =>
      step := if self.end >= self.start { 1 } else { -1 }
      current := self.start
      loop {
        if step > 0 {
          if self.inclusive {
            if current > self.end {
              gen.stop()
            }
          } else if current >= self.end {
            gen.stop()
          }
        } else {
          if self.inclusive {
            if current < self.end {
              gen.stop()
            }
          } else if current <= self.end {
            gen.stop()
          }
        }
        gen.yield(current)
        current = current + step
      }
    }
  }
}

struct IntRangeFactory;

impl Range i32 i32 i32 for IntRangeFactory {
  fn inclusive_range(start: i32, finish: i32) -> Iterable i32 {
    IntRange { start: start, end: finish, inclusive: true }
  }

  fn exclusive_range(start: i32, finish: i32) -> Iterable i32 {
    IntRange { start: start, end: finish, inclusive: false }
  }
}
