package exec_12_02_proc_fairness_cancellation

## Semantics: proc_yield requeues behind runnable work, proc_cancelled observes cancellation, proc_flush drains.

fn main() -> void {
  do {
    trace := ""
    first_stage := 0
    second_stage := 0

    first := proc {
      if first_stage == 0 {
        trace = trace + "A"
        first_stage = 1
        proc_yield()
      }
      if first_stage == 1 {
        trace = trace + "B"
        first_stage = 2
      }
    }

    second := proc {
      if second_stage == 0 {
        trace = trace + "1"
        second_stage = 1
        proc_yield()
      }
      if second_stage == 1 {
        trace = trace + "2"
        second_stage = 2
      }
    }

    proc_flush()

    status_first := first.status() match {
      case Pending {} => "Pending",
      case Resolved {} => "Resolved",
      case Cancelled {} => "Cancelled",
      case Failed { error } => "Failed",
      case _ => "Other"
    }
    status_second := second.status() match {
      case Pending {} => "Pending",
      case Resolved {} => "Resolved",
      case Cancelled {} => "Cancelled",
      case Failed { error } => "Failed",
      case _ => "Other"
    }

    print(`fair trace ${trace}`)
    print(`fair status ${status_first} ${status_second}`)
  }

  do {
    cancel_stage := 0
    cancelled_seen := false

    worker := proc {
      if cancel_stage == 0 {
        cancel_stage = 1
        proc_yield()
      }
      if cancel_stage == 1 {
        cancelled_seen = proc_cancelled()
        cancel_stage = 2
      }
    }

    canceller := proc {
      worker.cancel()
    }

    proc_flush()

    cancel_status := worker.status() match {
      case Pending {} => "Pending",
      case Resolved {} => "Resolved",
      case Cancelled {} => "Cancelled",
      case Failed { error } => "Failed",
      case _ => "Other"
    }

    print(`cancel stage ${cancel_stage}`)
    print(`cancel seen ${cancelled_seen}`)
    print(`cancel status ${cancel_status}`)
    print(`pending ${proc_pending_tasks()}`)
  }
}
